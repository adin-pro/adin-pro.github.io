<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Coursera算法笔记Union-Find</title>
    <url>/2020/04/25/Coursera%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0Union-Find/</url>
    <content><![CDATA[<p>Coursera上的算法课程笔记,对应书本为Algorithm 4th Edition。这一章介绍的是Union-Find问题。</p>
<a id="more"></a>
<h2 id="Dynamic-connectivity"><a href="#Dynamic-connectivity" class="headerlink" title="Dynamic connectivity"></a>Dynamic connectivity</h2><p>Given a set of N objects </p>
<ul>
<li>union command: connect  two objects</li>
<li>Find/connected query: is there  a path connecting the two objects?</li>
</ul>
<p>We assume “Is connected to” is an equivalence relation:</p>
<ul>
<li>reflexive: p is connected to p (自己永远连接到自己)</li>
<li>symmetric: 连接是对称的</li>
<li>transitive: 连接是可以传递的</li>
</ul>
<p><strong>Connected Component</strong>: maximum set of objects that are mutually(相互)<br>onnected, like {0} {1,4,5} {7,9} {8}所以连接在一起的节点都是一个集合里面的元素</p>
<ul>
<li>union command: replace two sets of nodes to be connected with a union</li>
<li>find query: are two nodes in same set</li>
</ul>
<script type="math/tex; mode=display">
union(1,2) \; union(3,4) \; union(5,6) \;union(1,5) \; union (2,6)\\
two\; sets:\{1,2,5,6\}\;\{3,4\} \\
connected(1,6):true</script><div class="table-container">
<table>
<thead>
<tr>
<th>public class UF</th>
<th>Func</th>
</tr>
</thead>
<tbody>
<tr>
<td>UF(int N)</td>
<td>initilize union-find data structure</td>
</tr>
<tr>
<td>void union(int p, int q)</td>
<td>add connection between q and p</td>
</tr>
<tr>
<td>boolean connected(int p, int q)</td>
<td>are two nodes in the same component?</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Quick-Find-eager-approach"><a href="#Quick-Find-eager-approach" class="headerlink" title="Quick Find [eager approach]"></a>Quick Find [eager approach]</h2><p><img src='image1.png' width = '800' title = 'eager approach'></p>
<ul>
<li>Find: check if id[p] = id[q]</li>
<li>Union: change all entries whose values equals to id[p] and id[q]</li>
</ul>
<blockquote>
<p>the method “Find” is quick, o(1) ,so named quick-find<br>but “union” is too expensive , o(n), if you want to do n times union operation on a array of n,  o(n^2)</p>
</blockquote>
<h2 id="Quick-Union-lazy-approach"><a href="#Quick-Union-lazy-approach" class="headerlink" title="Quick Union [lazy approach]"></a>Quick Union [lazy approach]</h2><blockquote>
<p>we try to avoid work unitl we have to</p>
</blockquote>
<p><img src='image2.png' width = '800' title = 'lazy approach'></p>
<ul>
<li>find: check if p and q have the same root O(n)</li>
<li>union: to merge components containing p and q, set thr id of p’s root to the id of q’s root, O(n)</li>
</ul>
<blockquote>
<p>It still works not very well</p>
</blockquote>
<h2 id="Quick-Union-Improvements"><a href="#Quick-Union-Improvements" class="headerlink" title="Quick Union Improvements"></a>Quick Union Improvements</h2><h3 id="Weighted-quick-union"><a href="#Weighted-quick-union" class="headerlink" title="Weighted quick union"></a>Weighted quick union</h3><p>避免将大树🌳放在小树  下面，让数目尽可能平衡</p>
<p>decease the depth of the tree, making depth of any node is at most</p>
<h3 id="Flatten-Path-Compression"><a href="#Flatten-Path-Compression" class="headerlink" title="Flatten! Path Compression"></a>Flatten! Path Compression</h3><p><img src='image3.png' width = '800' title = 'flatten'></p>
<p>let the node point to the roof every time the  method ‘roof’ called</p>
<p><a href="https://coursera.cs.princeton.edu/algs4/assignments/percolation/specification.php" target="_blank" rel="noopener">Assignment1: Percolation</a></p>
<h2 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">One Complementation</span><br><span class="line">/* *****************************************************************************</span><br><span class="line"> *  Name:Adin</span><br><span class="line"> *  Date:<span class="number">2020.1</span><span class="number">.1</span></span><br><span class="line"> *  Description:Percolation demo</span><br><span class="line"> **************************************************************************** */</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.WeightedQuickUnionUF;</span><br><span class="line"></span><br><span class="line">public class Percolation &#123;</span><br><span class="line"></span><br><span class="line">    // num of columns <span class="keyword">and</span> rows</span><br><span class="line">    private int num;</span><br><span class="line">    // WQUUF object</span><br><span class="line">    private WeightedQuickUnionUF uf;</span><br><span class="line">    // status sites blockes=<span class="number">0</span> open=<span class="number">1</span></span><br><span class="line">    private boolean[][] sites;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // creates n-by-n grid, <span class="keyword">with</span> all sites initially blocked</span><br><span class="line">    public Percolation(int n) &#123;</span><br><span class="line">        num = n;</span><br><span class="line">        check(n);</span><br><span class="line">        uf = new WeightedQuickUnionUF(n * n + <span class="number">1</span>);</span><br><span class="line">        sites = new boolean[n][n];</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            uf.union(value(<span class="number">1</span>, i + <span class="number">1</span>), num * num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // check invalidation</span><br><span class="line">    private void check(int num1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 &lt;= <span class="number">0</span> || num1 &gt; this.num)</span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid range of n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // calculate the <span class="comment"># of sites</span></span><br><span class="line">    private int value(int row, int col) &#123;</span><br><span class="line">        <span class="keyword">return</span> (row - <span class="number">1</span>) * num + col - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // opens the site (row, col) <span class="keyword">if</span> it <span class="keyword">is</span> <span class="keyword">not</span> open already</span><br><span class="line">    public void open(int row, int col) &#123;</span><br><span class="line">        check(row);</span><br><span class="line">        check(col);</span><br><span class="line">        <span class="keyword">if</span> (isOpen(row, col)) <span class="keyword">return</span>;</span><br><span class="line">        // open the site</span><br><span class="line">        sites[row - <span class="number">1</span>][col - <span class="number">1</span>] = true;</span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">1</span> &amp;&amp; isOpen(row - <span class="number">1</span>, col)) uf.union(value(row, col), value(row - <span class="number">1</span>, col));</span><br><span class="line">        <span class="keyword">if</span> (row &lt; num &amp;&amp; isOpen(row + <span class="number">1</span>, col)) uf.union(value(row, col), value(row + <span class="number">1</span>, col));</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">1</span> &amp;&amp; isOpen(row, col - <span class="number">1</span>)) uf.union(value(row, col), value(row, col - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (col &lt; num &amp;&amp; isOpen(row, col + <span class="number">1</span>)) uf.union(value(row, col), value(row, col + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // is the site (row, col) open?</span><br><span class="line">    public boolean isOpen(int row, int col) &#123;</span><br><span class="line">        check(row);</span><br><span class="line">        check(col);</span><br><span class="line">        <span class="keyword">return</span> sites[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // is the site (row, col) full?</span><br><span class="line">    public boolean isFull(int row, int col) &#123;</span><br><span class="line">        <span class="keyword">return</span> isOpen(row, col) &amp;&amp; (uf.find(value(row, col)) == uf.find(num * num));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // returns the number of open sites</span><br><span class="line">    public int numberOfOpenSites() &#123;</span><br><span class="line">        int count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">                <span class="keyword">if</span> (sites[i][j]) count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // does the system percolate?</span><br><span class="line">    public boolean percolates() &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isOpen(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="keyword">if</span> (uf.find(value(num, i + <span class="number">1</span>)) == uf.find(num * num))</span><br><span class="line">                <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/* *****************************************************************************</span><br><span class="line"> *  Name:Adin</span><br><span class="line"> *  Date:<span class="number">2020.1</span><span class="number">.1</span></span><br><span class="line"> *  Description:</span><br><span class="line"> **************************************************************************** */</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdStats;</span><br><span class="line"></span><br><span class="line">public class PercolationStats &#123;</span><br><span class="line"></span><br><span class="line">    private double mean;</span><br><span class="line">    private double stddev;</span><br><span class="line">    private double confilo;</span><br><span class="line">    private double confihi;</span><br><span class="line">    private int[] openSites;</span><br><span class="line">    private int openNum;</span><br><span class="line"></span><br><span class="line">    // perform independent trials on an n-by-n grid</span><br><span class="line">    public PercolationStats(int n, int trials) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || trials &lt;= <span class="number">0</span>)</span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid input : n or trials musu &gt; 0 !"</span>);</span><br><span class="line"></span><br><span class="line">        double[] threshold = new double[trials];</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; trials; i++) &#123;</span><br><span class="line">            // start of one trial</span><br><span class="line">            // initialize the sites</span><br><span class="line">            Percolation perco = new Percolation(n);</span><br><span class="line">            // StdRandom.setSeed(StdRandom.getSeed());</span><br><span class="line">            // choose a random number of open sites</span><br><span class="line">            openSites = StdRandom.permutation(n * n);</span><br><span class="line">            // start this trial</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; n * n; j++) &#123;</span><br><span class="line">                perco.open(openSites[j] / n + <span class="number">1</span>, openSites[j] % n + <span class="number">1</span>);</span><br><span class="line">                // <span class="keyword">if</span> percolate, stop the trial</span><br><span class="line">                <span class="keyword">if</span> (perco.percolates()) &#123;</span><br><span class="line">                    threshold[i] = (j + <span class="number">1</span>) * <span class="number">1.0</span> / (n * n) * <span class="number">1.0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                threshold[i] = <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // end of one trial</span><br><span class="line">        &#125;</span><br><span class="line">        // end of all trials</span><br><span class="line">        mean = StdStats.mean(threshold);</span><br><span class="line">        stddev = StdStats.stddev(threshold);</span><br><span class="line">        confilo = mean - stddev * <span class="number">1.96</span> / Math.sqrt((double) trials);</span><br><span class="line">        confihi = mean + stddev * <span class="number">1.96</span> / Math.sqrt((double) trials);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // sample mean of percolation threshold</span><br><span class="line">    public double mean() &#123;</span><br><span class="line">        <span class="keyword">return</span> mean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // sample standard deviation of percolation threshold</span><br><span class="line">    public double stddev() &#123;</span><br><span class="line">        <span class="keyword">return</span> stddev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // low endpoint of <span class="number">95</span>% confidence interval</span><br><span class="line">    public double confidenceLo() &#123;</span><br><span class="line">        <span class="keyword">return</span> confilo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // high endpoint of <span class="number">95</span>% confidence interval</span><br><span class="line">    public double confidenceHi() &#123;</span><br><span class="line">        <span class="keyword">return</span> confihi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // test client (see below)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StdOut.print(<span class="string">"Trials start!\n"</span>);</span><br><span class="line">        PercolationStats stats = new PercolationStats(Integer.parseInt(args[<span class="number">0</span>]),</span><br><span class="line">                                                      Integer.parseInt(args[<span class="number">1</span>]));</span><br><span class="line">        StdOut.print(<span class="string">"Work completed\n mean = "</span> + stats.mean() + <span class="string">"\n stddev = "</span> +</span><br><span class="line">                             stats.stddev() + <span class="string">"\n 95% confidence interval = ["</span> +</span><br><span class="line">                             stats.confidenceLo() + <span class="string">" , "</span> + stats.confidenceHi() + <span class="string">"] \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src='happy.png' width = '800' title = '真正的快乐哈哈哈哈'></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title>C++草稿本</title>
    <url>/2020/09/23/C-%E8%8D%89%E7%A8%BF%E6%9C%AC/</url>
    <content><![CDATA[<p>记录C++语法中的一些小问题</p>
<a id="more"></a>
<ol>
<li>初始化方式包括用=赋值，还有使用括号。例如 int a(1)。使用括号更加适配c++对象。</li>
<li>为什么switch语句会使用“不加break就能一直运行所有语句”这种机制？某些情况下可以对此加以利用，可以用于检测原因字母是否存在，替代一大堆或结构。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(nextchar) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'i'</span>: <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'o'</span>: <span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'u'</span>: <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">        ++vovel_cnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>cin的返回值不是一个内嵌类型，而是cin对象。对于while(cin&gt;&gt;nextchar)这种结构，结束循环的条件是EOF。在windows平台输入EOF的方法为，同时按下ctrl和z键。 如果是unix/linux平台，则需要同时按下ctrl+d键。</li>
<li>array数组的初始化数量必须用常量定义而非变量。即int s[variable]这种操作是非法的。可以留空，由编译器仔细根据初值数量判断。<strong>但是没有初始化数值又不明确数组长度的操作是非法的，编译器无法确定数组长度</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> s[a]; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li>
<li>array如果定义后不初始化，则数组元素为随机值。如果初始化={}，则所有元素被初始化为0，如果初始化={1}，则第一个元素为1，其余元素为0。</li>
<li>vector不支持={}这种初始化方式，只能逐个赋值或者用数组给他初始化，没有被初始化的元素默认值为0。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ini</span><span class="params">(<span class="number">5</span>)</span> </span>= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//ERROR!!!!</span></span><br><span class="line"></span><br><span class="line">ini[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></li>
<li>vector和string都是std命名空间里的，使用时注意。</li>
<li>指针初始化指向地址0，则等同于null指针，即什么对象都没有指向。int* p=0;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">define <span class="literal">NULL</span> <span class="number">0</span></span><br><span class="line">完全等价===</span><br></pre></td></tr></table></figure></li>
<li>srand()和rand()属于cstdlib库，使用时要配合time.h，使用time(NULL)或者time(0)生成srand()的种子，才能生成随机序列。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">srand(time(<span class="literal">NULL</span>))</span><br><span class="line">rand() <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></li>
<li>int[]这种写法只能在数组聚合初始化的时候使用，其余时候不等于int*。</li>
<li>单引号表示一个字符’a’双引号代表字符串”a” = ‘a’+’\0’。类型为char和const char。<strong>两个字符类型的变量没办法直接拼接，必须至少有一个是string</strong></li>
<li>ofstream和ifstream对象在未打开对象的时候会返回false。</li>
<li>ifstream读取文件的时候，空格和tab都可以作为分隔符，ifstream会依次读取，逗号尝试了不能作为分隔。</li>
<li>fstream可以满足io的读取功能，打开模式如果是ios_base::in | ios_base::app 则一开始的文件位置光标会位于文件末尾。需要使用fstream.seekg(0)重新定位光标位置到文件开头。</li>
<li>函数参数用指针和引用都可以作为输出值，使用指针时需要检查是否为空指针，而引用要求必须是存在的对象不需进行这个检查，也就说只要编译顺利通过，引用对象是不会发生runtime error的。一般的对象引用使用const修饰，除非要修改变量内容，<strong>一般内置变量不建议使用传址机制</strong>。</li>
<li>如果一个变量定义为了<strong>全局变量（file scope）</strong>，而又是<strong>内置类型</strong>，则它<strong>会被自动初始化为0</strong>（即使没有初始化语句）。而一个local scope里的变量除非指定初值，否则不会被初始化。</li>
<li>函数的默认参数值必须放在不带默认值的参数的后面，这一点和python一致。</li>
<li>在头文件声明的函数形式具有更高的可见性visibility（如头文件声明了而cpp文件没有声明默认值，以头文件为准）</li>
<li>inline内联函数一般要在头文件里面声明。</li>
<li>返回值不同不能让函数重载，因为在调用的时候编译器无法用返回值判断是哪个函数。</li>
<li>function template可以重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg, <span class="built_in">vector</span>&lt;T&gt; vecT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg, <span class="built_in">list</span>&lt;T&gt; vecList)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值为 const  只有用在函数返回为引用的情况。 函数返回值引用常量表示不能将函数调用表达式作为左值使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">mini</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">mini(a,b) = <span class="number">4</span>; <span class="comment">// OK, func returns a lvalue</span></span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">mini</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span>&amp;b)</span></span>;</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">mini(a,b) = <span class="number">4</span>; <span class="comment">//ERROR! function mini returns a rvalue</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>c风格字符串是字符数组，char str[]跟一般数组一样，方括号里如果不写长度，那么就必须在后面直接用字符串赋值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[]=<span class="string">"hello"</span>; <span class="comment">// must be initialized</span></span><br><span class="line"><span class="keyword">char</span> str[]=&#123;<span class="string">"myworld"</span>&#125;; <span class="comment">// must be initialized</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>] = <span class="string">"abcd"</span>; <span class="comment">// initilaztion is not mandatary</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>strlen()是一个函数，sizeof是一个运算符</p>
<ol>
<li>sizeof 操作符的结果类型是 size_t，它在头文件中 typedef 为 unsigned int 类型。该类型保证能容纳实现所建立的最大对象的字节大小。</li>
<li>sizeof 可以用类型做参数，strlen 只能用 char* 做参数，且必须是以 \0 结尾的</li>
<li>数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了</li>
<li>大部分编译程序在编译的时候就把 sizeof 计算过了，是类型或是变量的长度，这就是 sizeof(x) 可以用来定义数组维数的原因<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">strlen</span>(str); <span class="comment">// a=10;</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="keyword">sizeof</span>(str); <span class="comment">// 而 b=20;</span></span><br></pre></td></tr></table></figure></li>
<li>strlen 的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小</li>
<li>sizeof 后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为 sizeof 是个操作符不是个函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">strlen</span>(str);         <span class="comment">// a=10; &gt;&gt;&gt;&gt; strlen 计算字符串的长度，以结束符 0x00 为字符串结束。</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="keyword">sizeof</span>(str);         <span class="comment">// 而 b=20; &gt;&gt;&gt;&gt; sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>char[]和“char<em>”这个东西，在某些时候是可以转换的，比如printf希望获得一个“char</em>”的输入，这时候使用字符数组就会自动退化为字符指针。<strong>vs2019</strong>里面用const char<em> </em>给<em> char</em>赋值是forbidden的，例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="string">"world"</span>; <span class="comment">// Error </span></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="string">"world"</span>; <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line">在c语言里用指针“初始化赋值字符串”实际上指向的是一段静态字符串地址（Readonly），不可修改。而用字符数组是copy了一份，与原有的静态字符串无关了，可以修改。</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span> ;</span><br><span class="line">then s[<span class="number">0</span>] = <span class="string">'j'</span>; <span class="comment">//legal</span></span><br><span class="line"><span class="keyword">char</span> *s = <span class="string">"hello"</span> ; </span><br><span class="line">then *s = <span class="string">"world"</span>; <span class="comment">//illegal!!</span></span><br></pre></td></tr></table></figure></li>
<li>char<em>* 是指针的指针，与char</em>[]代表的有所区别<blockquote>
<p>A “double star” is a pointer to a pointer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[]= <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">char</span>* p = a; </span><br><span class="line"><span class="keyword">char</span>** pp = &amp;p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(*pp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">输出结果为b</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<ol>
<li><blockquote>
<p>There is one difference between an array name and a pointer that must be kept in mind. A pointer is a variable, so pa=a and pa++ are legal. But an array name is not a variable; constructions like a=pa and a++ areillegal.<br>——The C Programming Language by Brain W. Kernighan &amp; Dennis M. Ritchie</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">15</span>] = <span class="string">"loo"</span>;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span>* m;</span><br><span class="line">m = c;<span class="comment">//OK</span></span><br><span class="line">m = s;<span class="comment">//OK</span></span><br><span class="line">   c = b;<span class="comment">//ERROR!!!</span></span><br><span class="line">   c = s;<span class="comment">//ERROR!!!</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>const int<em> p1 vs. int</em> const p2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;a;  <span class="comment">// initialization is not mandatory </span></span><br><span class="line">    *p1 = <span class="number">5</span>; <span class="comment">// wrong</span></span><br><span class="line">    p1++;    <span class="comment">// right  </span></span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> p2=&amp;a; <span class="comment">// must be initialized when declare</span></span><br><span class="line">	*p2 = <span class="number">5</span>;  <span class="comment">//right</span></span><br><span class="line">    p2++; <span class="comment">// Wrong</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">链接：数组名称是指针吗？</a>不是的，但数组名称经常退化为指针</p>
</li>
<li><p>cin.fail()检查cin的非法输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cin</span>.fail()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid input"</span>;</span><br></pre></td></tr></table></figure></li>
<li>function pointer有点像泛化的函数，是一种更广泛的泛化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">用ptr指代所有参数、返回值符合要求的函数，ptr默认值<span class="number">0</span>检验是否真的调用了函数</span><br><span class="line"><span class="keyword">void</span> (*ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span> &lt;&lt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bigdis</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> (*ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span>; <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ptr(c, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">99</span>;</span><br><span class="line">	bigdis(a, b, dis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数指针还能是数组形式的！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">需要注意函数指针数组的声明需要放在函数定义之后，或者函数提前声明，否则也会有函数名未定义的问题</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"dis0"</span>; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span> &lt;&lt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span> &lt;&lt; b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"dis1"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">'\n'</span> &lt;&lt; b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"dis2"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*ptr[])(<span class="keyword">int</span>, <span class="keyword">int</span>) = &#123; dis, dis1, dis2 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bigdis</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> (*ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span>; <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ptr(c, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">99</span>;</span><br><span class="line">	bigdis(a, b,ptr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>vector使用vector.at(i)函数可以访问第i个位置的元素，在使用vector指针的时候可以这么用，或者（*P）[i]也可以。vector.front()与vector.back()分别用于提取首尾元素。</p>
</li>
<li><p>引入头文件的时候如果用双引号那么会优先在项目目录下面找，默认是用户提供的头文件。而如果使用&lt;&gt;那么会认为是系统提供的头文件，会先去默认的磁盘目录找。</p>
</li>
<li><p>iterator也叫泛型指针，是对指针的一个抽象化和包装</p>
</li>
<li>每一个容器类型（含string）的共同操作<ol>
<li>==equality和！=inequality运算符</li>
<li>=赋值assignment</li>
<li>empty(), true/false</li>
<li>size(), num of elems</li>
<li>clear(), clear all</li>
<li>begin(), end(), return the iterator, the first element and the <strong>(last+1) </strong>element</li>
<li>insert(), erase(), insert and remove</li>
</ol>
</li>
<li><p>使用数组为vector初始化时，数组提供两个iterator或者说哨兵，要符合first和last的习惯，即要用数组元素第一个指针，和数组最后一个元素的再后一个指针来赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">veci</span><span class="params">(a, a + <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; veci.back()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// output is 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数对象是一个实现了调用操作符（）的对象，c++里有许多内置的函数对象，它可以替换函数指针，从而将调用某个函数的过程简化为内联，提高调用效率。某些STL算法函数只允许输入一个函数指针，而一个函数指针也只能有一个参数，一旦需求改变，还需要重新编写函数。函数对象可以利用重载调用操作符实现前述函数指针的功能，同时还可以利用对象实例化的参数改变函数的功能。</p>
</li>
<li><p>function object adapter可以实现“参数绑定”的功能，将某一个值绑定到函数对象的参数，感觉是使之固定的样子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目：依据字符串长度排序，使用函数对象作为泛型算法**sort**的参数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LessThan</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s1, <span class="keyword">const</span> <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 关键在于sort那一句，前两个参数是要排序的迭代器，最后一个是定义的函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"practice.txt"</span>, ios_base::in)</span></span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecs;</span><br><span class="line">	<span class="built_in">string</span> ex[] = &#123; <span class="string">"a"</span>,<span class="string">"an"</span>, <span class="string">"or"</span>,<span class="string">"but"</span>,<span class="string">"the"</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">exset</span><span class="params">(ex, ex + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">string</span> tword;</span><br><span class="line">	<span class="keyword">while</span> (infile &gt;&gt; tword) &#123;</span><br><span class="line">		<span class="keyword">if</span> (exset.count(tword)) <span class="keyword">continue</span>;</span><br><span class="line">		vecs.push_back(tword);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(vecs.begin(), vecs.end(),LessThan());</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = vecs.begin();</span><br><span class="line">	<span class="keyword">for</span> (; it != vecs.end(); it++)</span><br><span class="line">		<span class="built_in">cout</span>  &lt;&lt; *it&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>使用map来统计文章词频，使用索引方式首次加入的key会被设为默认值value</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;words;</span><br><span class="line">	words[<span class="string">"vermeer"</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">string</span> tword;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; tword) &#123;</span><br><span class="line">		words[tword]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找map里是否存在某个key可以使用三种方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">No<span class="number">.1</span></span><br><span class="line"><span class="keyword">int</span> count = words[<span class="string">"key"</span>]; <span class="comment">// 如果不存在key，会导致words额外增加了一个条目pair class</span></span><br><span class="line">No<span class="number">.2</span></span><br><span class="line"><span class="built_in">map</span>::iterator it = words.find(<span class="string">"key"</span>); <span class="comment">// find返回一个iterator</span></span><br><span class="line">No<span class="number">.3</span></span><br><span class="line"><span class="keyword">int</span> count = words.count(<span class="string">"key"</span>) ? words[<span class="string">"key"</span>] : <span class="number">0</span> ; <span class="comment">// 先看看是否存在</span></span><br></pre></td></tr></table></figure></li>
<li><p>$\color{red}{Iterator Inserter以及iostream Iterator没看懂}$</p>
</li>
<li><p>vector.emplace_back()代替vector.push_back()</p>
</li>
<li><p>如果想读取某一个文本文件某一行的第几个，可以用getline函数与string类的find_first_of()函数配合，进行字符串的切割。用string.substr()提取子字符串。</p>
</li>
<li><p>实例化对象的时候，如果想用默认的构造函数不能带括号，因为cpp为了兼容c，默认带括号的都是调用函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SomeClass <span class="title">obj</span><span class="params">()</span></span>;<span class="comment">//ERROR!</span></span><br><span class="line">SomeClass obj; <span class="comment">//Default Constructor</span></span><br></pre></td></tr></table></figure></li>
<li><p>copy constructor()复制构造函数的目的，需要申请堆空间的变量不能直接复制给别的对象，会出现野指针的问题。为某个class编写copy constructor了之后还有必要编写copy assignment operator。</p>
</li>
<li><p>const &amp; mutable</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// const member function.</span></span><br><span class="line">		<span class="comment">// writing is forbidden</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _length;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _beg_pos;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">elem</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="comment">// non-const member function</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> &amp;val)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">next_reset</span><span class="params">()</span> </span>&#123; _next = _beg_pos<span class="number">-1</span>;&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> _length;</span><br><span class="line">		<span class="keyword">int</span> _beg_pos;</span><br><span class="line">		<span class="keyword">mutable</span> <span class="keyword">int</span> _next;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//static data member</span></span><br><span class="line">		<span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// function defined outside the class must declare with keyword "const"</span></span><br><span class="line"><span class="keyword">int</span> Triangular:: elem(<span class="keyword">int</span> pos) <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _elems[pos<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Triangular::next</span><span class="params">(<span class="keyword">int</span> &amp;value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( _next &lt; _beg_pos + _length <span class="number">-1</span> )&#123;</span><br><span class="line">		value = elems[_next++];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个class里面有同名函数，但一个是const，一个是non-const，那么在调用函数的时候，编译器会自动为调用者选择合适的被调用函数！</p>
</li>
</ol>
<p>mutable是一种变量声明，它表示mutable变量尽管有所改变，但这种改变不影响对量的常量性，例如next函数只是移动了指针指向数组元素，本质上只是一种迭代器，对数组本身没有根本性的影响。这种变量应当允许被const函数改变。</p>
<ol>
<li><p>this 是个指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;member</span><br><span class="line">*<span class="keyword">this</span> <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符重载中，递增的前置版本参数列表为空，后置版本本来也是空的，但是为了重载，后置版本强行给加了一个int参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Triangular_iterator&amp; Triangular_iterator::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">	++_index;</span><br><span class="line">	check_intergrity();</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这应该是第二次看到函数参数只是一个类型名称，第一次看到是在函数指针</span></span><br><span class="line"><span class="keyword">inline</span> Triangular_iterator Triangualr_iterator::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">	Triangular_iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">	++_index;</span><br><span class="line">	check_intergrity();</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>友元函数声明需要保证被声明的函数的定义在此声明之前，或者只能用友元类做整体的声明。</p>
</li>
<li><p>maximal munch规则，合法符号序列总是以最长的那个解释，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;后面两个尖括号必须分开，如何中间没有空格就会被解释为&gt;&gt;流符号</span><br><span class="line">a+++b会解释为a++ + b</span><br></pre></td></tr></table></figure>
</li>
<li><p>面向对象风格：继承inheritance、多态polymorphism、动态绑定dynamic binding</p>
</li>
<li><p>protected为只有子类可以访问，子类使用时不需要区分“继承而来的成员”还是“自身定义的成员”，在派生类的构造函数中，如果基类需要构造参数，需要先完成基类的初始化。</p>
</li>
<li><p>基类的指针调用虚函数的时候可以调用到子类的虚函数。虚函数的解析发生在运行时，而非编译阶段。</p>
</li>
<li><p>如果类里面有一个reference类型的变量，那么它就需要再构造函数中初始化，且一旦初始化就不能改变引用的对象。它不能够指向空对象，这相比指针既是优点，也是缺点，优点在于它不需要进行额外的空检查，缺点在于它没有指针那么灵活。引用和指针到底用哪个需要根据具体的设计要求来灵活判断。</p>
</li>
<li><p><em>使用 sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。</em></p>
</li>
<li><p>基类虚函数调用失效的两种情况：</p>
<ol>
<li>基类的constructor和destructor内，此时派生类还未构造</li>
<li>使用基类对象而非对象的指针或引用</li>
</ol>
</li>
<li><p>template类成员函数在class外的定义顺序：template<typename elemtype> keyword returnvalue classname::func() otherkeyword{}</p>
</li>
<li><p>为了提高效率，不论模板类型实际是啥，我们在构造函数中都是用变量引用和列表初始化。</p>
</li>
<li>reference to pointer？？？？？只用指针只能改变指针指向的东西，而不能改变指针自己（看到这我人都傻了，脑子不够用了）</li>
<li>模板尖括号里面不一定要是某一个类型type，也可以是常量表达式，non-type parameter非类型参数？？？？</li>
<li>一种catch all exception的方法：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exception也就是一种类而已</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line">	log_message(<span class="string">"exception of unknown type"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line">	<span class="keyword">throw</span>; <span class="comment">// ...代表任意类型异常，我都不处理，全部throw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这种异常并非硬件异常。</li>
</ol>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter11</title>
    <url>/2021/02/06/CppPrimer5th-Chapter11/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第十一章中的重要知识点，这一章的内容是介绍关联容器，map、set以及相关的变体。<br><a id="more"></a></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>从三个方面分类关联容器</p>
<ol>
<li>map或者set</li>
<li>是否允许重复key（multi）</li>
<li>key的顺序是否有规律（unordered）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span> <span class="comment">// 保存key-value</span></span><br><span class="line"><span class="built_in">set</span> <span class="comment">// 只保存key</span></span><br><span class="line"><span class="built_in">multimap</span></span><br><span class="line"><span class="built_in">multiset</span></span><br><span class="line"><span class="built_in">unordered_map</span></span><br><span class="line"><span class="built_in">unordered_set</span></span><br><span class="line"><span class="built_in">unordered_multimap</span></span><br><span class="line"><span class="built_in">unordered_multiset</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count=&#123;&#123;<span class="string">"ad"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">"top"</span>, <span class="number">80</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">word_bag</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;w : word_count)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; w.first &lt;&lt; w.second; <span class="comment">// first成员为const类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p>
</blockquote>
<h2 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h2><p>定义在头文件 <em>utility</em> 中<br>一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样：<br>pair使用public成员first与second来存储key与value</p>
<h2 id="关联容器额外的类型"><a href="#关联容器额外的类型" class="headerlink" title="关联容器额外的类型"></a>关联容器额外的类型</h2><ul>
<li>key_type</li>
<li>mapped_type</li>
<li>value_type</li>
</ul>
<p>对map和set来说这三个类型含义有所不同，具体参照以下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::key_type v1; <span class="comment">// string</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::value_type v2; <span class="comment">//string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::key_type v3; <span class="comment">//string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type v4; <span class="comment">// pair</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::mapped_type v5; <span class="comment">// int</span></span><br></pre></td></tr></table></figure>
<h2 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h2><p>虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改</p>
<p>由于关联容器的迭代器大部分都是只读const，并且key值排列经常没有顺序，因此<strong>泛型算法通常不会作用在关联容器上</strong>。关联容器通常只会作为算法的源或者目的容器，而不参与过多的元素变换过程。</p>
<h2 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h2><p>map元素的下标访问有两种访问方式，set因为只有key，没有下标访问操作。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m[k]; <span class="comment">// 若k不存在，则在m中生成k项</span></span><br><span class="line">m.at(k); <span class="comment">// 若k不存在，抛出out of range异常</span></span><br></pre></td></tr></table></figure><br>如果只是想查找k在不在，不应该使用下标操作，因为若没有这个元素，使用下表会造成元素插入。查找元素应该使用find</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m.find(k) == m.end()) <span class="comment">// find由前至后的寻找k，找不到则返回尾后迭代器</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"k is not in the map"</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter10</title>
    <url>/2021/01/30/CppPrimer5th-Chapter10/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第十章中的重要知识点，这一章的内容是介绍STL相关的泛型算法。<br><a id="more"></a></p>
<p>泛型算法是为了丰富容器的操作而设计出的算法，定义在 <em>algorithm &amp; numeric</em>之中。<br>算法输入通常不是整个容器，而是与容器相关的迭代器。</p>
<p><img src='find.png' width=700 title='find algorithm'></p>
<p>泛型算法的操作都是在适配器之上进行的，因此不会对容器本身进行操作，他们自身不能改变容器的大小。</p>
<p>算法可以分为只读，改变元素，以及重新排序</p>
<h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><p>以numeric中的accumulate算法为例，算法要求迭代器指向容器元素类型与函数第三参数的类型一致，第三参数为初值，当为int时代表累加，当是字符串的的时候表示容器内各字符串相连在一起。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; vec</span></span><br><span class="line"><span class="comment">vector&lt;string&gt; v</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> sum = accumulate(vec.cbgein(), vec.cend(), <span class="number">0</span>); <span class="comment">// right, int</span></span><br><span class="line"><span class="built_in">string</span>  sum = accumulate(v.cbegin(), v.cend(), str(<span class="string">""</span>) ); <span class="comment">// right, string</span></span><br><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="string">""</span>); <span class="comment">// wrong, const char* is not compatiable with string</span></span><br></pre></td></tr></table></figure><br>这里需要注意的是字符串字面值类型为const char * 而非 string，因此不能直接将字符串字面值作为第三参数。</p>
<h3 id="迭代器参数数目"><a href="#迭代器参数数目" class="headerlink" title="迭代器参数数目"></a>迭代器参数数目</h3><p>当涉及到对两个容器序列的操作的时候，有些算法会使用三个迭代器参数，有些算法使用四个迭代器参数。三个参数的算法例如equal，前两个参数为第一个序列的首末迭代器，第三个参数为第二个序列的首迭代器，这时候算法默认两个迭代器的长度一致；四参数算法则完整的读取两个序列的首末迭代器。</p>
<h2 id="写容器算法"><a href="#写容器算法" class="headerlink" title="写容器算法"></a>写容器算法</h2><p>需要保证写入的内存都是有定义的，否则为非法操作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill(vec.begin(), vec.end(), <span class="number">0</span>); <span class="comment">// 将每个元素重置为0</span></span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 将begin开始的10个元素置0，存在风险，容器有可能为空</span></span><br><span class="line"><span class="comment">/*使用back_insert获取尾部迭代器*/</span></span><br><span class="line"><span class="keyword">auto</span> it = back_inserter(vec);</span><br><span class="line">*it = <span class="number">40</span>; <span class="comment">// OK</span></span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<h2 id="重排元素算法"><a href="#重排元素算法" class="headerlink" title="重排元素算法"></a>重排元素算法</h2><blockquote>
<p>某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。</p>
</blockquote>
<p>重排算法不能对容器本身的元素进行删除操作，具体对元素的删除还需要直接对容器进行操作。</p>
<h2 id="定制算法"><a href="#定制算法" class="headerlink" title="定制算法"></a>定制算法</h2><p>某些算法，在运行时会调用容器元素的操作符，例如sort默认调用小于号运算符。对于那些没有定义相应运算符的元素，或者当我们希望自由选择使用的运算符的时候，我们可以使用自定义函数并作为参数传入算法的方式来解决。这个参数或者说自定义函数被称作<strong>谓词</strong>（predicate）</p>
<blockquote>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*一个二元谓词isShorter，比较两个字符串的长度大小*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">sort(words.begin(), words.end(), isShorter); <span class="comment">// 按由短到长的顺序将words排序</span></span><br></pre></td></tr></table></figure></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2></blockquote>
<p>「lambda函数」是一个对象。因为它可以像函数一样被调用，类不能被调用，只有对象才可以。</p>
<p>更准确地说，「lambda函数」就是一个「函数对象」。</p>
<p>lambda的语法其实一个语法糖，编译器会将它“翻译”成一个函数对象，然后再编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (parameters) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br><span class="line"><span class="comment">/*lambda isShorter*/</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp;s2) -&gt; <span class="keyword">bool</span> &#123;<span class="keyword">return</span> s1.size()&lt;s2.size();&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lambda函数没有默认参数值，因此实参与形参数目必须一致</strong><br>lambda表达式可以使用所在的函数中的局部变量，只要在捕获列表中“捕获”即可，这种方式可以让部分只接受一元谓词的算法也适配多参数的<em>多元谓词</em></p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>使用c++11中的bind函数与placeholder也可以解决一元谓词变多元的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = bind(f, a, b, _1, c, _2);</span><br><span class="line"><span class="comment">// g函数有两个参数，f函数有五个参数，调用g的时候可以将g的参数作为f的参数传入，实际起作用的是f函数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter3</title>
    <url>/2021/01/27/CppPrimer5th-Chapter3/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第三章中的重要知识点</p>
<a id="more"></a>
<p>阅读《C++ Primer 5th》后记录下比较重要或者不熟悉的知识点，方便以后查询复习。本篇为第三章字符串、向量和数组，讲述了string、vector与迭代器的一些知识。</p>
<h2 id="using命名空间的声明"><a href="#using命名空间的声明" class="headerlink" title="using命名空间的声明"></a>using命名空间的声明</h2><p>不同于常用的 <em>using namespace std</em> ，这里primer推荐的是针对每一个要用的函数单独声明，这样不会让命名空间保护的名称全部暴露出来。<br>单独声明某一个函数的格式为 <em>using namespace::func</em><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="标准库string"><a href="#标准库string" class="headerlink" title="标准库string"></a>标准库string</h2><h3 id="拷贝初始化与直接初始化"><a href="#拷贝初始化与直接初始化" class="headerlink" title="拷贝初始化与直接初始化"></a>拷贝初始化与直接初始化</h3><blockquote>
<p>C++语言有几种不同的初始化方式，通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化（direct initialization）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"abcd"</span>; <span class="comment">// copy</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"hiya"</span>)</span></span>; <span class="comment">//direct</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>; <span class="comment">//direct "cccccccccc"</span></span><br></pre></td></tr></table></figure>
<h3 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a>使用getline读取一整行</h3><p>一般使用cin读取字符串流的时候，会把空格、制表符、换行符当作分隔符。如果想要保留这些分隔符（除了换行符），可以使用<em>getline()</em></p>
<blockquote>
<p>getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。</p>
</blockquote>
<p><em>getline()</em> 同样返回流对象，因此可以用while来判断是否读到底部了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="size-type"><a href="#size-type" class="headerlink" title="size_type"></a>size_type</h3><blockquote>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的</p>
</blockquote>
<p>size_type是一个无符号量，使用的时候尽量不要与整型（有符号量）混用，防止出现意外得到负数的情况，进而致使 <em>size()+10 &lt; n</em> 这种条件无法正常判断。</p>
<h3 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h3><p>为了与c兼容和历史原因，字符串字面值类型不是string类，无法执行相关的操作。</p>
<h3 id="处理字符串中的字符"><a href="#处理字符串中的字符" class="headerlink" title="处理字符串中的字符"></a>处理字符串中的字符</h3><p>一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。</p>
<p>例如 <em>cctype</em> 和 <em>ctype.h</em> 文件实际上是同一个文件（从包含的函数功能来说）， <em>cctype</em> 符合c++命名规范</p>
<p>处理字符串中每个字符元素最好的方式是使用c++11的range for</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : expression)</span><br><span class="line">    statement</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(str.size()) cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">        ++cnt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">"digits in str\n"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>如果修改字符，需要将auto后面增加引用修饰符 ，即 auto &amp;c : str</strong></p>
<h2 id="标准库中vector"><a href="#标准库中vector" class="headerlink" title="标准库中vector"></a>标准库中vector</h2><blockquote>
<p>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。</p>
</blockquote>
<p>vector能容纳绝大多数类型的<strong>对象</strong>作为其元素，但是因为<strong>引用不是对象</strong>，<em>所以不存在包含引用的vector</em>。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。</p>
<h3 id="不同括号初始化效果不同"><a href="#不同括号初始化效果不同" class="headerlink" title="不同括号初始化效果不同"></a>不同括号初始化效果不同</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">//十个元素都是1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>,<span class="number">1</span>&#125;; <span class="comment">//前两个元素是10和1</span></span><br></pre></td></tr></table></figure>
<p><strong>一些重要的注意事项</strong></p>
<blockquote>
<p>开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。</p>
<p>随着对vector的更多使用，我们还会逐渐了解到其他一些隐含的要求，其中一条是现在就要指出的：如果循环体内部包含有向vector对象添加元素的语句，则不能使用<strong>范围for</strong>循环</p>
</blockquote>
<h3 id="vector的size-type"><a href="#vector的size-type" class="headerlink" title="vector的size_type"></a>vector的size_type</h3><p>vector的size_type需要指明具体模板元素<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type  <span class="comment">//right</span></span><br><span class="line"><span class="built_in">vector</span>::size_type <span class="comment">//wrong!</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>两个vector对象相等当且仅当它们所含的元素个数相同，而且对应位置的元素值也相同。关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。</p>
</blockquote>
<p>只有元素支持比较的时候，vector容器才可以比较</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>如果容器为空，begin和end是同一个迭代器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> be = v.begin(), ed = v.end();</span><br><span class="line"><span class="keyword">auto</span> cbe = v.cbegin(), ced = v.cend();</span><br></pre></td></tr></table></figure><br>一般来说不在意也不清楚迭代器的具体类型，使用auto关键字来代替准确的类型<br>cbegin和cend是专用得到const_iterator类型的返回值</p>
<p><strong>两个迭代器相加没有意义，相减能够得到之间的间距，类型为__int64</strong></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组在c++11中利用begin end函数可以近似得到头指针和尾指针（最后元素的后一个内存位置）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> be = begin(a);</span><br><span class="line"><span class="keyword">auto</span> ed = end(a);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(ed<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。</p>
</blockquote>
<p>为了兼容c风格字符串，string类型做出了兼容性配置</p>
<ul>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</li>
<li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象</li>
</ul>
<p>反过来，如果以string作为右值，不可以直接赋给c风格字符串</p>
<ul>
<li>string类具有c_str函数，可以返回一个c风格字符串<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c[] = str; <span class="comment">// wrong!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c[] = str.c_str(); <span class="comment">//right</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组的初始化可以用花括号分隔每一行的数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::begin;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia; p!=ia+<span class="number">3</span>; p++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> *m = *p; m!=*p+<span class="number">4</span>; m++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia; <span class="comment">//right! 指向4元素数组的指针</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">4</span>] = ia; <span class="comment">//wrong! 整形指针的数组</span></span><br><span class="line"></span><br><span class="line">用<span class="keyword">auto</span>解决这个问题最快乐</span><br></pre></td></tr></table></figure>
<p>我们首先明确（＊p）意味着p是一个指针。接着观察右边发现，指针p所指的是一个维度为4的数组；再观察左边知道，数组中的元素是整数。因此，p就是指向含有4个整数的数组的指针。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter12</title>
    <url>/2021/02/07/CppPrimer5th-Chapter12/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第十二章笔记内容，有关智能指针和动态内存的管理。<br><a id="more"></a></p>
<p>程序相关的对象内存分为三部分，static空间，栈空间stack，堆空间heap。</p>
<ul>
<li>static空间中的对象在程序运行前生成，程序结束时销毁</li>
<li>stack栈空间里的对象在程序块作用域中存在，超出作用域后销毁</li>
<li>上述两者都是编译器负责自动创建和销毁</li>
<li>heap空间由程序负责分配和销毁，处理不好会造成内存泄漏，这种内存分配也叫做动态内存管理</li>
</ul>
<p><strong>动态内存的管理十分重要且棘手</strong></p>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>C++中使用一对运算符 new 和 delete 来分配和销毁对象内存<br>C++11引入了智能指针shared_ptr unique_ptr weak_ptr , 使用智能指针可以降低动态内存管理的难度</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>是一个模板类，按照模板创建的方式来创建智能指针<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; p2;</span><br><span class="line"></span><br><span class="line">usage：</span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; !p1-&gt;empty())</span><br><span class="line">    *p1 = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>独有的操作：</span><br><span class="line">p1.use_count(); <span class="comment">// 返回指向共享对象的智能指针数量，返回速度较慢</span></span><br><span class="line">p1.unique(); <span class="comment">// 判断是否只有一个指针指向对象</span></span><br><span class="line">make_shared&lt;T&gt;(args); <span class="comment">// 初始化shared_ptr并用args初始化</span></span><br><span class="line">p1 = p3; <span class="comment">//p3的引用计数减少，p1的引用计数增加</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。与智能指针一样，make_shared也定义在头文件memory中。</p>
</blockquote>
<p>计数器清零时，对象就会被自动释放（call destructor），不能也不用delete</p>
<blockquote>
<p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p>
</blockquote>
<p>运用shared_ptr与initialize_list的一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type size_type;</span><br><span class="line">	StrBlob();</span><br><span class="line">	StrBlob(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il);</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;size(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">( <span class="keyword">const</span> <span class="built_in">string</span> &amp;t )</span></span>&#123;data-&gt;push_back(t); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> &amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> &amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span> &lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;data;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlob::StrBlob():data(make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;())&#123;&#125;</span><br><span class="line">StrBlob::StrBlob(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il): data(make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;(il))&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; data-&gt;size())</span><br><span class="line">		<span class="keyword">throw</span> out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp; <span class="title">StrBlob::front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	check(<span class="number">0</span>, <span class="string">"front on empty StrBlob"</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp; <span class="title">StrBlob::back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	check(<span class="number">0</span>, <span class="string">"back on empty StrBlob"</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter4</title>
    <url>/2021/01/27/CppPrimer5th-Chapter4/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第四章中的重要知识点，第四章内容为表达式</p>
<a id="more"></a>
<h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。<br>一个原则：</p>
<ul>
<li>在需要右值的地方可以用左值来代替，使用的是对象的值</li>
<li>但是反过来，不能把右值当成左值</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>C++11中，对于除法，不管是正数除以正数，还是负数除以负数，在无法除尽的时候都向0舍入。</p>
<p>赋值运算符满足右结合律，所以可以出现连续多个变量赋值<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a = b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">++a; <span class="comment">//养成使用前置版本递增运算符的习惯，对于迭代器等复杂的运算结构，可以节省不必要的开销</span></span><br></pre></td></tr></table></figure></p>
<h3 id="混用解运算符和递增"><a href="#混用解运算符和递增" class="headerlink" title="混用解运算符和递增"></a>混用解运算符和递增</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.begin();</span><br><span class="line"><span class="keyword">while</span>(pbeg != v.end())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>递增运算符的优先级高于解运算符，等价于先移动迭代器，再解出原位置的值（因为后置递增运算符返回原值），<strong>这种写法是C++常见并推荐的写法</strong>。</p>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>sizeof运算符返回的是size_t类型的常量表达式</p>
<ul>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效</li>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> p = ia;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> * p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//16</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> * ia &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> ia &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 48</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="若干隐形转换"><a href="#若干隐形转换" class="headerlink" title="若干隐形转换"></a>若干隐形转换</h3><p>算术转换，一般性原则是占内存地址小的类型转化为占内存地址大的类型，即char bool可以转换为int，int转换为long和double等</p>
<p><strong>数组转换成指针</strong>：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：<br>当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid等运算符的运算对象时，上述转换不会发生。</p>
<p><strong>指针的转换</strong></p>
<ul>
<li>0和nullptr转换为任意指针类型</li>
<li>任意非常量的指针能转换成void＊</li>
<li>指向任意对象的指针能转换成const void＊</li>
</ul>
<h3 id="显性转换"><a href="#显性转换" class="headerlink" title="显性转换"></a>显性转换</h3><p>本质上强制转换是一种危险的操作<br>标准形式 <em>cast-name<name>(expression)</em></p>
<ul>
<li><p>static_cast,任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用static_cast找回存在于void＊指针</span></span><br><span class="line"><span class="keyword">void</span> *p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span> *&gt;(p);</span><br></pre></td></tr></table></figure>
<p>强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失</p>
</li>
<li><p>const_cast, 强行将一个只读const对象变成可写状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast away the const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</span><br></pre></td></tr></table></figure>
<p>const_cast只能解决常量转换，不能进行其他类型转换</p>
</li>
<li><p>reinterpret_cast <em>为运算对象的位模式提供较低层次上的重新解释?</em></p>
</li>
</ul>
<p>我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);</span><br><span class="line"><span class="comment">// dangerous</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(pc)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter5</title>
    <url>/2021/01/28/CppPrimer5th-Chapter5/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第五章中的重要知识点，第五章内容为语句</p>
<a id="more"></a>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：<br>· exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。<br>· stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。<br>· new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节（第407页）详细介绍。<br>· type_info头文件定义了bad_cast异常类型，这种类型将在19.2节（第731页）详细介绍。</p>
<p><img src='errtype.png' width=600 title='errtype'></p>
<p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，<strong>返回值是一个指向C风格字符串</strong>的const char＊。该字符串的目的是提供关于异常的一些文本信息。</p>
<p><img src='what.png' width=600 title='what'></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter6</title>
    <url>/2021/01/28/CppPrimer5th-Chapter6/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第六章中的重要知识点，第六章内容为函数</p>
<a id="more"></a>
<h2 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h2><p>使用实参初始化形参的时候会忽略<strong>顶层const</strong>，也就说即便形参要求的格式为常量形参，也可以使用非常量形参为其赋值。<br>函数重载的时候，不能将顶层const和非const形参视为重载<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125; <span class="comment">// wrong: top-level const</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn0</span><span class="params">(<span class="keyword">int</span>* p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dcn0</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> p)</span></span>; <span class="comment">//wrong: top-level const</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn1</span><span class="params">(<span class="keyword">int</span>* p)</span></span>; <span class="comment">//right: low-level const</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn2</span><span class="params">(<span class="keyword">int</span>&amp; r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; r)</span></span>; <span class="comment">//right: low-level const</span></span><br></pre></td></tr></table></figure><br>我们可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">int</span> *p = cp;</span><br><span class="line"><span class="keyword">int</span> &amp;r3 = r;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><br>一般将引用形参设置为const，否则直接以字面值无法传递给形参（非const引用不能引用无地址的字面值）</p>
<h3 id="对于数组的引用"><a href="#对于数组的引用" class="headerlink" title="对于数组的引用"></a>对于数组的引用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *matrix[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*matrix)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h2 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h2><h3 id="initialize-list形参"><a href="#initialize-list形参" class="headerlink" title="initialize_list形参"></a>initialize_list形参</h3><p>initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，是一种模板类型</p>
<h3 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h3><p>省略符形参是为了便于c++函数访问部分特殊c代码出现的，也就是说并非c++推荐的格式</p>
<h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><blockquote>
<p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定</p>
</blockquote>
<p>在下面的函数中，我们返回一个vector对象，用它存放表示错误信息的string对象：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (expected.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (expected == actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"FunctionX"</span>, <span class="string">"Okay"</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"FunctionX"</span>, expected, actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用花括号的内容去初始化vector，然后返回这个vector</p>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组,不过，函数可以返回数组的指针或引用.<br>从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function">arrT * <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">等价于一种很复杂的声明</span><br><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>C++11中有了新的返回数组的方式</p>
<ol>
<li>返回尾置类型<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto func(int i) -&gt; int(*)[10];</span><br></pre></td></tr></table></figure></li>
<li>使用decltype<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) * func(<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure>
有一个地方需要注意：decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个＊符号。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter7</title>
    <url>/2021/01/29/CppPrimer5th-Chapter7/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第七章中的重要知识点，第七章内容为类</p>
<a id="more"></a>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p><strong>定义在类内部的函数是隐式的成员函数</strong></p>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;&#125; <span class="comment">// same</span></span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line">调用total.isbn()等价于</span><br><span class="line">Sales_data::isbn(&amp;total); <span class="comment">// fake code</span></span><br></pre></td></tr></table></figure>
<p>this是一个常量指针，不允许改变this的值，指向调用成员函数的对象</p>
<p><em>const作用是修改隐式指针const的类型</em>, const是常量指针（Sales_data <em> const），并非指向常量的指针，因此无法指向常量对象，有时候就需要将const转换为指向常量的指针形式(const Sales_data </em> const)，const是隐式指针，无法直接修改类型，因此借助const成员函数的帮助</p>
<blockquote>
<p>C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针</p>
</blockquote>
<p>因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容</p>
<h3 id="返回this对象的成员函数"><a href="#返回this对象的成员函数" class="headerlink" title="返回this对象的成员函数"></a>返回this对象的成员函数</h3><p>完成类似于自增的函数combine，返回this对象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>该函数一个值得关注的部分是它的返回类型和返回语句。一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回（参见4.4节，第129页），因此为了与它保持一致，combine函数必须返回引用类型（参见6.3.2节，第202页）。因为此时的左侧运算对象是一个Sales_data的对象，所以返回类型应该是Sales_data&amp;。</p>
</blockquote>
<h3 id="IO类不支持拷贝"><a href="#IO类不支持拷贝" class="headerlink" title="IO类不支持拷贝"></a>IO类不支持拷贝</h3><p>调用的时候需要直接使用对象引用。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp; os, Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">    os &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote>
<p>在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数。其中，= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果= default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s):bookNo(s)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="进阶属性"><a href="#进阶属性" class="headerlink" title="进阶属性"></a>进阶属性</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">string</span>::size_type pos; <span class="comment">// is equivalent to: using pos = string::size_type;</span></span><br><span class="line">	Screen() = <span class="keyword">default</span>; <span class="comment">// default constructor</span></span><br><span class="line">	Screen(pos h, pos w, <span class="keyword">char</span> c) : height&#123; h &#125;, width&#123; w &#125;, contents(h* w, c)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> contents[cursor]; &#125; <span class="comment">// implicit inline</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(pos h, pos w)</span> <span class="keyword">const</span></span>; <span class="comment">// explicit inline ; overloaded function</span></span><br><span class="line">	<span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r, pos c)</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(<span class="keyword">char</span> c)</span></span>; <span class="comment">// return *this</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(pos, pos, <span class="keyword">char</span>)</span></span>; <span class="comment">// return *this</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	pos cursor = <span class="number">0</span>;</span><br><span class="line">	pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> contents;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr = <span class="number">0</span>;  <span class="comment">// mutable variable</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">// </span></span><br><span class="line">	++access_ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过返回*this（Screen对象引用）可以实现move，set函数的序列化调用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myScreen.move(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br></pre></td></tr></table></figure></p>
<p><em>Warning: 一个const成员函数如果以引用的形式返回＊this，那么它的返回类型将是常量引用。</em></p>
<p>$\color{red}{常量对象，以及常量对象的引用或指针都只能调用常量成员函数。}$</p>
<p>一些成员函数需要有const和非const重载版本，来满足不同对象的要求。</p>
<h2 id="构造函数初始化顺序"><a href="#构造函数初始化顺序" class="headerlink" title="构造函数初始化顺序"></a>构造函数初始化顺序</h2><p>一般而言，要求构造初始化类成员的时候按照定义顺序来，尤其是存在类成员变量互相初始化的时候。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    Exp(<span class="keyword">int</span> val): j&#123;val&#125;, i&#123;j&#125; &#123;&#125; <span class="comment">// wrong initialize i with unintialized value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i会按照定义的顺序先执行初始化，而不是按照列表初始化里的顺序来</span></span><br></pre></td></tr></table></figure></p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11中出现的新特性，目的是减少构造函数中的代码冗余，委托构造函数可以调用其他构造函数，从而简化构造过程。将构造任务部分或者全部的交给其他构造函数。</p>
<p>默认构造函数还是能有就有，不然在某些情形下缺少默认构造函数会报错，例如初始化vector数组的时候，会调用默认构造函数</p>
<h3 id="聚合类与constexpr类"><a href="#聚合类与constexpr类" class="headerlink" title="聚合类与constexpr类"></a>聚合类与constexpr类</h3><p>public成员，无成员函数，都是字面值</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter9</title>
    <url>/2021/01/29/CppPrimer5th-Chapter9/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第九章中的重要知识点，这一章的内容是顺序容器的基础知识。<br><a id="more"></a></p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><p>当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同，如果使用迭代器则可以用不同类型的容器来初始化<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a&#123;<span class="string">"ac"</span>,<span class="string">"ree"</span>,<span class="string">"wq"</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; b&#123;<span class="string">"aa"</span>,<span class="string">"ew"</span>,<span class="string">"ww"</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">c</span><span class="params">(b)</span></span>; <span class="comment">//wrong</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">d</span><span class="params">(b.begin(), b.end())</span></span>; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap与assign"><a href="#swap与assign" class="headerlink" title="swap与assign"></a>swap与assign</h3><p>这是两个操作顺序容器元素的函数，swap有成员函数版本和非成员函数版本，<strong>推荐使用非成员函数版本</strong></p>
<h3 id="容器比较"><a href="#容器比较" class="headerlink" title="容器比较"></a>容器比较</h3><p>两个容器如果能进行比较运算，则比较结果为第一不同元素之间的大小</p>
<h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><p><img src='add.png' width=600 title='add elems'></p>
<p><strong>插入元素会使得现有的迭代器，范围循环失效</strong></p>
<p><em>insert()</em>会返回插入元素的第一个元素<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; lst;</span><br><span class="line">iter = lst.begin();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    iter = lst.insert(iter, word);</span><br><span class="line"><span class="comment">// 等价于push_front</span></span><br></pre></td></tr></table></figure><br>emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。</p>
<blockquote>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。</p>
</blockquote>
<h2 id="容器操作使迭代器失效"><a href="#容器操作使迭代器失效" class="headerlink" title="容器操作使迭代器失效"></a>容器操作使迭代器失效</h2><ul>
<li>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但<strong>指向插入位置之后元素的迭代器、指针和引用将会失效</strong>。</li>
<li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li>
<li>对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用<strong>仍有效</strong></li>
</ul>
<p>注意：当我们删除元素时，尾后迭代器总是会失效。</p>
<p><em>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector、string和deque尤为重要</em></p>
<p>换言之，保存尾迭代器是个坏主意，因为它有可能因为插入或者删除元素变成无效的迭代器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> end = vec.end();</span><br><span class="line"><span class="keyword">while</span>(p!=end) <span class="comment">// bad</span></span><br><span class="line"><span class="comment">/***/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p!=vec.end()) <span class="comment">// good</span></span><br><span class="line"><span class="comment">/***/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="vector和string的额外操作"><a href="#vector和string的额外操作" class="headerlink" title="vector和string的额外操作"></a>vector和string的额外操作</h2><p>vector在内存空间不足的时候会申请当前空间翻倍的新空间，使用c++11中的新函数 <em>shrink_to_fit()</em>可以退回多余的capacity。</p>
<p>string可以通过substr来部分的提取。除此之外，还有append，replace等函数对string进行操作，具体需要用到的时候再看。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>stack、queue和priority_queue是三个顺序容器适配器。<em>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list外），并使其操作起来像一个stack一样。</em></p>
<p>他们在顺序容器之上定义了新的接口，使之能表现地像相应的数据类型</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>CppPrimer5th-Chapter8</title>
    <url>/2021/01/29/CppPrimer5th-Chapter8/</url>
    <content><![CDATA[<p>《C++ Primer 5th》第八章中的重要知识点，从本章开始进入C++标准库方面的介绍，这一章的内容是IO库<br><a id="more"></a></p>
<p>这一章开始进入C++标准库，讲述庞大的标准库内需要熟练掌握的部分。</p>
<ul>
<li>IO库</li>
<li>顺序容器</li>
<li>泛型算法</li>
<li>关联容器</li>
<li>动态内存</li>
</ul>
<p>从IO库开始</p>
<h2 id="IO对象"><a href="#IO对象" class="headerlink" title="IO对象"></a>IO对象</h2><ul>
<li>无法拷贝或者赋值，IO类也都无法按值传递</li>
<li>读写IO对象会改变状态，因此传递和返回的引用不能是const的</li>
<li>流会进入错误状态，错误后所有的IO操作都会失败<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)&#123;&#125;<span class="comment">//...check status OK</span></span><br><span class="line">istream.clear();<span class="comment">// 恢复正常状态</span></span><br><span class="line"><span class="keyword">auto</span> state = istream.rdstate(); <span class="comment">// 读取状态</span></span><br></pre></td></tr></table></figure>
<h3 id="缓冲区与刷新"><a href="#缓冲区与刷新" class="headerlink" title="缓冲区与刷新"></a>缓冲区与刷新</h3></li>
</ul>
<p>输出对象具有缓冲区，为了减少直接访问硬件的次数可以多次输出到缓冲区然后统一写入硬件，写入硬件的过程叫做刷新。</p>
<blockquote>
<p>导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：<br>· 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。<br>· 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。<br>· 我们可以使用操纵符如endl（参见1.2节，第6页）来显式刷新缓冲区。<br>· 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。<br>· 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</p>
</blockquote>
<h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>使用fstream进行读写</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>MITLinearAlgebra(2)</title>
    <url>/2020/11/13/MITLinearAlgebra-2/</url>
    <content><![CDATA[<p>MIT线性代数笔记的第二部分</p>
<ul>
<li>线性相关性与线性空间</li>
<li>四个子空间</li>
<li>图和网络</li>
<li>正交空间与子空间投影</li>
<li>求解最小二乘的矩阵</li>
</ul>
<a id="more"></a>
<p>完整链接:<br><a href="/2020/09/27/MITLinearAlgebra/" title="MITLinearAlgebra">MITLinearAlgebra</a><br><a href="/2020/11/13/MITLinearAlgebra-2/" title="MITLinearAlgebra(2)">MITLinearAlgebra(2)</a><br><a href="/2020/11/13/MITLinearAlgebra-3/" title="MITLinearAlgebra(3)">MITLinearAlgebra(3)</a><br><a href="/2021/03/17/MITLinearAlgebra-4/" title="MITLinearAlgebra-4">MITLinearAlgebra-4</a></p>
<h2 id="线性相关性、基、维数"><a href="#线性相关性、基、维数" class="headerlink" title="线性相关性、基、维数"></a>线性相关性、基、维数</h2><p>线性无关的是“向量组”而不是矩阵</p>
<blockquote>
<p>若矩阵A的m &lt; n<br>Ax=0 未知数大于方程数，存在某些自由变量，也就是存在零空间的特解，至少n-m个</p>
</blockquote>
<h3 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h3><p>如果向量组的非零系数线性组合不存在零向量，则这一组向量线性无关。易知，零向量与所有向量线性相关。<br><strong>如果矩阵A的零空间null space包含非零向量，说明他们线性相关。</strong>例如二维空间里，三个向量一定是线性相关的，把他们组成一个矩阵A，这是一个2*3矩阵，明显存在自由变量，也就是零空间存在特解。</p>
<h3 id="生成向量空间span"><a href="#生成向量空间span" class="headerlink" title="生成向量空间span"></a>生成向量空间span</h3><p><strong>span</strong>生成一个空间是使用线性无关向量组去线性组合。这个空间包含这些向量的线性组合。</p>
<p><strong>基</strong>，basis，指能够生成向量空间的一组线性无关的向量。</p>
<p>给定向量空间，各组基向量的个数都是一致的。这个个数称作<strong>空间维数</strong>。</p>
<p><strong>Rank=#pivots columns=dimension of column space</strong></p>
<p>请注意，这里并非是<em>矩阵的维度</em>而是<em>列空间的维度</em></p>
<p>一个问题：null space的维度是多少？零空间在表示怎样这些列向量能够线性相关。维度是<strong>自由变量的数目</strong>。</p>
<p>dim N（A）= #free variables = n-r</p>
<h2 id="第十讲-四个基本子空间"><a href="#第十讲-四个基本子空间" class="headerlink" title="第十讲-四个基本子空间"></a>第十讲-四个基本子空间</h2><ul>
<li>列空间$C(A)$</li>
<li>零空间$N(A)$</li>
<li>行空间$C(A^{T})$row space</li>
<li>左零空间$N(A^T)$left null space</li>
</ul>
<ol>
<li>列空间的维度为r，基是主列向量</li>
<li>行空间与列空间的维度相同，也是r，基是矩阵R的前r行</li>
<li>零空间的维度为n-r，基是自由变量对应自由向量</li>
<li>左零空间的维度是m-r，也是能让行向量线性相关得到零向量的一组向量</li>
</ol>
<p>C(A)和N(A^T)在R^m空间里，N(A)和C(A^T)在R^m中</p>
<p>3<em>3的矩阵也可以找出一组基，形成一个矩阵空间，有点像把向量空间扩展到了矩阵空间，我们给他取个更好的名字不如叫<em>*线性空间</em></em>吧。</p>
<h2 id="矩阵空间-秩1矩阵-小世界图"><a href="#矩阵空间-秩1矩阵-小世界图" class="headerlink" title="矩阵空间 秩1矩阵 小世界图"></a>矩阵空间 秩1矩阵 小世界图</h2><h3 id="新空间"><a href="#新空间" class="headerlink" title="新空间"></a>新空间</h3><p>all 3 by 3 matrices组成矩阵空间M，里面的矩阵满足加法和数乘，基也是3*3矩阵，9个<br>也包括各种子空间subspaces: symmetric matrices, upper triangular matrices, lower …<br>那么这些子空间的维度是多少呢？<br>对称矩阵S维度为6，对角矩阵维度为3，上三角维度U为6</p>
<p><strong>一个规律</strong></p>
<script type="math/tex; mode=display">
dim(S\cap U)+ dim(S+U) = dim(S)+dim(U)\\[4px]
3+9 = 6+6\\</script><p>扩展到各种函数的组合，他们都是广义的向量</p>
<h3 id="秩1矩阵"><a href="#秩1矩阵" class="headerlink" title="秩1矩阵"></a>秩1矩阵</h3><p>就像积木的基本组成，但是两个秩1矩阵相加不能得到一个确定维度的矩阵，可能秩为1，可能秩为2</p>
<script type="math/tex; mode=display">
S = all v in R^4 with v1+v2+v3+v4=0(各分量相加为0)\\\\
那么S的维度是3\\\\
S = nullspace of A=[1 1 1 1], rank(A)=1=r\\\\
Rank(N(A))=n-r=3\\\\
dim C(A) = 1\\\\
dim C(A^T) = 1\\\\
dim N(A^T)=0</script><h3 id="小世界图"><a href="#小世界图" class="headerlink" title="小世界图"></a>小世界图</h3><p>图graph是点和边的集合，可以用矩阵来表示图的连接<br>small world小世界是说六度空间理论</p>
<h2 id="图和网络"><a href="#图和网络" class="headerlink" title="图和网络"></a>图和网络</h2><p>开始关注线性代数的应用</p>
<ul>
<li>Graphs&amp;Networks</li>
<li>Incidence Matrices关联矩阵</li>
<li>Kirchhoff’s laws基尔霍夫电流定律<br>所有实际应用中的矩阵其实都有一些结构特征，在处理矩阵的时候要注意利用这些矩阵的特征。</li>
</ul>
<p>图的封闭边可以构成一个loop</p>
<script type="math/tex; mode=display">

A = 
\begin{pmatrix}
-1& 1& 0& 0\\
0& -1& 1& 0\\
-1 &0 &1 &0\\
-1 &0 &0 &1\\
0 &0 &-1 &1\\
\end{pmatrix}</script><p>用关联矩阵表示图：</p>
<ol>
<li>行为有向边edge，列为节点node，出点为-1，入点为1</li>
<li>线性相关的几个行向量可以代表<strong>环loop</strong></li>
<li>关联矩阵的零空间nullspace反应线性相关，也就代表环的组成</li>
</ol>
<p>$Ax = 0$如果把这个想成电路，x想象成节点上的电势，零空间代表使得各处电势相等的情况。回路的电势差为0。</p>
<p>节点代表电势，边代表电流</p>
<p>基尔霍夫电流定律：$A^Ty=0$各个节点流出的电流和等于流入的电流和。</p>
<p><strong>树是没有环的图，在矩阵中是线性无关的A^T的列空间向量，也就是没能组成环的一堆边</strong></p>
<p>dim(N(A^T)) = m -r<br>num of loops = #edges-（#nodes-1）<br>rank=n-1</p>
<p><strong>欧拉公式</strong> #nodes-#edges+#loops=1<br><em>使用线性代数证明了欧拉公式</em></p>
<p><strong>应用数学中的最基本方程</strong><br>$A^{T}CAx=f$</p>
<h2 id="正交空间"><a href="#正交空间" class="headerlink" title="正交空间"></a>正交空间</h2><h3 id="两向量正交"><a href="#两向量正交" class="headerlink" title="两向量正交"></a>两向量正交</h3><p>两个向量x, y的正交条件就是内积为0</p>
<script type="math/tex; mode=display">
x^{T}y = 0</script><p>如果存在两个向量空间S和T, S中的任意向量都与T中的任意向量正交, 则两空间互为正交空间.</p>
<p>零空间和行空间是正交空间, 列空间和左零空间是正交空间</p>
<h3 id="A-TA的重要性质"><a href="#A-TA的重要性质" class="headerlink" title="A^TA的重要性质"></a>A^TA的重要性质</h3><blockquote>
<p>如果Ax=b无解, 那么如何”求解”出一个解</p>
</blockquote>
<p>这种问题在矩阵A, m&gt;n的时候很常见, 方程的个数超过了未知量的个数, 很容易无解(超正定问题?)</p>
<p>A^TA是对称矩阵, 有可能是可逆矩阵,是求解这种无解问题的答案</p>
<h2 id="子空间投影与投影矩阵"><a href="#子空间投影与投影矩阵" class="headerlink" title="子空间投影与投影矩阵"></a>子空间投影与投影矩阵</h2><p>先考虑一维的情况</p>
<p><img src='1dproj.bmp' width='600' title='一维投影情况'></p>
<script type="math/tex; mode=display">
向量B投影至向量A所在直线 \\[4px]
E = B - P 为误差向量\\[4px]
P = Ax, x是标量\\[4px]
由于E与A垂直或者说正交\\[4px]
E^{T}A=0 \rightarrow (B-Ax)^{T}A=0 \\[4px]
 B^{T}A - xA^{T}A = 0 \rightarrow x = \frac{B^{T}A}{A^{T}A}\\[4px]
 P = xA = Ax = A\frac{A^TB}{A^TA} = Proj*B</script><p>对一维场景来说$A^TB=B^TA$，并且可以用投影矩阵$Proj$来与向量$B$相乘得到投影的量</p>
<p>再来看一下二维乃至N维的情况</p>
<p><img src='2dproj.bmp' width='600' title='二维平面投影的情况' ></p>
<p>这里$A_1$和$A_2$两个向量组成了平面，$B$向量要投影到这个平面空间里，按照上述的一维正交情况，假设投影后的向量$P$用$A1，A2$表示为$P = c_1A_1+c_2A_2$,我们可以迅速写出如下方程</p>
<script type="math/tex; mode=display">
A1^{T}(B-(c_1A_1+c_2A_2))=0\\\\
A2^{T}(B-(c_1A_1+c_2A_2))=0\\\\</script><p>以上两个向量正交的表达化成矩阵形式可以用平面对应的列空间的矩阵A来表示</p>
<script type="math/tex; mode=display">
A^T(B-Ax)=0</script><p>经过一番移项乘逆矩阵整理</p>
<script type="math/tex; mode=display">
P = Ax =A(A^TA)^{-1} A^TB = Proj*B</script><p>那么这样我们就得到了二维乃至扩展到多维空间上的投影表达式<br>那么这种投影的用处是什么呢?</p>
<p>对于$Ax=B$, 对于A是瘦长矩阵的情形下, 常常没有解, 也就是B不在A的列空间里面, 那么这时候, 我们把B投影到A的列空间里面, 可以得到一个列空间里最像B的向量, 也就近似解出x</p>
<blockquote>
<p>这里不能展开求逆括号，因$A$会存在不可逆的情况, 如果可逆了当然可以展开, 那么就相当于把B投影到一个$R^N$的空间里, 只会得到他自己</p>
</blockquote>
<p>这里的投影矩阵具有$Proj^2 = Proj$的性质, 展开即可验证</p>
<h2 id="正交矩阵与Gram-Schmit正交化"><a href="#正交矩阵与Gram-Schmit正交化" class="headerlink" title="正交矩阵与Gram-Schmit正交化"></a>正交矩阵与Gram-Schmit正交化</h2><h3 id="正交矩阵的基本定义"><a href="#正交矩阵的基本定义" class="headerlink" title="正交矩阵的基本定义"></a>正交矩阵的基本定义</h3><p>正交矩阵的定义是, 其中包含的列向量两两正交(orthonormal vectors)同时每个向量的二范数为1</p>
<p>正交矩阵(符号为Q, orthogonal matrix)能够带来很多优良的性质,比如说当Q是一个方阵的时候$Q^TQ=I$, 再比如Q的投影矩阵是$Q(Q^TQ)^{-1}Q^T = QQ^T$, 形式会比较简单, 再比如对于$Ax=b$A是瘦长矩阵时, 如果A是一个正交矩阵, 两边可以左乘A转置, 左边可以直接化为单位矩阵</p>
<script type="math/tex; mode=display">
A^TA\hat{x}=A^Tb \\\\
\hat{x} = A^Tb</script><p>同时, $\hat{x}$在第$i$个维度上的投影就等于$q_i^{T}b$</p>
<h3 id="Gram-Schmit方法"><a href="#Gram-Schmit方法" class="headerlink" title="Gram-Schmit方法"></a>Gram-Schmit方法</h3><p>Gram负责求解出方向满足要求的vector, Schmit负责把该向量的范数变成1(就是除以范数值即可)</p>
<p>假设现在有a, b两个向量,那么让他们变成orthonormal vector的方法就是Gram-Schmit, a只需要保持原来的方向不变为a’, b减去在a上的投影得到b’就可以做到与a正交, 之后再把a’和b’进行schmit变换就可以(投影矩阵P如上面所讲$b’=b-Pa$)</p>
<p>如果有了第三个向量c, 也想与前两个构成正交矩阵, 则让c减去c在a’和b’上的投影, 以此类推, 每一个新的向量都是基于前述正交基向量来得到的</p>
<p><strong>这部分需要看课本再好好学一学啊</strong></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>MITLinearAlgebra(3)</title>
    <url>/2020/11/13/MITLinearAlgebra-3/</url>
    <content><![CDATA[<p>MIT线性代数笔记的第三部分</p>
<ul>
<li>行列式</li>
<li>克拉默法则,逆矩阵,体积</li>
<li>特征值与特征向量</li>
<li>对角化和A的幂</li>
<li>微分方程, exp(At)</li>
<li>马尔可夫矩阵,傅里叶级数</li>
</ul>
<a id="more"></a>
<p>完整链接:<br><a href="/2020/09/27/MITLinearAlgebra/" title="MITLinearAlgebra">MITLinearAlgebra</a><br><a href="/2020/11/13/MITLinearAlgebra-2/" title="MITLinearAlgebra(2)">MITLinearAlgebra(2)</a><br><a href="/2020/11/13/MITLinearAlgebra-3/" title="MITLinearAlgebra(3)">MITLinearAlgebra(3)</a><br><a href="/2021/03/17/MITLinearAlgebra-4/" title="MITLinearAlgebra-4">MITLinearAlgebra-4</a></p>
<h2 id="行列式与代数余子式"><a href="#行列式与代数余子式" class="headerlink" title="行列式与代数余子式"></a>行列式与代数余子式</h2><p>首先明确学习行列式的意义：为了后续计算特征值做铺垫</p>
<p>$detA$用于表示A的行列式</p>
<p>目前我们已知的是，行列式可以用来反映可逆性（invertibility）,行列式等于0代表矩阵(方阵)不可逆</p>
<p>从行列式的若干个性质开始：</p>
<ol>
<li>单位矩阵的行列式等于1</li>
<li>交换矩阵的行row exchange,行列式的值的符号会相反inverse sign of det 由此可以推出置换矩阵(permutation matrices)的行列式为1或者-1</li>
<li>行列式可以对<strong>某一行进行线性组合</strong><ol>
<li>对行列式的数乘等于对某一行单独的乘积</li>
<li>行列式相加等于某一行加一起而非所有行加一起<br><img src='detcom.png' width='500' title='行列式性质3'></li>
</ol>
</li>
</ol>
<p>扩展性质:</p>
<ol>
<li>两行相等则行列式为0</li>
<li>消元法时,对行k减去j倍行i,行列式不变</li>
<li>某一行为零向量,行列式为0</li>
<li>upper triangular matrix上三角矩阵的行列式等于对角元素乘积</li>
<li>当且仅当矩阵A是singular(not invertible)的时候,行列式为0</li>
<li>$detAB = detA\times detB$可以直接的推导出逆矩阵的行列式</li>
<li>转置之后行列式的值不变(列交换也可以改变符号)</li>
</ol>
<p>代数余子式cofactor</p>
<p>每一个行列式可以被分解为$N^2$个单独的行列式,每个非零行列式的每行每列都只有一个元素,因此每个行列式可以得到$N!$个非零的基础行列式</p>
<p>$det A= \sum \pm a<em>{1\alpha}a</em>{2\beta}a<em>{3\gamma}…a</em>{n\omega}$</p>
<p>以上就是行列式的公式,代数余子式$C<em>{ij}$<br>$cofactor of a</em>{ij}$指的是其中包含$a_{ij}$的项目,也就是把i行和j列选定的项, 行列式是否为正取决于$i+j$的正负</p>
<p>行列式的另一种计算方式就是把某一行的元素乘以他们的代数余子式的和<br>$det A = a<em>{11}C</em>{11}+a<em>{12}C</em>{12}+a<em>{13}C</em>{13}$</p>
<h2 id="克拉默法则与逆矩阵和体积"><a href="#克拉默法则与逆矩阵和体积" class="headerlink" title="克拉默法则与逆矩阵和体积"></a>克拉默法则与逆矩阵和体积</h2><h2 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h2><p>定义式非常熟悉了</p>
<script type="math/tex; mode=display">
Ax = \lambda x</script><ul>
<li>特征值的和等于矩阵的<strong>迹</strong></li>
<li>特征值的乘积等于矩阵的<strong>行列式</strong></li>
</ul>
<p>投影矩阵的特征向量，分为在投影平面上的所有向量和垂直于投影平面的向量</p>
<p>求解方式就是移项后行列式$det(A-\lambda I)=0$，可能会出现重根，重根比较麻烦（老师原话：重根是18.06痛苦的根源）</p>
<p>特征向量是上面那个移项后矩阵的零空间成员（零向量有很多，只需要列出来一个）</p>
<p>一个性质：如果给定的矩阵A加上若干个，例如m个单位矩阵，则特征向量不变，但是所有特征值都会同步加上m</p>
<ul>
<li><p>当系数矩阵是旋转矩阵（行列式为1的正交矩阵）的时候，它的特征值计算会出现<strong>复数</strong>，反对称的矩阵特征值是纯虚数，对称的矩阵特征值是实数</p>
</li>
<li><p>上三角矩阵的对角线元素就是特征值，退化矩阵，2x2的矩阵只有一个特征向量</p>
</li>
</ul>
<h2 id="对角化和A的幂"><a href="#对角化和A的幂" class="headerlink" title="对角化和A的幂"></a>对角化和A的幂</h2><p>如果A矩阵有n个线性无关的特征向量，组成特征向量矩阵S</p>
<script type="math/tex; mode=display">
AS = S\Lambda</script><p>对角化矩阵的元素就是每个特征值</p>
<ul>
<li>对角化之后可以很方便的求A的幂</li>
<li>所有的特征值绝对值小于1是一个使得矩阵幂“稳定”的条件，即结果会趋向于0</li>
</ul>
<p>那么哪些矩阵可以对角化？<br>即如何确保矩阵必然有n个线性无关的特征向量？</p>
<ul>
<li>所有的特征值不同</li>
</ul>
<p>斐波那契数列可以写成矩阵的形式，增长速度由特征值的最大值决定</p>
<script type="math/tex; mode=display">
u_{k+1} = Au_k</script><p>可以写成差分方程形式</p>
<script type="math/tex; mode=display">
[F_{k+2} , F_{k+1}]^T = A [F_{k+1} , F_k]^T</script><p>求解A的特征值就知道斐波那契数列的增长速度了</p>
<h2 id="微分方程和exp-A"><a href="#微分方程和exp-A" class="headerlink" title="微分方程和exp(A)"></a>微分方程和exp(A)</h2><script type="math/tex; mode=display">
\frac{du}{dt}=Au</script><p>解等于指数的特征值的组合（//TODO）</p>
<p>exp(At)可以进行泰勒展开，如果A可以对角化，还可以写成<br>$Se^{\Lambda t}S^{-1}$</p>
<h2 id="马尔可夫矩阵，傅里叶级数"><a href="#马尔可夫矩阵，傅里叶级数" class="headerlink" title="马尔可夫矩阵，傅里叶级数"></a>马尔可夫矩阵，傅里叶级数</h2><p>应用层面</p>
<p>马尔可夫矩阵：</p>
<ol>
<li>所有的元素大于0</li>
<li>所有列元素加起来等于1</li>
<li>所有矩阵的幂仍是马尔可夫矩阵</li>
</ol>
<h2 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h2><p>symmetric matrix</p>
<script type="math/tex; mode=display">A^T = A</script><p>实对称矩阵有较好的性质:</p>
<ol>
<li>实对称矩阵的特征值都是实数</li>
<li><strong>能够挑选出</strong>完全正交的一组特征向量，这组经过挑选得到的向量可以组成<strong>正交矩阵</strong></li>
</ol>
<p>从第二条可以得到对称矩阵的<strong>谱定理</strong></p>
<script type="math/tex; mode=display">A = Q\Lambda Q^{-1}= Q\Lambda Q^T</script><p>这个定理十分重要，在物理上被叫做主轴定理</p>
<p>根据谱定理，如果把正交矩阵写成一群列向量，则可以把上面的公式展开成n个<strong>投影矩阵</strong>的和</p>
<script type="math/tex; mode=display">A = q_1\lambda_1q^T_1 + .... + q_n\lambda_1q^T_n</script><p>实对称矩阵还有一条比较重要的性质：矩阵主元中positive的数量等于特征值中positive的数量</p>
<p>特征值全为正数的对称矩阵是<strong>正定矩阵</strong>中重要的一类，关于正定矩阵会在后面进行更详细的讨论</p>
<h2 id="正定矩阵和最小值"><a href="#正定矩阵和最小值" class="headerlink" title="正定矩阵和最小值"></a>正定矩阵和最小值</h2><p>正定矩阵有几种判定的条件，正定矩阵定义在对称矩阵之上</p>
<ol>
<li>矩阵所有的主元大于0</li>
<li>矩阵所有的特征值大于0</li>
<li>矩阵的各阶主子式行列式值大于0</li>
<li>$x^TAx$恒大于零</li>
</ol>
<p>第四点是比较接近<strong>正定</strong>定义的一种判定方式，它反映了以它为二次型矩阵时，f(x)函数值恒大于0的情形，进一步这个f(x)的偏导数矩阵，也就是这个矩阵A</p>
<p>如果将f(x)进行配凑，得到二次项之和，那么每一个二次项前面的系数都是主元，这也是主元、特征值作为判定条件的原因</p>
<p>对于非正定的矩阵，形成的二次型的图像会在原点形成一个鞍点saddle point，鞍点不同方向的梯度正负不同。而对于正定矩阵对应的二次型函数的图形，是一个抽象的bowl的形状或者说是一个抛物面。</p>
<p>对于向量$x$维度为3的时候，bowl会抽象为一个椭球，这个椭球的主轴就是特征向量的方向，这也是上一部分<strong>主轴定理</strong>名字的由来</p>
<p>插播一部分正定矩阵的内容，正定矩阵的定义式来自于最小二乘问题 $A^TA$ ，我们想了解关于这个表达式的正定性， $A$ 是一个长方形矩阵，行数大于列数。<br>两个前置结论：</p>
<ul>
<li>一个正定矩阵的逆矩阵还会是正定矩阵吗？是的。逆矩阵的特征值等于原矩阵特征值的倒数，也因此保持同号，进而同样满足正定矩阵特征值都为正的判定条件。</li>
<li>两个正定矩阵的和也仍然是正定矩阵。<br>使用正定矩阵的定义式判断$A^TA$<script type="math/tex; mode=display">
x^T(A^TA)x = (Ax)^TAx = \|Ax\|^2 \ge 0</script></li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>Embedded Linux System</title>
    <url>/2020/11/28/Embedded-Linux-System/</url>
    <content><![CDATA[<p>嵌入式Linux系统的一些概念，做一些记录，内容来源于Linux Foundation Instructor John Bonesio的系列文章。<br><a href="https://thenewstack.io/an-introduction-to-using-linux-in-embedded-systems/" target="_blank" rel="noopener">https://thenewstack.io/an-introduction-to-using-linux-in-embedded-systems/</a></p>
<a id="more"></a>
<h2 id="Major-components-for-embedded-linux-system"><a href="#Major-components-for-embedded-linux-system" class="headerlink" title="Major components for embedded linux system"></a>Major components for embedded linux system</h2><p>介绍嵌入式Linux系统中的相关组件，这里面bootloader常常不算做Linux系统的一部分，而被视作常规嵌入式系统的内容</p>
<h3 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h3><p>boot来自于一个笑话</p>
<blockquote>
<p>pick yourself up by your bootstraps</p>
</blockquote>
<p><strong>bootloader: find the Linux kernal’s program code, and load it into the memory</strong></p>
<p>the bootloader is different from what in desktop or server computer.</p>
<ul>
<li>desktop: BIOS —&gt; grub(bootloader) —&gt; os</li>
<li>embedded: init —&gt; Das-uboot(bootloader) —&gt; os</li>
</ul>
<p>Question: why we need bootloader? why can’t the os loaded itself into the memeory<br>Answer: for flexibility, without bootloader user can not set up multi-os computer</p>
<p>另一种回答说，这个问题提问的答案就是bootloader的作用，上面的回答可能解答了为什么os不放在固件ROM上（不灵活，不可更换，地方不够）</p>
<h3 id="kernal"><a href="#kernal" class="headerlink" title="kernal"></a>kernal</h3><p><strong>kernal: start the program and provide coordination among them</strong></p>
<p>the very first program: <em>init</em></p>
<p>init提供系统运行所必须的服务</p>
<p>这一部分kernal和x86上的在运行作用上没什么区别，但底层的实现明显不同</p>
<h3 id="root-file-system"><a href="#root-file-system" class="headerlink" title="root file system"></a>root file system</h3><p>storage medium can be SD cards, flash memory or even RAM in embedded system<br>在init程序运行之前，/根目录就应该挂载好，以放内核找不到init程序而崩溃<br>在嵌入式系统上的Linux文件系统很不一样</p>
<h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><blockquote>
<p>Linux folks traditionally call these services daemons or daemon programs</p>
</blockquote>
<p>通过init程序启动的，在后台运行的服务/守护进程</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>when an embedded computer starts, the Linux system will perform these steps:</p>
<ul>
<li>jump into the bootloader</li>
<li>jump into the kernel</li>
<li>mount the root filesystem</li>
<li>load and run init</li>
<li>load and run background services (or daemons)</li>
<li>load and run applications</li>
</ul>
<h3 id="cross-compiler"><a href="#cross-compiler" class="headerlink" title="cross compiler"></a>cross compiler</h3><p>交叉编译：指的是程序编译平台和运行平台不同</p>
]]></content>
      <categories>
        <category>UNIX/LINUX</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>UNIX/LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>MITLinearAlgebra</title>
    <url>/2020/09/27/MITLinearAlgebra/</url>
    <content><![CDATA[<p>MIT Prof. Gilbert Strang 的公开课，讲解线性代数的知识，这里做一个小笔记，简单记录每个课堂里的重点。</p>
<ul>
<li>方程组的几何解释</li>
<li>矩阵的消元和LU分解</li>
<li>列空间与零空间</li>
<li>求解Ax=b</li>
</ul>
<a id="more"></a>
<p>完整链接:<br><a href="/2020/09/27/MITLinearAlgebra/" title="MITLinearAlgebra">MITLinearAlgebra</a><br><a href="/2020/11/13/MITLinearAlgebra-2/" title="MITLinearAlgebra(2)">MITLinearAlgebra(2)</a><br><a href="/2020/11/13/MITLinearAlgebra-3/" title="MITLinearAlgebra(3)">MITLinearAlgebra(3)</a><br><a href="/2021/03/17/MITLinearAlgebra-4/" title="MITLinearAlgebra-4">MITLinearAlgebra-4</a></p>
<h2 id="方程组的几何解释"><a href="#方程组的几何解释" class="headerlink" title="方程组的几何解释"></a>方程组的几何解释</h2><p>以三维的方程组为例(随便写的)</p>
<script type="math/tex; mode=display">

5x + 4y -  z = 0\\\\</script><script type="math/tex; mode=display">
2x +  y - 3z = 1\\\\</script><script type="math/tex; mode=display">
3x - 4y - 2z =-2\\\\</script><script type="math/tex; mode=display">
A=
\begin{pmatrix}

5 & 4& -1\\
2 & 1& -3\\
3 &-4& -2\\
\end{pmatrix}</script><ul>
<li>row picture：逐行解释，满足每行方程的点在三维空间里能够形成一个二维的平面，三个平面的交点就是满足方程组的解</li>
<li>column picture：把系数矩阵A视作三个列向量，原方程视作三个三维列向量的线性组合</li>
</ul>
<script type="math/tex; mode=display">

x\begin{bmatrix}
5&\\
2&\\
3
\end{bmatrix}

+y\begin{bmatrix}
4&\\
1&\\
-4
\end{bmatrix}

+z\begin{bmatrix}
-1&\\
-3&\\
-2
\end{bmatrix}</script><p>$\color{red}{矩阵\times列向量=列向量}$</p>
<p>明显，以列向量线性组合的方式更简洁，更符合直观认识。</p>
<h2 id="矩阵消元"><a href="#矩阵消元" class="headerlink" title="矩阵消元"></a>矩阵消元</h2><p>讲解的内容为高斯消元法，思路很简单，所涉及到的都是<strong>行变换</strong></p>
<p>消元：</p>
<ol>
<li>如果(1,1)元素非0，将其作为第一列主元，保留第一行不变</li>
<li>通过矩阵行加法，将第一列其余元素变为0</li>
<li>查看第二列，若(2,2)元素为0，寻找非零主元pivot，找到后将其所在行与第二行交换，使用矩阵行加法将其余行的第二列元素变为0</li>
<li>重复上述消元步骤，直至将A变化为上三角矩阵U</li>
</ol>
<p>回代：</p>
<ol>
<li>对$Ax=b$等式右侧的$b$列向量运用同样的上述变换</li>
<li>先计算出最后一维的解，再依次求解所有的变量解</li>
</ol>
<p>那么上述的行变换过程如何用矩阵表示呢？</p>
<p>需要首先明确的是，行变换需要的是左乘，与上一节右乘列向量得到列向量类似，有</p>
<p>$\color{red}{行向量\times矩阵=行向量}$</p>
<p>一个行向量的左乘就代表一次矩阵$A$行向量的线性组合，产生一个新的行向量。每一次每一列的消元，就是n次的矩阵A行向量的线性组合，形成的是$n$个新的行向量。</p>
<p>因此，每一列的消元都是左乘一个跟$A$一样维度的方阵，如果对上面的三维矩阵$A$，将方阵的下标写成每次要消去的第一个元素的代号，那么可以将两次消元的方阵写作$E<em>{(2,1)}和E</em>{(3,2)}$，他们的乘积$E$就是这次表示消元所需要的矩阵。</p>
<script type="math/tex; mode=display">
A=
\begin{pmatrix}

5 & 4& -1\\
2 & 1& -3\\
3 &-4& -2\\
\end{pmatrix}</script><p>下面简要说明其中一个方阵的书写思路，也就是线性组合的思路</p>
<script type="math/tex; mode=display">
E_{(2,1)}第一行负责计算新矩阵的第一行\\保持不变所以是{1，0，0},以此类推\\新第二行是旧的第二行减去0.4倍的第一行\\新第三行是旧第三行减去0.6倍的旧第一行\\
E_{(2,1)}=
\begin{pmatrix}

1 & 0&  0\\
-0.4 & 1& 0\\
-0.6 &0& 1\\
\end{pmatrix}</script><p>上述是行变换的矩阵，如果需要计算列变换对应的矩阵，和上面的思路是一致的，只不过矩阵变成了右乘。</p>
<p><strong><em>矩阵消元法也会有失败的时候，也就是最后发现某一列找不到主元元素了，即剩余的元素都是0</em></strong></p>
<p><em>一般不会去直接计算E，而是去计算各方阵的逆</em>（原因好像没解释）</p>
<h2 id="矩阵的乘法和逆矩阵"><a href="#矩阵的乘法和逆矩阵" class="headerlink" title="矩阵的乘法和逆矩阵"></a>矩阵的乘法和逆矩阵</h2><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><script type="math/tex; mode=display">A\times B=C</script><p>矩阵乘法的四种方法：</p>
<ol>
<li>点乘对应A行B列得到C中的某一个元素</li>
<li>A中列向量的线性组合，A分别与B中每个列向量相乘</li>
<li>B中行向量的线性组合，B分别与A中每个行向量相乘</li>
<li>A和B中对应列对应行分别的乘积，得到若干个矩阵，矩阵相加为结果（一列乘一行得到一个矩阵，很特殊，每一行和每一列都是线性相关）</li>
</ol>
<p>矩阵还可以分块乘积</p>
<h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><p>这里讨论的都是方阵的逆矩阵，方阵的逆矩阵左右乘都可以，非方阵的不可以</p>
<p>可逆的，非奇异的<br>invertible，nonsingular</p>
<p><strong>什么样的方阵是不可逆的：</strong></p>
<ul>
<li>行列式为0的矩阵</li>
<li>矩阵的行向量或者列向量存在线性相关</li>
<li>存在非零向量$x$，使得$Ax=0$成立</li>
</ul>
<blockquote>
<p>第三个的简单证明，使用反证法，若存在$A^{-1}$，则若$Ax=0$成立，那么$A^{-1}Ax=Ix=0 \Rightarrow x=0$，矛盾</p>
</blockquote>
<p><strong>使用Gauss-Jordan思路求逆矩阵：</strong></p>
<ol>
<li>将原矩阵$A$与单位矩阵$I$组合形成增广矩阵$[A|I]$</li>
<li>对增广矩阵进行高斯消元，使用行变换方法，将左半部分转化为上三角矩阵</li>
<li>使用jordan思路，反向行变换，将上三角矩阵变成单位阵，则此时右半部分即为$A^{-1}$</li>
</ol>
<h2 id="矩阵的LU分解"><a href="#矩阵的LU分解" class="headerlink" title="矩阵的LU分解"></a>矩阵的LU分解</h2><p>本节内容：</p>
<ul>
<li>逆矩阵和转置矩阵的基本知识</li>
<li>如何理解A=LU分解</li>
<li>A的高斯消去需要多少步骤</li>
<li>permutation置换矩阵是啥以及它的性质</li>
</ul>
<h3 id="逆矩阵和转置的一些基本知识"><a href="#逆矩阵和转置的一些基本知识" class="headerlink" title="逆矩阵和转置的一些基本知识"></a>逆矩阵和转置的一些基本知识</h3><script type="math/tex; mode=display">

(AB)^{-1} = B^{-1}A^{-1} \\\\</script><script type="math/tex; mode=display">
(AB)^{T} = B^{T}A^{T}  \\\\</script><script type="math/tex; mode=display">
(A^{T})^{-1} = (A^{-1})^{T} \\\\</script><h3 id="LU分解"><a href="#LU分解" class="headerlink" title="LU分解"></a>LU分解</h3><blockquote>
<p>前提：<br>矩阵是方阵（LU分解主要是针对方阵）；<br>矩阵是可逆的，也就是该矩阵是满秩矩阵，每一行都是独立向量；<br>消元过程中没有0主元出现，也就是消元过程中不能出现行交换的初等变换。</p>
</blockquote>
<p>意义：单次LU分解量不小，但是可以反复利用LU</p>
<blockquote>
<p>看起来比高斯消元经历了更多的步骤，那为什么又说LU分解更快呢？在实践中，b是输出，输出又经常变动，从Ax = b频繁地变成Ax = b’，此时高斯消元就需要全部重新计算（高斯消元用增广矩阵消元，变化过程是[A, b]→[U, b’]），这对大型矩阵来说及其耗时。反观LU分解，因为它不依赖于b，所以计算一次后就可以存储U和L-1，在输出变化后也只是需要简单的相乘。实际上，由于L已经是整理过的斜对角全是1的下三角矩阵，所以用高斯-诺当消元法对L求逆非常简单。</p>
</blockquote>
<script type="math/tex; mode=display">
EA = U\\\\</script><script type="math/tex; mode=display">
L = E^{-1}\\\\</script><script type="math/tex; mode=display">
A = LU \\\\</script><p>U代表upper上三角矩阵，L代表lower下三角矩阵。<br>如果将U继续分解为DU,可以得到新的分解LDU，下三角乘对角乘上三角。</p>
<script type="math/tex; mode=display">

A = LDU</script><p>推荐LU分解的原因在于，利用单个的消元矩阵$E<em>{2,1},E</em>{3,1}$这种直接去求$E$其实很麻烦，因为会涉及到复杂的矩阵乘法运算，后续的步骤会受到前序消元的影响，不能直接通过理解写出$E$。</p>
<p>而L矩阵因为是逆矩阵的乘积，顺序从最后一行返回第一行，每一个都不会受到前序矩阵的影响，因此能够直接把单个的消元矩阵的元素拼接到一起形成一个下三角矩阵。</p>
<blockquote>
<p>如果没有行交换操作，则消元矩阵的因子可以直接写入矩阵L。没有多余的交叉项出现是LU分解要优于EA=U这种形式的原因之一。</p>
</blockquote>
<h3 id="消元法的计算量"><a href="#消元法的计算量" class="headerlink" title="消元法的计算量"></a>消元法的计算量</h3><p>将线性组合每进行一次行元素的乘和加减作为一次操作，例如将第一行某一个元素乘以两倍，再用第二行对应元素减去，这个算一次操作。</p>
<p>第一列除了第一个元素外消成0，这个流程总共需要大约$n^2$次操作，一个矩阵完成消元需要$\sum^{N}_{i} i^2$次，拿微积分公式近似计算一下发现需要$1/3N^{3}$次计算操作。</p>
<p>等号右侧向量b的行变换大致需要nxn次运算。</p>
<h3 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h3><p>表示row exchange行交换的矩阵，行交换在高斯消元法里用于寻找主元，</p>
<p>直接用单位矩阵的各种行交换矩阵就可以表示出置换矩阵的样子。</p>
<p>对于n阶的方阵，总共有n！个置换矩阵，置换矩阵的逆矩阵也是置换矩阵，同时也是置换矩阵的转置矩阵。即如果置换矩阵是对称矩阵，则其是三矩阵一体，原矩阵=逆矩阵=转置矩阵。</p>
<h2 id="转置-置换-向量空间"><a href="#转置-置换-向量空间" class="headerlink" title="转置-置换-向量空间"></a>转置-置换-向量空间</h2><p>symmetric matrix</p>
<script type="math/tex; mode=display">

M^{T} = M</script><p>任何转置矩阵乘以本身得到的都是对称矩阵$R^{T}R=(R^{T}R)^{T}$</p>
<p>$R^{T}R$ is always symmetric</p>
<h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h3><p>对于其中向量进行线性计算（加法和数乘）封闭（closed）的空间$R^{n}$显然是向量空间<br>0向量必须是向量空间中的一部分<br>向量子空间是向量空间中的一部分，本质上感觉是对n-1维基向量重新展开的结果，比如在$R^{2}$中过零点的直线。（不，这不一样，不是一维的）</p>
<p><strong>subspace of $R^{2}$</strong>:</p>
<ul>
<li>$R^{2}$</li>
<li>any line through origin</li>
<li>zero vector only</li>
</ul>
<p>比较特殊的是零向量空间，这个空间里只有0向量，所以线性计算都能成立，是个单矢量空间</p>
<h3 id="列空间和零空间"><a href="#列空间和零空间" class="headerlink" title="列空间和零空间"></a>列空间和零空间</h3><p>用矩阵中的列向量作为基向量，形成spin得到的子空间称为列空间C（A），column space</p>
<p>两个向量子空间，P和L，那么两个子空间的并集并非向量空间，因为对加法不封闭。两个空间的交集则是子空间，因为所包含的向量无论做加法还是数乘都一定在这个交集里面。</p>
<script type="math/tex; mode=display">

A=
\begin{pmatrix}

1 & 1& 2\\
2 & 1& 3\\
3 & 1& 4\\
4 & 1& 5\\ 
\end{pmatrix}</script><p>对于$Ax=b$，当b属于A的列空间时有解。<br>观察矩阵A，发现第三列是前两列的线性组合，这里将前两列称作主列，并说这三列是线性相关的，去掉非主列不影响列空间的规模。</p>
<h4 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h4><p>null space of A： add solutions to $Ax=0$使得方程成立的解组成的空间是零空间</p>
<ul>
<li>nullspace certainly contains zero零空间包含零向量，的确是个向量空间</li>
<li>对于A矩阵来说，零空间得到了一条直线 [c,c-c]</li>
<li>a line in $R^3$</li>
<li>零空间是向量空间的检验，和向量与数乘后向量依然满足$Ax=0$的方程，证明非常明显$A(w+v)=0, A(kw)=0$<h4 id="解空间？"><a href="#解空间？" class="headerlink" title="解空间？"></a>解空间？</h4>？？？对于$Ax=b,b\ne0$这个方程的解不构成向量空间，最容易证明的是这个解里面不包含0。解是一个不通过零点的直线。</li>
</ul>
<h3 id="解Ax-0主变量和特解"><a href="#解Ax-0主变量和特解" class="headerlink" title="解Ax=0主变量和特解"></a>解Ax=0主变量和特解</h3><script type="math/tex; mode=display">
A=
\begin{pmatrix}
1 & 2& 2&2 \\
2 & 4& 6&8 \\
3 & 6& 8&10 \\
\end{pmatrix}</script><p>随着消元法进行，零空间不改变，改变了列空间。</p>
<script type="math/tex; mode=display">
得到了一个echelon form
staircase form阶梯形矩阵
U=
\begin{pmatrix}
1 & 2& 2&2 \\
0 & 0& 2&4 \\
0 & 0& 0&0 \\
\end{pmatrix}</script><p>这里引入了<strong>Rank</strong>的定义：表示Ux=0中阶梯型矩阵U主元（<strong>pivot variable</strong>）的个数。主元所在的列称作主列（<strong>pivot column</strong>），其余列为自由列（<strong>free column</strong>），自由列对应的变量元素（<strong>free variable</strong>）可以自由的取值，我们要求解的只有主元的值。</p>
<ul>
<li><strong>任意对free variable赋值可以得到special solution特解</strong>，特解的线性组合就是null space。</li>
<li>每一个自由变量对应一个特解。</li>
<li>自由变量有多少呢？自由变量=列数n-主元r，r个主变量代表只有r个方程起作用，那么（n-r）个自由变量可以得到（n-r）个特解。</li>
</ul>
<h4 id="进一步简化"><a href="#进一步简化" class="headerlink" title="进一步简化"></a>进一步简化</h4><p>矩阵R = Reduced row echelon matrix<br>做向上消元，使得主元上下都是0，主元化1</p>
<script type="math/tex; mode=display">
R=
\begin{pmatrix}
1 & 2& 0&-2 \\
0 & 0& 1&2 \\
0 & 0& 0&0 \\
\end{pmatrix}</script><p>包含所有信息的最简形式，所有主元为1，形成一个单位矩阵。$Rx=0$仍然是零空间的向量。<br>移动R中列，得到</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
I&F\\
0&0\\
\end{pmatrix}</script><p>N零空间矩阵nullspace matrix<br>为了$RN=0$</p>
<script type="math/tex; mode=display">
N=
\begin{pmatrix}
-F\\
I\\
\end{pmatrix}</script><p>N就是其中的一个特解，这里可以清晰看到通过简化行矩阵，可以清楚的写出零空间特解。<br><em>这里有点迷惑，因为感觉这样会造成解元素顺序的混乱。。。</em></p>
<h2 id="求解Ax-b，complete-solution"><a href="#求解Ax-b，complete-solution" class="headerlink" title="求解Ax=b，complete solution"></a>求解Ax=b，complete solution</h2><script type="math/tex; mode=display">
Augmented Matrix=
\begin{pmatrix}
1& 2& 2& 2& b1\\
2& 4& 6& 8& b2\\
3& 6& 8& 10& b3\\
\end{pmatrix}</script><p>为了有解b1，b2，b3需要满足条件。</p>
<h3 id="可解性"><a href="#可解性" class="headerlink" title="可解性"></a>可解性</h3><p>如何可以让Ax=b有解？</p>
<ul>
<li>仅当b属于C（A）的时候有解</li>
<li>如何A的<strong>行向量组合</strong>得到了0，那么b的组合也要等于0</li>
</ul>
<p>求解过程：</p>
<ol>
<li>找出一个特解<ol>
<li>将自由向量置0</li>
<li>求解Ax=b中的主元素</li>
</ol>
</li>
<li>可以加上nullspace中的任意向量</li>
<li>最终结果就是全解<br>（与线性微分方程惊人一致，这种形式存在于各种线性方程中）<br>$X<em>{complete}=X</em>{p}+c<em>{1}Xn</em>{1}+c<em>{2}Xn</em>{2}$<br>零空间是一个二维向量子空间，但是x的全解的空间不是向量空间，因为不过0点。</li>
</ol>
<p><strong>扩展思考可解性</strong><br>m*n matrix A of rank r<br>know:</p>
<ul>
<li>$r\le m$</li>
<li>$r\le n$</li>
</ul>
<p>讨论满秩情况<br><strong>full column rank</strong><br>没有自由向量，全都是主元，就意味着没有零空间的特解。N（A）只有零向量。$Ax=b$的解只有一个特解$X_{unique}$。</p>
<p><em>列满秩情况如果解存在则解唯一</em><br>b在A列空间中的时候有解</p>
<p><strong>full row rank</strong> </p>
<ul>
<li>对任意b都会有解，对于b没有要求，每一行都有主元，<em>不会有零行</em>。</li>
<li>自由变量数目为n-m个free variables</li>
</ul>
<ol>
<li><p><strong>r=n=m</strong><br>满秩方阵<br>R = I 有唯一解</p>
</li>
<li><p>r=n &lt; m<br>R = [I;0] 没有解或者唯一解</p>
</li>
<li><p>r=m &lt; n<br>R = [I F] 有解 I和F会交叉出现，无穷多解</p>
</li>
<li><p>r &lt; m, r &lt; n<br>R = [I F; 0 0]<br>0或者无穷多解</p>
</li>
</ol>
<p>是否有解在于Ax=b的特解是否存在，而是否有无穷解则看零空间是否只含零向量（是否有自由变量）。</p>
<p><strong>Rank里包含了所有解数量的信息</strong></p>
<a href="/2020/11/13/MITLinearAlgebra-2/" title="MITLinearAlgebra(2)">MITLinearAlgebra(2)</a>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2020Note-1</title>
    <url>/2020/09/29/ML2020Note-1/</url>
    <content><![CDATA[<p>李宏毅老师2020年机器学习课程的一点学习笔记，作为重新学习机器学习的开始吧。<br><a id="more"></a></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>15次作业，使用Pytorch。</p>
<p>前沿研究：</p>
<ul>
<li>Explainable AI 解释原因</li>
<li>Adversarial Attack 恶意攻击</li>
<li>Network Compression 网络压缩</li>
<li>Anomaly Detection 异常识别</li>
<li>Transfer Learning 迁移学习</li>
<li>Meta Learning 自学成才：学习如何得到学习算法</li>
<li>Life-long Learning：终身学习</li>
</ul>
<p><img src='intro.PNG' width='600' title='learning map'></p>
<p><strong>hand-crafted rules</strong></p>
<ul>
<li>永远无法超过创造者</li>
<li>Lots of human effort</li>
</ul>
<ol>
<li>去github上安装pyenv，一个学习环境，防止装崩</li>
<li>kaggle每个人五次预测结果</li>
<li>github提交作业</li>
</ol>
<h2 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h2><p>线性回归基本的流程:</p>
<ol>
<li>选取一种model或者function</li>
<li>选择一种cost function</li>
<li>在训练集上选取并使用梯度下降算法对model的参数进行优化</li>
<li>在测试集上对model进行评估</li>
<li>若对于结果表现不满意重新选取model, 或者审视数据重新处理(也算重选model)</li>
</ol>
<h3 id="complex-better"><a href="#complex-better" class="headerlink" title="complex!=better"></a>complex!=better</h3><p>模型在选择时候不一定越复杂效果越好,越复杂的模型通常会在训练集上表现越来越好, 但是在测试集上误差不一定会变好, 即有可能出现了overfit这种情况</p>
<p><img src='overfit-regression.png' width='500' title='线性回归中出现的过拟合现象'></p>
<p>在图中, 使用多项式进行线性回归, 横轴代表多项式的维度越来越高, 纵轴是平均误差值, 出现了先上升后下降的情形, 这代表出现了过拟合的情况</p>
<p>为了解决这个问题, 可以1.重新选择模型 2.使用regularization正则化手段</p>
<h3 id="regularization"><a href="#regularization" class="headerlink" title="regularization"></a>regularization</h3><p>正则化在这里说的是增加一项进入cost function, 使得参数趋向于0, 这可以让每次的变动更小, 梯度下降的更为平滑, 换言之就是对输入的敏感程度大幅下降, 能帮助处理噪声造成的影响</p>
<p><img src='regularization-regression.png' width='500' title='正则化使得模型对于输入不敏感'></p>
<p>正则化的两点好处:</p>
<ol>
<li>变化幅度小,更平滑</li>
<li>对于噪声的抵抗力增强</li>
</ol>
<p><img src='regularization-regression2.png' width='500' title='正则化系数对于性能的影响'></p>
<p>但是,我们也要看到正则化的系数并非越大越好, 换言之模型的梯度下降也不应该过于的smooth</p>
<p><strong>偏置项不需要加入正则化里面</strong></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2020Note-2</title>
    <url>/2020/12/14/ML2020Note-2/</url>
    <content><![CDATA[<p>ML2020note2：RNN 循环神经网络的由来 原理 以及标准LSTM<br><a id="more"></a></p>
<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h3 id="Slot-Filling"><a href="#Slot-Filling" class="headerlink" title="Slot Filling"></a>Slot Filling</h3><p><strong>I will arrive Taipei on November 2nd</strong><br>挖词槽，找到关键词的任务，如果使用原本的神经网络（对每一个词汇进行编码），难以分析前后文的信息，即网络缺乏<strong>记忆力</strong>。</p>
<p><strong>Recurrent Neural Network</strong><br>循环神经网络，隐藏层的输出会被存储在内存中，参与下一个序列值的计算<br><img src='rnn.png' width='600' title='rnn'><br>图中蓝色部分就是被记忆的部分，初始会有一个值，之后每次序列计算完成后都会把绿色存入蓝色</p>
<p>改变输入序列的顺序，得到的结果完全不一样！序列输入的顺序影响输出的值。</p>
<p>有两类RNN的基本结构，jordan是把结果保存在内存里，Lee说jordan的效果似乎更好，可能是因为有结果target<br><img src='rnn-2.png' width='600' title='elman vs jordan'></p>
<h3 id="Bidirection双向的网络"><a href="#Bidirection双向的网络" class="headerlink" title="Bidirection双向的网络"></a>Bidirection双向的网络</h3><p><img src='brnn.png' width='600' title='Bi-RNN'><br>序列不同方向训练，结果相加输出<br>网络可以看到整个的句子</p>
<h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p><em>较长的短期记忆</em><br>Long Short-Term Memory<br><img src='lstm.png' width='600' title='LSTM'><br>有几道门控制着记忆单元的存储内容，门的开关信号都是通过学习得到</p>
<p>使用sigmoid来模拟0，1信号，模拟门的开关。$f(z_f)=0$时执行了遗忘的功能，$f(z_i)=0$时执行输入关闭的效果<br><img src='lstm-2.png' width='600' title='LSTM GATES'></p>
<p>实际上这些门是通过调整权重实现的，会让输入的向量中的某一些元素乘以权重得到控制门开闭的效果<br>例如在下图中，向量第一个元素代表输入，第二个元素1的时候开输入门，-1的时候关闭遗忘门，第三个元素等于1的时候开启输出门<br><img src='lstm-3.png' width='600' title='LSTM GATES2'></p>
<p>如果用LSTM模块直接替代原有的网络神经单元，参数会变成<strong>四倍</strong>！<br><img src='lstm-4.png' width='600' title='LSTM GATES3'></p>
<p>LSTM的循环执行过程，每一时刻输入的量有原输入，LSTM模块上一时刻的输出，以及上一时刻的cell的内容<br><img src='lstm-5.png' width='600' title='LSTM Layer'></p>
<p>上述的LSTM层会重复个五六层以来达到较好的效果，相当复杂，，但是目前也成了RNN的标准操作，当人们谈论RNN的时候，他一般就是在说lstm<br><img src='lstm-6.png' width='600' title='LSTM NET FULL'></p>
<p><strong>GRU</strong>：LSTM的简化版本，只有两个gate，但据说表现比较相当，参数少了三分之一</p>
<p><strong>SimpleRNN</strong>：一开始讲的最简单的rnn结构</p>
<h3 id="cost-func-and-training"><a href="#cost-func-and-training" class="headerlink" title="cost func and training"></a>cost func and training</h3><p>Backpropagation through time BPTT<br>。。。Lee没有讲，是与时间序列有关的反向传播算法</p>
<p>RNN的训练是比较困难的，训练的loss曲线会有很剧烈的抖动，RNN的error surface非常都平坦或者陡峭，导致振荡可能很剧烈</p>
<p><img src='rnn-lose.png' width='600' title='RNN-LOSE'></p>
<p>这种崎岖的原因在于循环神经网络会导致memory乘以w的多次方，出现梯度弥散和爆炸</p>
<p><strong>LSTM的优势：可以处理梯度弥散（非爆炸）！这是广泛使用的原因</strong></p>
<p>会拿掉一些比较平坦的地方，但还是有比较陡峭的地方，一般学习率learning rate设置的比较小</p>
<ul>
<li>memory和input是相加的关系</li>
<li>如果forget gate开着那么就不会有梯度弥散gradient vanishing（简单RNN的memory每一个时刻都会forget然后变成新的值，也就是说对memory造成影响的东西会较为长久的留在里面，造成影响）</li>
<li>GRU Gated Recurrent Unit只有两个gate，参数少不容易overfit，精神是“旧的不去新的不来”</li>
</ul>
<p>一些应用：</p>
<ul>
<li>Many to One</li>
<li>Many to Many（NLP，CTC）</li>
<li>Many to Many（No Limitation）</li>
<li>beyond sequence</li>
<li>auto encoder使语音变成向量</li>
</ul>
<h3 id="Attention-based-model"><a href="#Attention-based-model" class="headerlink" title="Attention-based model"></a>Attention-based model</h3><p>注意力机制是从机器的memory中提取出感兴趣的部分</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2020Note-3</title>
    <url>/2020/12/17/ML2020Note-3/</url>
    <content><![CDATA[<p>到了期待已久的异常检测部分，学点新知识</p>
<a id="more"></a>
<h2 id="什么是异常检测"><a href="#什么是异常检测" class="headerlink" title="什么是异常检测"></a>什么是异常检测</h2><p><strong>Anomaly Detection</strong>：让机器知道自己不知道</p>
<p>Anomaly并不是错误，只是样本不属于原有模型可以识别进行分类的数据</p>
<p>异常检测问题的分类categories：</p>
<ul>
<li>训练数据带有标签：classifier</li>
<li>无标签数据<ul>
<li>所有的数据全部为正常数据</li>
<li>部分数据被污染，包含异常数据（银行的交易记录）</li>
</ul>
</li>
</ul>
<h2 id="带标签数据的检测"><a href="#带标签数据的检测" class="headerlink" title="带标签数据的检测"></a>带标签数据的检测</h2><h3 id="一种简单的方法"><a href="#一种简单的方法" class="headerlink" title="一种简单的方法"></a>一种简单的方法</h3><p>从一个分类器入手，假设现在有一个训练好的classifier，会为每一个输入的图片输出属于各种类别的概率。<br>现在设定一个额外的数值，称为confidence信心，confidence的计算方法可以人为设定，最简单的方法是选取各类别预估概率中的最大值。<br>如果信心值小于阈值$\lambda$，则认为输入的样本属于异常值。信心值过小，可以认为是分类器对与估计的把握很小，或者理解为出现了它无法识别的东西，也就是分类意义上的异常类别。<br><em>这种方法很简单，但是目前是很有效的方法之一</em></p>
<p><img src='confidence.png' width='600' title='normal-anomaly confidence'></p>
<p>上图是一个“辛普森家族分类器”面对两种数据（正常与异常数据，异常为辛普森家族之外的动漫图片）时的分类信心值，可以看到面对正常数据的时候，大部分的信心值的结果都接近1，而对于异常数据（凉宫春日）的时候，大部分的信心值相对较低。也就是信心值对于正常、异常数据的分布有比较明显的区别。</p>
<h3 id="示例框架"><a href="#示例框架" class="headerlink" title="示例框架"></a>示例框架</h3><p>Training Set：全部数据来自于辛普森家族的图片，并得到了良好的标注<br>Dev Set： 图片有一些不是来自辛普森家族，得到了良好的标注，用于调整超参数$\lambda$<br>Test Set: 测试用例</p>
<p><img src='evaluation.png' width='600' title='result'></p>
<p>红色的点是异常值，发现也有存在部分信心值很高的异常数据，但总的来说大部分正常数据的信心值都非常高。<br>如果只使用accuracy来衡量结果，对于异常检测来说很不合理，因为绝大多数数据都是正常的，系统会趋向于直接把所有数据变成正常！<br>这边就又要用precision+recall来判断了，具体问题precision和recall的重要度并不同，比如癌症判断的时候人们对于召回率更看重。</p>
<p>一些模型可以直接学习出confidence。<br>使用GAN去生成异常数据，来弥补异常数据不够的问题。</p>
<h2 id="无标签数据的检测"><a href="#无标签数据的检测" class="headerlink" title="无标签数据的检测"></a>无标签数据的检测</h2><p>检测示例：宝可梦在线游戏中检测游戏小白</p>
<ul>
<li>从输入中提取向量数据</li>
<li>没有标签数据</li>
</ul>
<h3 id="最大似然函数"><a href="#最大似然函数" class="headerlink" title="最大似然函数"></a>最大似然函数</h3><p>假设所有的数据点都是一个概率密度函数$f_\theta(x)$</p>
<script type="math/tex; mode=display">
L(\theta) = f_\theta(x^1)f_\theta(x^2)...f_\theta(x^N)</script><p><strong>Likelihood</strong></p>
<script type="math/tex; mode=display">
\theta^* = argmax_\theta L(\theta)</script><p>一种常用的模型：高斯分布<br><img src='gaussian.png' width='600' title='gaussian distribution'></p>
<p>高斯分布由均值（vector）和相关矩阵（matrix）决定</p>
<p><strong>为什么用高斯分布？</strong>：常用，效果很好，有时候看起来根本不是高斯的分布，可以更深入的寻找function</p>
<h2 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h2><ol>
<li><p>Auto-Encoder 训练输入与输出越像越好。测试的时候，如果还原回来的图片和原图片很像，那么可以认为是异常图片</p>
</li>
<li><p>One-class SVM</p>
</li>
<li><p>Isolated Forest 周志华</p>
</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2020Note-4</title>
    <url>/2020/12/22/ML2020Note-4/</url>
    <content><![CDATA[<p>无监督学习 自编码器 自编码网络<br>Auto-Encoder and More Auto-Encoder<br><a id="more"></a></p>
<p><img src='auto.png' width='500' title='auto-encoder'></p>
<h2 id="PCA-and-Deep-Auto-Encoder"><a href="#PCA-and-Deep-Auto-Encoder" class="headerlink" title="PCA and Deep Auto-Encoder"></a>PCA and Deep Auto-Encoder</h2><p>Auto Encoder是无监督学习的一种，相比监督学习可以利用的data数据更多（不需要标注）</p>
<p>PCA是一种编解码器，编码和解码的权重是转置的关系</p>
<h2 id="Text-Retrieval"><a href="#Text-Retrieval" class="headerlink" title="Text Retrieval"></a>Text Retrieval</h2><p>文本检索，输入query返回最接近的文件</p>
<p><img src='textRetrieval.png' width='500' title='textRetrieval'></p>
<p>使用auto-encoder将维度降低到2维，可以看到非常满意的分类结果<br><img src='textRetrieval2.png' width='500' title='textRetrieval2'></p>
<h2 id="Similar-Imgae-Search"><a href="#Similar-Imgae-Search" class="headerlink" title="Similar Imgae Search"></a>Similar Imgae Search</h2><p>相似图像搜寻<br>如果在像素等级进行距离计算，结果令人很不满意，而使用encoder在编码之后</p>
<p><img src='imageSearch.png' width='500' title='imageSearch'><br><img src='imageSearch2.png' width='500' title='imageSearch'></p>
<h2 id="Pre-Training"><a href="#Pre-Training" class="headerlink" title="Pre-Training"></a>Pre-Training</h2><p><img src='pre.png' width='500' title='pre'><br>如果encoder的hidden layer超过了输入输出，那么需要在隐藏层添加一个很强的regularzation，需要中间很大的维度是一个系数的矩阵，让起到作用的神经元数量比较少，防止网络直接把输入原样输出</p>
<p><img src='pre2.png' width='500' title='pre2'></p>
<p>逐层的用auto-encoder学习隐藏层，作为预训练的参数<br>这样类似identity学习的方式可以学到比较好的权重，之后fine-tune会得到比较好的数据</p>
<h2 id="De-Noising-auto-encoder"><a href="#De-Noising-auto-encoder" class="headerlink" title="De-Noising auto-encoder"></a>De-Noising auto-encoder</h2><p>用加噪声后的数据作为输入，以加噪声之前的数据作为要学习的target，可以得到一个去噪的网络</p>
<p><img src='noise.png' width='500' title='noise'></p>
<h2 id="CNN-Unpooling-Deconvolution"><a href="#CNN-Unpooling-Deconvolution" class="headerlink" title="CNN-Unpooling-Deconvolution"></a>CNN-Unpooling-Deconvolution</h2><p><img src='unpooling.png' width='500' title='unpooling'></p>
<p>反pooling是一种扩充image的方法</p>
<p>反卷积实际上就是卷积，只不过权重的顺序不一样</p>
<h2 id="More-About-Auto-Encoder"><a href="#More-About-Auto-Encoder" class="headerlink" title="More About Auto-Encoder"></a>More About Auto-Encoder</h2><h3 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h3><p><img src='discri.png' width='500' title='discriminator'></p>
<p>把encoder和discriminator一起训练，discriminator是评价encoder的一个指标</p>
<p>这是一种特殊的auto-encoder</p>
<h3 id="sequential-data"><a href="#sequential-data" class="headerlink" title="sequential data"></a>sequential data</h3><p>to  be continued</p>
<h3 id="Explainable-Encoder"><a href="#Explainable-Encoder" class="headerlink" title="Explainable Encoder"></a>Explainable Encoder</h3><p>Encoder如何变得可解释<br>Feature Disentangle<br>从数据中提取不轻易可以看到的特征信息，比如从一段语音中提取到声音信息</p>
<h3 id="Discrete-Representation"><a href="#Discrete-Representation" class="headerlink" title="Discrete Representation"></a>Discrete Representation</h3><p>Encoder得到vector后，去codebook中寻找最相似的vector，再放入decoder中，最小化reconstruction loss，达到一个分类的效果</p>
<p><img src='VQVAE.png' width='500' title='VQVAE'></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX/LINUX大学指南</title>
    <url>/2020/09/26/UNIX-LINUX%E5%A4%A7%E5%AD%A6%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>《Harley Hanh’s Guide to UNIX&amp;LINUX》是一本给UNIX/LINUX初学者学习的读物，内容比较活泼有趣，这里记录一些有趣的知识点。</p>
<a id="more"></a>
<h2 id="什么是UNIX和LINUX"><a href="#什么是UNIX和LINUX" class="headerlink" title="什么是UNIX和LINUX"></a>什么是UNIX和LINUX</h2><p>UNIX是贝尔实验室的产品，版权在AT&amp;T手里，但是因为版权问题一直受到广大程序员的不满，不断尝试突破原本System的限制，BSD和Linux都可以说是这种开放精神的产物。</p>
<p>UNIX是一种多用户、多任务处理的操作系统。包括一个类UNIX内核，许多类UNIX实用工具和一个类UNIX shell组成。</p>
<p>Linux是任何使用Linux内核的Unix的名称。（遵循GNU的GPL协议）</p>
<p>从我理解的角度，目前的UNIX=BSD发行版+LINUX发行版+SystemV发行版（存疑）。</p>
<blockquote>
<p> 类UNIX这个术语很怪异也解释不清楚是什么东西，但是大家看到了都明白在说什么哈哈哈</p>
</blockquote>
<hr>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="登录与基本用户相关"><a href="#登录与基本用户相关" class="headerlink" title="登录与基本用户相关"></a>登录与基本用户相关</h3><ul>
<li>查看日期：date，cal,calendar</li>
<li>与登录状态相关：who，w，whoami，passwd，last</li>
<li>系统状态：hostname，uname，uptime</li>
<li>注销：logoout，exit，login（不一定完全注销），^D（强行注销）</li>
<li>echo $TERM 查看终端类型，stty显示或改变终端设置，tty查看终端内部名称<ul>
<li>tty是teletype终端输入（其实就是键盘）的缩写</li>
<li>print也是因为之前的终端输出是打印纸带而命名的</li>
</ul>
</li>
</ul>
<h3 id="Unix键盘信号"><a href="#Unix键盘信号" class="headerlink" title="Unix键盘信号"></a>Unix键盘信号</h3><blockquote>
<p>键盘映射系统可以适用于任何类型键盘，这种映射可以被改变，理解并改变是Unix CLI（Command Line Interface）的使用者必备技能。</p>
</blockquote>
<p>stty -a可以显示目前的映射（set terminal -all）</p>
<h4 id="键入过程中的信号"><a href="#键入过程中的信号" class="headerlink" title="键入过程中的信号"></a>键入过程中的信号</h4><ul>
<li>erase删除最后一个字符</li>
<li>werase删除最后一个键入的单词(maybe word-erase?)</li>
<li>kill删除整行</li>
</ul>
<p><em>Backspace</em> 或者 <em>Delete</em> <em>^H</em> 负责发送erase信号</p>
<p><em>^W</em>会触发werase信号</p>
<p><em>^X</em>或者<em>^U</em>触发清除整行的kill信号，在WSL中测试为<em>^U</em></p>
<blockquote>
<p>kill信号并不会停止程序，它只删除刚键入的一行，为了停止需要^C中断信号</p>
</blockquote>
<h4 id="Backspace从何处来"><a href="#Backspace从何处来" class="headerlink" title="Backspace从何处来"></a>Backspace从何处来</h4><p>以前的打印机终端的输入输出都是打印纸带孔，每一个孔代表2进制的一位0/1，如果输入错误了，不能像现在的屏幕直接删掉，而是要先回位（输入^H，回位Backspace，BS命令），然后<em>Rubout</em>（擦掉，发送DEL命令），使得穿孔机8位都打孔置1，使得该忽略该字符。（127无效？）</p>
<p>^H后来由Backspace按键代替，Rubout由Delete代替</p>
<p><em>后来混乱了，Backspace直接映射到了erase，乱七八糟的我也看不懂。现在PC上的delete和当时的delete也完全不是一个东西了，没有映射到erase。</em></p>
<p><strong>按下^/在我的WSL中是撤销操作</strong></p>
<h4 id="神秘字符-H"><a href="#神秘字符-H" class="headerlink" title="神秘字符^H"></a>神秘字符^H</h4><blockquote>
<p>如果发现自己狂按backspace没有出现删除效果，而是出来了好几个^H，代表在你的远程主机那里，^?被映射位erase信号，你发送的都是无效的指令。</p>
</blockquote>
<p>为了测试这个东西，我用了书上的stty erase ^H命令，将主机的映射改变了，结果发现WSL的终端上backspace映射的是^?，导致我现在按下backspace会出来一堆^?，着实可爱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adin@LAPTOP-VA1IGCFC:~$ stty erase ^H</span><br><span class="line">adin@LAPTOP-VA1IGCFC:~$ ^?^?^?^?^?^?</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我还是改回去了 stty erase ^?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adin@LAPTOP-VA1IGCFC:~$ stty erase ^?</span><br></pre></td></tr></table></figure>
<h4 id="停止与启动程序"><a href="#停止与启动程序" class="headerlink" title="停止与启动程序"></a>停止与启动程序</h4><ul>
<li>intr：</li>
</ul>
<p>一些程序为了防止误操作，把^C命令给禁止了，比如vi，所以在编辑的时候经常会出现奇奇怪怪的神秘映射后字符。</p>
<ul>
<li>quit：</li>
</ul>
<p>quit是当年用于调试用的老命令，停止程序加复制一份内存保留，以便后续分析当时的原因，文件命名为core（内存的老名字），称作<strong>磁芯文件</strong></p>
<p>命令是^\，但在WSL上测试发现什么都没有发生（可能是时机不对，在bash没有运行的时候单独按没反应）</p>
<ul>
<li>stop：</li>
</ul>
<p>^S发送stop信号用于终止屏幕的显示，在大篇幅疯狂滚动的时候会有用，当然更好的是less命令</p>
<ul>
<li>start</li>
</ul>
<p>^Q发送start命令，和之前的stop对应着，恢复屏幕的输出，如果屏幕</p>
<h4 id="终止信号eof"><a href="#终止信号eof" class="headerlink" title="终止信号eof"></a>终止信号eof</h4><p>这个比较熟悉了^D发送输入终止信号，end of file，同时也是注销shell的命令</p>
<p>可以使用环境变量{IGNOREEOF}来封闭eof信号，数字代表连续按下多少次才能注销</p>
<h4 id="返回与换行"><a href="#返回与换行" class="headerlink" title="返回与换行"></a>返回与换行</h4><p>也是为了适配以前打印机打印纸换行问题的信号，对应键盘上的^M（返回）和^J（换行），这两个都可以代替回车</p>
<h3 id="立即使用程序吧"><a href="#立即使用程序吧" class="headerlink" title="立即使用程序吧"></a>立即使用程序吧</h3><h4 id="查找which-type-whence"><a href="#查找which-type-whence" class="headerlink" title="查找which type whence"></a>查找which type whence</h4><p>which和type适用bash</p>
<p>whence适用korn shell</p>
<h4 id="一些辅助功能"><a href="#一些辅助功能" class="headerlink" title="一些辅助功能"></a>一些辅助功能</h4><ul>
<li>lock：锁定终端15min，或者自己指定时间，只能用当前user或者root的密码才能解锁</li>
<li>leave：提醒结束工作，设定离开时间，超过时间后每分钟催促你一次</li>
<li>bc：计算器bc -l启动库函数，scale小数，ibase/obase输入输出基</li>
</ul>
<h4 id="说明书和bang"><a href="#说明书和bang" class="headerlink" title="说明书和bang"></a>说明书和bang</h4><p><strong>RTFM：Read The Fucking Manual</strong></p>
<p>man开启说明书，/pattern搜索</p>
<p>！命令称作bang字符命令，可以暂停当前程序向shell发送一条命令，在读manual的时候可以去做别的事情</p>
<p>man其实是一个包含9个章节的手册，默认输入命令会打开它们在第一章节里的内容，如果需要看其他部分，可以在 man命令后面跟上数字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adin@LAPTOP-VA1IGCFC:~$ man 2 <span class="built_in">which</span></span><br><span class="line">No manual entry <span class="keyword">for</span> <span class="built_in">which</span> <span class="keyword">in</span> section 2</span><br><span class="line">See <span class="string">'man 7 undocumented'</span> <span class="keyword">for</span> <span class="built_in">help</span> when manual pages are not available.</span><br><span class="line">adin@LAPTOP-VA1IGCFC:~$ man 2 <span class="built_in">kill</span></span><br></pre></td></tr></table></figure>
<p>上述打开了kill在第二章节系统调用中的内容，which命令没出现在第二章节所以打不开</p>
<p><strong>破折号被叫做dash，ls -l发音 L-S-dash—L</strong></p>
<h2 id="命令特征"><a href="#命令特征" class="headerlink" title="命令特征"></a>命令特征</h2><p>shell分为两大类，Bourn Shell和C-Shell，Bash是Bourn Again Shell（Born-Again），属于前者族系，两者在语法上有所不同</p>
<p>命令 选项 参数</p>
<p>ls <strong>options</strong> <em>filename…</em></p>
<ol>
<li>方括号里面的是可选择的</li>
<li>不在方括号里的是必须写的</li>
<li>黑体字必须原样输入</li>
<li>斜体字使用适当内容替换</li>
<li>接省略号…代表可以重复任意多次</li>
<li>如果一个单独的选项和参数放在一起，则必须同时使用或者不用</li>
<li>竖线分开的多个项目代表选择</li>
</ol>
<ul>
<li>echo $SHELL 查看当前shell</li>
<li>less /etc/shells 查看系统上装的所有shell</li>
<li>每次执行shell脚本的时候，实际上是启动了一个新的shell</li>
</ul>
<h3 id="环境、进程和变量"><a href="#环境、进程和变量" class="headerlink" title="环境、进程和变量"></a>环境、进程和变量</h3><ul>
<li>环境：一组用来存放信息的变量</li>
<li>变量：一个用来存储数据的<strong>实体</strong>，不能数字打头，分为全局和局部变量，默认为局部shell变量，使用export可以导出到环境中,unset用于复位（清除）变量</li>
<li>进程：父子进程之间有全局变量的作用</li>
</ul>
<p>env和printenv命令可以显示环境变量，set显示shell变量与它们的值</p>
<p><strong>元字符</strong>：类似&lt;&gt;这种具有特殊含义的标点字符称为元字符，元字符在双引号中会解释为普通字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adin@LAPTOP-VA1IGCFC:~$ <span class="built_in">echo</span> I am <span class="variable">$USER</span></span><br><span class="line">I am adin</span><br><span class="line">adin@LAPTOP-VA1IGCFC:~$ <span class="built_in">echo</span> I am &lt;<span class="variable">$USER</span>&gt;</span><br><span class="line">-bash: syntax error near unexpected token `newline<span class="string">'</span></span><br><span class="line"><span class="string">adin@LAPTOP-VA1IGCFC:~$ echo "I am &lt;$USER&gt;"</span></span><br><span class="line"><span class="string">I am &lt;adin&gt;</span></span><br></pre></td></tr></table></figure>
<p>set -o | +o <em>switchname</em>这种可以改变shell本身的设置，比如ignoreeof，一般用户比较少修改，默认配置在bashrc文件中</p>
<hr>
<h2 id="使用shell：命令和定制"><a href="#使用shell：命令和定制" class="headerlink" title="使用shell：命令和定制"></a>使用shell：命令和定制</h2><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>各种各样的字母数字字符alphanumeric character，包括空格，制表符，回车等等。其中重要的一类称作通配符globbing，用于文件名的扩展。</p>
<p>在引号之内就“引用”了元字符，会取消转义。反斜杠\也是重要的转义字符，使用双引号的时候会保留 $ ‘ \这三个的特殊含义。而单引号会把所有元字符的意义覆盖，变成纯粹的文本。也因此，单引号称作<strong>强引用</strong>，双引号对应称作<strong>弱引用</strong>。</p>
<h3 id="shell提示"><a href="#shell提示" class="headerlink" title="shell提示"></a>shell提示</h3><p>修改环境变量PS1可以改变提示行的格式，编写该格式的时候可以使用<em>特殊码</em>，例如\u代表$USER，\h代表hostname</p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>fc -l可以展示历史命令，！num可以执行对应事件的编号</p>
<p>fc -s p=q可以让q命令以p命令的参数重新执行一遍</p>
<p>^R可以让用户输入一个模式，然后history去寻找与之匹配的格式</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>alias 可以起别名；<br>unalias取消别名</p>
<h2 id="使用shell：初始化文件"><a href="#使用shell：初始化文件" class="headerlink" title="使用shell：初始化文件"></a>使用shell：初始化文件</h2><p>两个特殊文件也就是初始化文件：</p>
<ul>
<li>登陆文件login file：每次登录时自动执行的命令 .profile</li>
<li>环境文件environment file：在新shell启动时自动执行的命令 .bashrc(bash run commands)</li>
<li><p>这个其实也算第三个特殊文件，登出文件logout file，可以在注销的时候执行一些命令 .profile_logout</p>
</li>
<li><p>交互式shell：输入命令行时，又分为登录shell和非登录shell</p>
</li>
<li>非交互式shell：执行shell脚本时</li>
</ul>
<p><strong>打开一个终端不需要登录，属于非登录shell，</strong>打开虚拟控制台则需要登录。打开<strong>ssh需要登录</strong>，在shell打开一个新sh不需要登录。</p>
<p>登录shell执行登录文件和环境文件，非登录shell只执行环境文件。但是bash默认模式只执行登陆文件，而不执行环境文件？？？？</p>
<h2 id="管线命令与标准IO"><a href="#管线命令与标准IO" class="headerlink" title="管线命令与标准IO"></a>管线命令与标准IO</h2><h3 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h3><ul>
<li>标准输入 0&lt; &lt;&lt;</li>
<li>标准输出 1&gt; &gt;&gt;</li>
<li>标准错误 2&gt; &gt;&gt;<br>控制 noclobber的选项开关，<em>可以控制是否对已有文件进行修改</em></li>
<li>‘&gt;| 强制重写’</li>
<li>2&amp;&gt;1 将标准错误定向到标准输出</li>
</ul>
<h3 id="管线命令"><a href="#管线命令" class="headerlink" title="管线命令"></a>管线命令</h3><p>tee是分流命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat names1 names2 names3 | tee d1 d2 <span class="comment"># 把管线输入赋给d1 d2两个文件</span></span><br><span class="line">who | tee -a d1 <span class="comment"># 追加模式</span></span><br></pre></td></tr></table></figure><br>以上所有命令都会在标准输出（屏幕）上额外显示一份</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><blockquote>
<p>过滤器就是能够从标准输入读取文本数据并向标准输出写入文本数据（每次一行）的程序。通常，大多数过滤器都被设计成工具，出色地完成一件事情。</p>
</blockquote>
<ul>
<li>cat就是把输入变成输出<ul>
<li>cat &gt; data 把键盘输入内容输出到data</li>
<li>cat &lt; data 显示文件内容</li>
<li>cat后面可以跟多个文件，依次读入并输出，起到catenate的作用</li>
<li><strong>Warning</strong>cat输入和输出文件如果一样，会将文件内容清空报错</li>
</ul>
</li>
<li>split划分文件，有点像cat逆操作<ul>
<li>默认创建1000行一个的文件</li>
<li>split -l n file，以n行每个创建切分文件，默认命名为xaa，xab等</li>
</ul>
</li>
<li>tac与cat的碰瓷，输出前将文本反转<ul>
<li>cat -n data | tac | tac两极反转就整回来啦</li>
</ul>
</li>
<li>rev又一个反转的命令，但是不想tac逐行反转，rev是逐字符反转</li>
<li>head/tail 平平无奇的显示头尾的命令</li>
<li>colrm col1 col2 &lt; file 删除指定行</li>
</ul>
<h3 id="比较和抽取"><a href="#比较和抽取" class="headerlink" title="比较和抽取"></a>比较和抽取</h3><ul>
<li>cmp file1 file2</li>
<li>comm file1 file2 需要排序文件</li>
<li>diff file1 file2 表示如何操作可以把文件1变成文件2<ul>
<li>文件1使用&lt; 文件2使用 &gt;</li>
<li>c改变,d删除,a添加</li>
<li>相当多的选项可以展示两个文件的区别</li>
</ul>
</li>
<li>sdiff,并排展示,把两个文件都列出来</li>
</ul>
<h4 id="差分和补丁"><a href="#差分和补丁" class="headerlink" title="差分和补丁"></a>差分和补丁</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff foo-2.0.c foo-2.1.c &gt; foo-diff-2.1</span><br></pre></td></tr></table></figure>
<p>输出文件包含一列指示,可以将2.0版本更新到2.1版本,这种方式叫做<strong>差分</strong><br>使用patch命令可以完成补丁的修补</p>
<p>实际中应用版本控制系统VCS, 不需要自己控制项目的差分补丁</p>
<ul>
<li><p>cut指令作用与colrm相反,它会将指定的列从文件中抽取并且删除掉其他内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cut -c 1-8, 5-16 info</span><br></pre></td></tr></table></figure>
<p>这种破折号表示范围也是左闭右开的</p>
</li>
<li><p>paste合并数据列,和cat合并的能力有点类似, 这个可以水平合并, cat是竖直方向合并</p>
</li>
</ul>
<h3 id="统计与格式化"><a href="#统计与格式化" class="headerlink" title="统计与格式化"></a>统计与格式化</h3><ul>
<li>nl提供在文本中插入行号,并输出</li>
<li>wc word count统计字符数量,输出顺序: 行—line 单词—word 字符—character,可以输入多份文件,多份文件会计算各个项目的总数</li>
<li>expand将制表符变成空格, vim中 :set list可以可视化展示tab和space</li>
<li>unexpand将空格变成制表符</li>
<li>fold可以折叠文本,保证每行字符数量不超过指定值</li>
<li>fmt格式化段落,让段落文字每句话之间的空格变得规范(例如法国式间距里每个句子后面空两个空格)</li>
<li>pr为了给要打印的东西编号,按页格式化文本/按列格式化文本,是为了当年程序员们打印纸带的时候排版用的</li>
</ul>
<h3 id="选取排序组合以及变换"><a href="#选取排序组合以及变换" class="headerlink" title="选取排序组合以及变换"></a>选取排序组合以及变换</h3><ul>
<li><p>grep最牛的过滤器<br>搜索包含特定pattern的行, 中间的re代表regular expression<br><strong>G</strong>lobal search the <strong>R</strong>egular <strong>E</strong>xpression and <strong>P</strong>rint the line</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep [-cilLnsvwx] pattern [file...]</span><br></pre></td></tr></table></figure>
<p><em>讨论若干个重要的命令参数</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -F| grep -c <span class="string">'/'</span> <span class="comment">#统计目录的个数</span></span><br><span class="line">grep -i pattern file <span class="comment">#忽略大小写区别</span></span><br><span class="line">grep -<span class="keyword">in</span> pattern file <span class="comment">#忽略大小写,注明结果所在行ignore</span></span><br><span class="line">grep -l pattern file1 file2 ... <span class="comment">#只显示包含模式的文件名称,适用于多个文件寻找</span></span><br><span class="line">grep -w pattern file <span class="comment">#必须完全匹配</span></span><br><span class="line">grep -v pattern file <span class="comment">#显示不包含模式的行!!!!</span></span><br><span class="line">grep -r pattern dir <span class="comment">#在整个目录里面查找</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>fgrep是快速grep(已废弃deprecated,现在grep也很快),egrep是扩展grep(使用扩展正则表达式)</p>
</li>
<li>look没有看懂,功能比grep简单很多,不能读取标准输入,但是快,适合优化的时候使用</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul>
<li>sort排序数据或者查看数据是否有序</li>
<li>sort -o names &gt; names 可以实现对于源文件的排序,不至于出现cat names &gt; names清空自己这种情况</li>
<li>sort通常就用做管线命令的一部分排个序</li>
<li>sort -c查看是否有序</li>
<li>sort -r反序</li>
<li>sort -u唯一unique</li>
<li><p>sort -n排序数字</p>
</li>
<li><p>uniq与重复行相关的操作</p>
</li>
<li><p>join会把两个<strong>已排序文件</strong>中键值相同的文本合并</p>
</li>
</ul>
]]></content>
      <categories>
        <category>UNIX/LINUX</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>UNIX/LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试器命令cheatsheet</title>
    <url>/2021/02/28/gdb%E8%B0%83%E8%AF%95%E5%99%A8%E5%91%BD%E4%BB%A4cheatsheet/</url>
    <content><![CDATA[<p>gdb使用命令调试</p>
<a id="more"></a>
<p>以~/Documents/vscTest/main.cpp为例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"b is "</span>&lt;&lt;b &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"b is "</span>&lt;&lt;b ;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"abchd"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"b is "</span>&lt;&lt;b &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"b is "</span>&lt;&lt;b ;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"abchd"</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用cmake生成的可执行文件放在build文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adinvm@ubuntu:~/Documents/vscTest/build$ gdb</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">"show copying"</span> and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">(gdb) file main</span><br><span class="line">Reading symbols from main...</span><br></pre></td></tr></table></figure>
<p>使用file [filename] 打开相应文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b 2</span><br><span class="line">Breakpoint 1 at 0x10e0: file /home/adinvm/Documents/vscTest/main.cpp, line 4.</span><br><span class="line">(gdb) b 7</span><br><span class="line">Breakpoint 2 at 0x1149: file /home/adinvm/Documents/vscTest/main.cpp, line 9.</span><br><span class="line">(gdb) b 9</span><br><span class="line">Note: breakpoint 2 also <span class="built_in">set</span> at pc 0x1149.</span><br><span class="line">Breakpoint 3 at 0x1149: file /home/adinvm/Documents/vscTest/main.cpp, line 9.</span><br></pre></td></tr></table></figure>
<p>使用b [number]  在某一行进行断点的设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/adinvm/Documents/vscTest/build/main </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /home/adinvm/Documents/vscTest/main.cpp:4</span><br><span class="line">4	 int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/adinvm/Documents/vscTest/build/main</span><br></pre></td></tr></table></figure>
<p>r命令为restart，启动或者重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, main () at /home/adinvm/Documents/vscTest/main.cpp:4</span><br><span class="line">4	 int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">b is 10</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at /home/adinvm/Documents/vscTest/main.cpp:9</span><br><span class="line">9	        cout&lt;&lt;<span class="string">"abchd"</span>;</span><br></pre></td></tr></table></figure>
<p>c命令为continue，断点单步执行，执行时才有效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) p a</span><br><span class="line"><span class="variable">$1</span> = 10</span><br><span class="line">(gdb) p b</span><br><span class="line"><span class="variable">$2</span> = 10</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">b is 10abchdb is 10</span><br><span class="line">b is 10abchd[Inferior 1 (process 31811) exited normally]</span><br><span class="line">(gdb) c</span><br><span class="line">The program is not being run.</span><br><span class="line">(gdb) c</span><br><span class="line">The program is not being run.</span><br></pre></td></tr></table></figure>
<p>info b展示出来所有的断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00005555555550e0 <span class="keyword">in</span> main() </span><br><span class="line">                                                   at /home/adinvm/Documents/vscTest/main.cpp:4</span><br><span class="line">	breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x0000555555555149 <span class="keyword">in</span> main() </span><br><span class="line">                                                   at /home/adinvm/Documents/vscTest/main.cpp:9</span><br><span class="line">3       breakpoint     keep y   0x0000555555555149 <span class="keyword">in</span> main() </span><br><span class="line">                                                   at /home/adinvm/Documents/vscTest/main.cpp:9</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cheatsheet</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>python&amp;numpy的草稿本</title>
    <url>/2020/09/11/python-numpy%E7%9A%84%E8%8D%89%E7%A8%BF%E6%9C%AC/</url>
    <content><![CDATA[<p>关于python和numpy一些零碎的知识点</p>
<a id="more"></a>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h3 id="列表的深复制和浅复制"><a href="#列表的深复制和浅复制" class="headerlink" title="列表的深复制和浅复制"></a>列表的深复制和浅复制</h3><p>现在有<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">&gt;&gt;&gt;B = A</span><br><span class="line">&gt;&gt;&gt;B</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">&gt;&gt;&gt;A.append(<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;B</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>]</span><br><span class="line">&gt;&gt;&gt;C = A.copy()</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> copy</span><br><span class="line">&gt;&gt;&gt;D = copy.deepcopy(A)</span><br><span class="line">&gt;&gt;&gt;A.append(<span class="number">7</span>)</span><br><span class="line">&gt;&gt;&gt;A[<span class="number">3</span>].append(<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;A</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;C</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">6</span>]</span><br><span class="line">&gt;&gt;&gt;D</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>B只是A的一个别称，也就是对象的引用</li>
<li>C是A的浅复制，A和C对象本身是独立的，但是它们其中包含的子对象指向的还是同一个</li>
<li>D是A的深复制，完全分离，对于A的修改完全不影响D，深复制在这里使用了copy模块中的deepcopy()函数</li>
</ul>
<h3 id="python2-7的继承"><a href="#python2-7的继承" class="headerlink" title="python2.7的继承"></a>python2.7的继承</h3><p>有关类的继承的写法，与python3有所区别，在子类init中super需要写两个参数，子类名称和self，python3不需要写这两个参数，直接super()即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init___</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Father)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        super(Child,self).__init__(name)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<h3 id="sort和sorted的区别"><a href="#sort和sorted的区别" class="headerlink" title="sort和sorted的区别"></a>sort和sorted的区别</h3><p>这是两个内置的排序函数，区别在于sort直接改变原有的列表，sorted不改变原有的列表</p>
<h3 id="json在python中的用法"><a href="#json在python中的用法" class="headerlink" title="json在python中的用法"></a>json在python中的用法</h3><p>json模块使用前需要import</p>
<p>主要的函数是json.dump（var，fd） 和 json.load（fd）</p>
<h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h3 id="argsort使用关键字的排序"><a href="#argsort使用关键字的排序" class="headerlink" title="argsort使用关键字的排序"></a>argsort使用关键字的排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">numpy.argsort(a, axis=<span class="number">-1</span>, kind=<span class="string">'quicksort'</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>argsort返回的是一个元素排列顺序的array，排列顺序为从大到小，可以选择的参数包括排序依据的轴，排序用的算法有mergesort, heapsort, quicksort</p>
<p><em>最后一个参数没有完全理解，doc中原文如下，大概是说自定义域的类型排序顺序</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">order : str <span class="keyword">or</span> <span class="built_in">list</span> of str, optional</span><br><span class="line"></span><br><span class="line">When a is an <span class="built_in">array</span> with fields defined, <span class="keyword">this</span> argument specifies which fields to compare first, second, etc. A single field can be specified as a <span class="built_in">string</span>, <span class="keyword">and</span> <span class="keyword">not</span> all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to <span class="keyword">break</span> ties.</span><br></pre></td></tr></table></figure>
<p><strong>基本用法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one-dimensional</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">two-dimensional</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([[<span class="number">0</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x, axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<p><strong>使用关键字排序的用法</strong></p>
<p>在定义array时添加dtype类型，并在排序中设置order的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)], dtype=[(<span class="string">'x'</span>, <span class="string">'&lt;i4'</span>), (<span class="string">'y'</span>, <span class="string">'&lt;i4'</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)],</span><br><span class="line">      dtype=[(<span class="string">'x'</span>, <span class="string">'&lt;i4'</span>), (<span class="string">'y'</span>, <span class="string">'&lt;i4'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x, order=(<span class="string">'x'</span>,<span class="string">'y'</span>))</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x, order=(<span class="string">'y'</span>,<span class="string">'x'</span>))</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch笔记本</title>
    <url>/2020/12/19/pytorch%E7%AC%94%E8%AE%B0%E6%9C%AC/</url>
    <content><![CDATA[<p>记录一下pytorch中需要复习的一些零碎知识点</p>
<a id="more"></a>
<h2 id="从Tensor开始"><a href="#从Tensor开始" class="headerlink" title="从Tensor开始"></a>从Tensor开始</h2><h3 id="Tensor的存储结构"><a href="#Tensor的存储结构" class="headerlink" title="Tensor的存储结构"></a>Tensor的存储结构</h3><p>python原本的存储是不连续，例如list中的每一个元素并不像c++中的数组是连续存放在内存中。而numpy与pytorch会将array以及tensor放置在连续内存单元里面，通过修改索引来构造各种维度</p>
<p>如图所示，与Tensor存储相关的有三个量，尺寸size、存储偏移offset以及步长stride（每一个维度的长度）。这种表示方式比较灵活，在进行reshape操作的时候只需要修改offset和stride即可，而不需要重新构造新的张量。<br><img src='storage.png' width='600' title='Tensor storage'></p>
<p>需要注意，直接使用等号将某一个张量A赋值给新的张量B，两者仍将指向同一段内存地址，修改B会反过来影响A。</p>
<p><strong>元素的存储是逐行保留的</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">points = torch.tensor([[<span class="number">1.0</span>, <span class="number">4.0</span>], [<span class="number">2.0</span>, <span class="number">1.0</span>], [<span class="number">3.0</span>, <span class="number">5.0</span>]])</span><br><span class="line">second_point = points[<span class="number">1</span>]</span><br><span class="line">second_point[<span class="number">0</span>] = <span class="number">10.0</span></span><br><span class="line">points</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">tensor([[ <span class="number">1.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">10.</span>,  <span class="number">1.</span>],</span><br><span class="line">        [ <span class="number">3.</span>,  <span class="number">5.</span>]])</span><br></pre></td></tr></table></figure>
<p>如果想避免这种情况，去创建一个新的Tensor独占空间，需要使用clone()函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">points = torch.tensor([[<span class="number">1.0</span>, <span class="number">4.0</span>], [<span class="number">2.0</span>, <span class="number">1.0</span>], [<span class="number">3.0</span>, <span class="number">5.0</span>]])</span><br><span class="line">**second_point = points[<span class="number">1</span>].clone()**</span><br><span class="line">second_point[<span class="number">0</span>] = <span class="number">10.0</span></span><br><span class="line">points</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">5.</span>]])</span><br></pre></td></tr></table></figure>
<p>转置前后可以使用id()函数验证两者的内存空间一致, <strong>但是转置之后的Tensor数据存放不再连续。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">id(points.storage()) == id(points_t.storage())</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">points.contiguous(), points_t.contiguous()</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Tensor数据类型"><a href="#Tensor数据类型" class="headerlink" title="Tensor数据类型"></a>Tensor数据类型</h3><ul>
<li>torch.float32或torch.float —— 32位浮点数</li>
<li>torch.float64或torch.double —— 64位双精度浮点数</li>
<li>torch.float16或torch.half —— 16位半精度浮点数</li>
<li>torch.int8 —— 带符号8位整数</li>
<li>torch.uint8 —— 无符号8位整数</li>
<li>torch.int16或torch.short —— 带符号16位整数</li>
<li>torch.int32或torch.int —— 带符号32位整数</li>
<li>torch.int64或torch.long —— 带符号64位整数</li>
</ul>
<p>使用dtype参数构造新Tensor<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">double_points = torch.ones(<span class="number">10</span>, <span class="number">2</span>, dtype=torch.double)</span><br><span class="line">short_points = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=torch.short)</span><br></pre></td></tr></table></figure><br>Tensor元素的类型可以在创建时使用to()或者某种type的函数进行生成<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">double_points = torch.zeros(<span class="number">10</span>, <span class="number">2</span>).double()</span><br><span class="line">short_points = torch.ones(<span class="number">10</span>, <span class="number">2</span>).short()</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">double_points = torch.zeros(<span class="number">10</span>, <span class="number">2</span>).to(torch.double)</span><br><span class="line">short_points = torch.ones(<span class="number">10</span>, <span class="number">2</span>).to(dtype=torch.short)</span><br></pre></td></tr></table></figure><br>任何时刻都可以使用type()，转换Tensor类型，注意type()是返回tensor而不是直接在调用对象上进行改变，因此想改变某个tensor的类型，需要进行赋值操作，即<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = a.type(torch.float)</span><br><span class="line">a = a.to(torch.int8)</span><br></pre></td></tr></table></figure></p>
<h3 id="与Numpy互通"><a href="#与Numpy互通" class="headerlink" title="与Numpy互通"></a>与Numpy互通</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tensor --&gt; numpy</span><br><span class="line">points = torch.ones(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">points_np = points.numpy()</span><br><span class="line"></span><br><span class="line">numpy --&gt; Tensor</span><br><span class="line">points = torch.from_numpy(points_np)</span><br></pre></td></tr></table></figure>
<p>当Tensor的设备为cpu的时候，numpy数组和tensor直接共用数据缓冲区，修改任何一个都会影响另一个，而当Tensor的设备为GPU的时候，numpy数组会从显存被拷贝至内存区中</p>
<h3 id="保存与读取Tensor"><a href="#保存与读取Tensor" class="headerlink" title="保存与读取Tensor"></a>保存与读取Tensor</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">torch.save(points, <span class="string">'../../data/chapter2/ourpoints.t'</span>)</span><br><span class="line">points = torch.load(<span class="string">'../../data/chapter2/ourpoints.t'</span>)</span><br><span class="line"></span><br><span class="line">保存后的格式是文本文件</span><br><span class="line"><span class="number">504</span>b <span class="number">0304</span> <span class="number">0000</span> <span class="number">0808</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span> <span class="number">1200</span> <span class="number">6172</span></span><br><span class="line"><span class="number">6368</span> <span class="number">6976</span> <span class="number">652</span>f <span class="number">6461</span> <span class="number">7461</span> <span class="number">2e70</span> <span class="number">6</span>b6c <span class="number">4642</span></span><br><span class="line"><span class="number">0e00</span> <span class="number">5</span>a5a <span class="number">5</span>a5a <span class="number">5</span>a5a <span class="number">5</span>a5a <span class="number">5</span>a5a <span class="number">5</span>a5a <span class="number">5</span>a5a</span><br><span class="line"><span class="number">8002</span> <span class="number">6374</span> <span class="number">6</span>f72 <span class="number">6368</span> <span class="number">2e5</span>f <span class="number">7574</span> <span class="number">696</span>c <span class="number">730</span>a</span><br><span class="line"><span class="number">5</span>f72 <span class="number">6562</span> <span class="number">7569</span> <span class="number">6</span>c64 <span class="number">5</span>f74 <span class="number">656</span>e <span class="number">736</span>f <span class="number">725</span>f</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="让Tensor运行在GPU上"><a href="#让Tensor运行在GPU上" class="headerlink" title="让Tensor运行在GPU上"></a>让Tensor运行在GPU上</h3><p><strong>device概念</strong>：是Tensor的属性之一，指在设置计算机上放张量（tensor）数据的位置</p>
<p>可以在创建tensor的时候就指定设备<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">points_gpu = torch.tensor([[<span class="number">1.0</span>, <span class="number">4.0</span>], [<span class="number">2.0</span>, <span class="number">1.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]], device=<span class="string">'cuda'</span>)</span><br></pre></td></tr></table></figure><br>也可以使用to()方法把tensor从CPU的内存拷贝到GPU的显存<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">points_gpu = points.to(device=<span class="string">'cuda'</span>)</span><br></pre></td></tr></table></figure><br>放置到显存后，变量的类型也会发生一些改变，变成了有cuda关键词的类型’torch.cuda.FloatTensor’</p>
<h3 id="张量的API"><a href="#张量的API" class="headerlink" title="张量的API"></a>张量的API</h3><p>一般来说torch.method(tensor,para)和tensor.method(para)是没什么区别的，但是部分方法只有tensor才具备，这部分方法的后缀是下划线，代表原地<strong>inplace操作</strong></p>
<p><strong>view()和reshape()的区别</strong>：</p>
<ul>
<li>view()只能作用于连续存储的Tensor上，对一些存储不连续的张量例如转置后的，view()无法执行</li>
<li>reshape()可以作用于连续或非连续的Tensor上，对连续存储的与view()完全一致，非连续存储的相当于contiguous()+view()，得到的是原存储空间的拷贝，也就是说修改拷贝不会影响原张量</li>
</ul>
<h2 id="使用张量表示真实数据"><a href="#使用张量表示真实数据" class="headerlink" title="使用张量表示真实数据"></a>使用张量表示真实数据</h2><h3 id="表格数据"><a href="#表格数据" class="headerlink" title="表格数据"></a>表格数据</h3><p>表格数据的读取，通常有三种方式</p>
<ol>
<li>python自带的csv模块</li>
<li>numpy</li>
<li>pandas</li>
</ol>
<p>对于结构化的数据而言，pandas最好，但是考虑到numpy与pytorch天生的内源性适配，这里更推荐使用numpy进行读取<br>以红酒品质的数据作为练习来源<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">wine_path = <span class="string">'./winequality-white.csv'</span></span><br><span class="line">wine_numpy = np.loadtxt(wine_path, delimiter=<span class="string">';'</span>,dtype=np.float32,skiprows=<span class="number">1</span>)</span><br><span class="line">print(wine_numpy.shape)</span><br><span class="line">col_list = next(csv.reader(open(wine_path),delimiter=<span class="string">';'</span>))</span><br><span class="line">print(col_list)</span><br><span class="line">data = torch.from_numpy(wine_numpy[:,:<span class="number">-1</span>])</span><br><span class="line">target = torch.from_numpy(wine_numpy[:,<span class="number">-1</span>]).long()</span><br><span class="line">print(data.shape,target.shape)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">(<span class="number">4898</span>, <span class="number">12</span>)</span><br><span class="line">[<span class="string">'fixed acidity'</span>, <span class="string">'volatile acidity'</span>, <span class="string">'citric acid'</span>, <span class="string">'residual sugar'</span>, <span class="string">'chlorides'</span>, <span class="string">'free sulfur dioxide'</span>, <span class="string">'total sulfur dioxide'</span>, <span class="string">'density'</span>, <span class="string">'pH'</span>, <span class="string">'sulphates'</span>, <span class="string">'alcohol'</span>, <span class="string">'quality'</span>]</span><br><span class="line">(<span class="number">4898</span>, <span class="number">11</span>) (<span class="number">4898</span>,)</span><br><span class="line"></span><br><span class="line">对target可以进行onehot编码，使用torch的scatter_原地方法，前提是target的dtype为int64（long）</span><br><span class="line">target_onehot = torch.zeros(target.shape[<span class="number">0</span>],<span class="number">10</span>)</span><br><span class="line">target_onehot.scatter_(<span class="number">1</span>,target.unsqueeze(<span class="number">1</span>),<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="时间序列数据"><a href="#时间序列数据" class="headerlink" title="时间序列数据"></a>时间序列数据</h3><p>与表格数据类似，只是需要使用view()对维度进行转换，可能会将不同的通道作为天数，每一行作为每小时或者每分钟数据，使得其成为具有时间序列的多维数据</p>
<h3 id="文本数据"><a href="#文本数据" class="headerlink" title="文本数据"></a>文本数据</h3><p>应用与NLP问题中。对字符串进行编码，可以从词的级别进行编码，one-hot方式面对巨大数量的词的时候是很崩溃的，类别过于大了。</p>
<p>使用<strong>文本嵌入embedding</strong>的方式可以解决这个问题，基本思路是通过张量中元素的组合来表示语义，类似于“红色+甜+球形=苹果”这种企业级理解方式，属于一种比较特殊的编码方式吧，对于人工编码来说也需要很大的工作量。</p>
<p>应该还有更有效率的编码方式，这里没有详谈。</p>
<h3 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h3><p>使用imageio模块加载图像<br>默认读入的numpy array维度是（width <em> height </em> channel），而torch一般处理时愿意将其变为（channel <em> height </em> width）因此需要进行一个转置transpose()</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line">img_arr = imageio.imread(<span class="string">'./img.jpg'</span>)</span><br><span class="line">img = torch.from_numpy(img_arr)</span><br><span class="line">out = torch.transpose(img, <span class="number">0</span>, <span class="number">2</span>).clone()</span><br></pre></td></tr></table></figure>
<p>注意：不加clone的话转置计算代价比较小，但是会让img和out共享内存，这个取舍由coder自己把握</p>
<p>上述的是一张图片的读取，对于图像数据集来说，一般会有一沓图片等着你读取，这时候使用batch堆叠的方法，将多张图片放到一起比较好。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">batch = torch.zeros(<span class="number">100</span>,<span class="number">3</span>,<span class="number">576</span>,<span class="number">576</span>,dtype=torch.int8)</span><br><span class="line">data_dir = <span class="string">'../../data/chapter3/image-cats/'</span></span><br><span class="line">filenames = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(data_dir) <span class="keyword">if</span> os.path.splitext(name) == <span class="string">'.png'</span>]</span><br><span class="line"><span class="keyword">for</span> i, filename <span class="keyword">in</span> enumerate(filenames):</span><br><span class="line">  img_arr = imageio.imread(filename)</span><br><span class="line">  batch[i] = torch.transpose(torch.from_numpy(img_arr), <span class="number">0</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="体积volume数据"><a href="#体积volume数据" class="headerlink" title="体积volume数据"></a>体积volume数据</h3><p>在通道（channel）维之后，你有一个额外的维——深度（depth），形成5D张量为N x C x D x H x W<br>使用imageio模块中的volread函数加载一个CT扫描样本，该函数以文件夹作为参数，将所有DICOM（Digital Imaging Communication and Storage，数字图像通信和存储）系列文件组合成一个NumPy 3D数组中<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line">dir_path = <span class="string">"../../data/chapter3/volumetric-dicom/2-LUNG 3.0  B70f-04083"</span> </span><br><span class="line">vol_arr = imageio.volread(dir_path, <span class="string">'DICOM'</span>) </span><br><span class="line">vol_arr.shape</span><br></pre></td></tr></table></figure></p>
<h2 id="学习机制"><a href="#学习机制" class="headerlink" title="学习机制"></a>学习机制</h2><blockquote>
<p>开普勒在没有计算机、微型计算器甚至微积分（那时这些都还没被发明出来的）的情况下估算了椭圆的偏心率和尺寸，提出了开普勒三定律。<br>这是早期通过输入输出参数来拟合模型的重要例子，某种程度上来说，机器从数据集中构建模型的思路完全可以参照多普勒当年的想法和流程。<br>本质上，开普勒必须使用一定数量的观测值来计算出曲线以尝试不同形状，然后使用计算出的曲线估计出更多位置，这是他拥有观测值的时间。然后检查这些计算出的位置是否与观测到的位置一致。</p>
</blockquote>
<ol>
<li>从他的朋友Brahe那里得到了很多好的数据（费了一些周折）。</li>
<li>试图将这些数据可视化，因为他觉得有的（数据）有些可疑。</li>
<li>选择有可能拟合数据的最简单的模型（椭圆）。</li>
<li>划分数据，以便处理部分数据并保留独立的数据集用来验证。</li>
<li>从试探性的偏心率和大小开始，然后进行迭代直到模型拟合观察结果为止。</li>
<li>根据独立的数据集验证他的模型。</li>
<li>难以置信地回顾。</li>
</ol>
<p><strong>科学的历史是建立在这七个步骤之上的</strong></p>
<h3 id="让autograd帮你计算梯度"><a href="#让autograd帮你计算梯度" class="headerlink" title="让autograd帮你计算梯度"></a>让autograd帮你计算梯度</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(t_u, w, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> w * t_u + b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_fn</span><span class="params">(t_p, t_c)</span>:</span></span><br><span class="line">    squared_diffs = (t_p - t_c)**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> squared_diffs.mean()</span><br><span class="line"></span><br><span class="line">params = torch.tensor([<span class="number">1.0</span>, <span class="number">0.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">loss = loss_fn(model(t_u, *params), t_c)</span><br><span class="line">loss.backward()</span><br></pre></td></tr></table></figure>
<p><img src='autograd.png' width='600' title='autograd'></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> params.grad <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    params.grad.zero_()</span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong>: grad会在每一个tensor处<strong>累积</strong>而非储存，也意味着每次计算完成需要将grad清零</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">training_loop</span><span class="params">(n_epochs, learning_rate, params, t_u, t_c)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, n_epochs + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> params.grad <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            params.grad.zero_() <span class="comment"># 这可以在调用backward之前在循环中的任何时候完成</span></span><br><span class="line">        t_p = model(t_u, *params)</span><br><span class="line">        loss = loss_fn(t_p, t_c)</span><br><span class="line">        loss.backward()</span><br><span class="line">        params = (params - learning_rate * params.grad).detach().requires_grad_()</span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch %d, Loss %f'</span> % (epoch, float(loss)))</span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure>
<p><em>detach()</em> 非常关键，不然每一次更新参数都会导致一直追踪到最原始的params</p>
<blockquote>
<p>我们重构params参数更新行：p1 = (p0 <em> lr </em> p0.grad)。这里p0是用于初始化模型的随机权重，p0.grad是通过损失函数根据p0和训练数据计算出来的。</p>
<p>到目前为止，一切都很好。现在，你需要进行第二次迭代：p2 = (p1 <em> lr </em> p1.grad)。如你所见，p1的计算图会追踪到p0，这是有问题的，因为(a)你需要将p0保留在内存中（直到训练完成），并且(b)在反向传播时不知道应该如何分配误差。</p>
<p>相反，应该通过调用.detatch()将新的params张量从与其更新表达式关联的计算图中分离出来。这样，params就会丢失关于生成它的相关运算的记忆。然后，你可以调用.requires<em>grad</em>()，这是一个就地（in place）操作（注意下标“_”），以重新启用张量的自动求导。现在，你可以释放旧版本params所占用的内存，并且只需通过当前权重进行反向传播。</p>
</blockquote>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p><img src='optim.png' width='600' title='optimizer'><br>在每个optim初始化的时候，输入optim关注的tensor<br>每个优化器的输入都是params或者说具有grad的张量，优化器含有zero_grad()和step()两个基本的方法<br>当输入的params有梯度属性后，调用optim.step()即可完成参数的更新<br>千万记住要在backward()之前调用optim.zero_grad(),将所有传递给优化器的Tensor的梯度清零<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">params = torch.tensor([<span class="number">1.0</span>, <span class="number">0.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line">optimizer = optim.SGD([params], lr=learning_rate)</span><br><span class="line">t_p = model(t_un, *params)</span><br><span class="line">loss = loss_fn(t_p, t_c)</span><br><span class="line">optimizer.zero_grad() <span class="comment"># 此调用可以在循环中更早的位置</span></span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure></p>
<p><strong>torch.randperm(int max)</strong>可以生成随机的index，范围为(0, max-1)</p>
<h3 id="不需要时关闭autograd"><a href="#不需要时关闭autograd" class="headerlink" title="不需要时关闭autograd"></a>不需要时关闭autograd</h3><blockquote>
<p>还有一个点需要讨论：因为你永远不会对val_loss调用backward，所以为什么要构建图形？实际上，此时你完全可以将model和loss_fn当作普通函数而无需追踪计算历史。无论经过怎样的优化，追踪计算历史都会带来额外的代价，所以你应该在验证过程中避免这些代价，尤其是当模型具有数百万个参数时</p>
</blockquote>
<p><img src='graph.png' width='600' title='train/valid map'></p>
<p>只使用train_loss更新params的梯度，不能使用valid_loss更新，否则就是在params中存储了这两者的梯度和，相当于把valid验证集也拿来做训练了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">training_loop</span><span class="params">(n_epochs, optimizer, params, </span></span></span><br><span class="line"><span class="function"><span class="params">                  train_t_u, val_t_u, train_t_c, val_t_c)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, n_epochs + <span class="number">1</span>):</span><br><span class="line">        train_t_p = model(train_t_u, *params)</span><br><span class="line">        train_loss = loss_fn(train_t_p, train_t_c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():<span class="comment"># 上下文管理，这部分运算不开启梯度，减少计算负荷</span></span><br><span class="line">            val_t_p = model(val_t_u, *params)</span><br><span class="line">            val_loss = loss_fn(val_t_p, val_t_c)</span><br><span class="line">            <span class="keyword">assert</span> val_loss.requires_grad == <span class="literal">False</span> <span class="comment"># 检查是否关闭了val_loss张量的grad</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        train_loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>
<h2 id="构建网络模型"><a href="#构建网络模型" class="headerlink" title="构建网络模型"></a>构建网络模型</h2><h3 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h3><blockquote>
<p>PyTorch有一个专门用于神经网络的完整子模块：torch.nn。该子模块包含创建各种神经网络体系结构所需的构建块。这些构建块在PyTorch术语中称为module（模块），在其他框架中称为layer（层）。</p>
<p>PyTorch模块都是从基类nn.Module继承而来的Python类。模块可以具有一个或多个参数（Parameter）实例作为属性，这些参数就是在训练过程中需要优化的张量（在之前的线性模型中即w和b）。模块还可以具有一个或多个子模块（nn.Module的子类）属性，并且也可以追踪其参数。</p>
</blockquote>
<p>nn.module中含有forward()函数，是实现前向计算的函数，但是pytorch官方不建议直接调用forward函数，因为在model(x)这种操作中，不仅有forward(x)，还有一系列重要的操作，例如我不明白的hook()函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = model(x) <span class="comment"># right</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = model.forward(x) <span class="comment"># 不要这样做!!!</span></span><br><span class="line"></span><br><span class="line">以下代码显示了Module.call的实现（为清楚起见进行了一些简化）:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *input, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> hook <span class="keyword">in</span> self._forward_pre_hooks.values():</span><br><span class="line">        hook(self, input)</span><br><span class="line">    result = self.forward(*input, **kwargs)</span><br><span class="line">    <span class="keyword">for</span> hook <span class="keyword">in</span> self._forward_hooks.values():</span><br><span class="line">        hook_result = hook(self, input, result)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> hook <span class="keyword">in</span> self._backward_hooks.values():</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>如上所示，如果直接使用.forward（…），很多hook将无法正确调用。<br>nn.Module的子类都默认输入张量的第一维度为Batchsize<br>nn提供了一种通过nn.Sequential容器串联模块的简单方法：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">seq_model = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">1</span>, <span class="number">13</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">            nn.Linear(<span class="number">13</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先创建一个空的sequential 再去add module</span></span><br><span class="line">seq_model.add_module(<span class="string">'name'</span>,nn.Linear(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h3 id="nn的子类"><a href="#nn的子类" class="headerlink" title="nn的子类"></a>nn的子类</h3><p>nn.Sequential在处理更大的网络时有点不够灵活（例如无法控制网络流向），使用nn.Module的子类更为合理<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubclassModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden_linear = nn.Linear(<span class="number">1</span>, <span class="number">13</span>)</span><br><span class="line">        self.hidden_activation = nn.Tanh()</span><br><span class="line">        self.output_linear = nn.Linear(<span class="number">13</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        hidden_t = self.hidden_linear(input)</span><br><span class="line">        activated_t = self.hidden_activation(hidden_t)</span><br><span class="line">        output_t = self.output_linear(activated_t)</span><br><span class="line">        <span class="keyword">return</span> output_t</span><br><span class="line"></span><br><span class="line">subclass_model = SubclassModel()</span><br></pre></td></tr></table></figure><br>当子模块作为self.attri属性加入子类后，会自动登记为子模块，类会自动访问子模块的参数</p>
<blockquote>
<p>回顾SubclassModel类的实现，并考虑在构造函数中登记子模块以便访问其参数的实用功能，似乎同时登记没有参数的子模块（如nn.Tanh）有点浪费，直接在forward函数中调用它们难道不是更容易吗？当然可以。</p>
<p>PyTorch的每个nn模块都有相应的函数。“函数”一词是指“没有内部状态”或“其输出值完全由输入的参数决定”。实际上，torch.nn.functional提供了许多与nn模块对应的函数，只是所有模型参数（parameter）都作为了参数（argument）移到了函数调用中。例如，与nn.Linear对应的是nn.functional.linear，它是一个具有参数(input, weight, bias=None)的函数，即模型的权重和偏差是该函数的参数。</p>
</blockquote>
<p>可以不添加module，直接在forward中直接调用函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubclassFunctionalModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden_linear = nn.Linear(<span class="number">1</span>, <span class="number">14</span>)</span><br><span class="line">        <span class="comment"># 去掉了nn.Tanh()</span></span><br><span class="line">        self.output_linear = nn.Linear(<span class="number">14</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        hidden_t = self.hidden_linear(input)</span><br><span class="line">        activated_t = torch.tanh(hidden_t) <span class="comment"># nn.Tanh对应的函数</span></span><br><span class="line">        output_t = self.output_linear(activated_t)</span><br><span class="line">        <span class="keyword">return</span> output_t</span><br><span class="line"></span><br><span class="line">func_model = SubclassFunctionalModel()</span><br><span class="line">func_model</span><br></pre></td></tr></table></figure>
<p><strong>WARNING</strong>:尽管1.0版的torch.nn.function中仍存在诸如tanh之类的通用科学函数，但不建议使用这些API，而应使用顶级torch命名空间中的API，例如torch.tanh。更多其他函数保留在torch.nn.functional中。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>交通数据分析-爬虫</title>
    <url>/2020/10/10/%E4%BA%A4%E9%80%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<p>《交通数据分析》课程中关于爬虫部分的内容，简单记录。</p>
<a id="more"></a>
<h2 id="HTTP与Web"><a href="#HTTP与Web" class="headerlink" title="HTTP与Web"></a>HTTP与Web</h2><p>HTTP是client与server之间的通讯协议，从server获取资源。</p>
<p>client发送URL（统一资源定位符）</p>
<ul>
<li>URL: Uniform Resource Locator</li>
<li>URI: Uniform Resource Identifier</li>
<li>URI可以是ftp，http，tel<ul>
<li>URL是URI的子集</li>
</ul>
</li>
</ul>
<p><strong>URI绝对格式</strong><br>协议名称：登录信息@服务器地址:端口号（门）/带层次的文件路径？查询字符串#片段标识符（网页中相应片段）</p>
<h2 id="网页数据采集"><a href="#网页数据采集" class="headerlink" title="网页数据采集"></a>网页数据采集</h2><p>流程：</p>
<ol>
<li>发现<strong>网址规律</strong>，构建URL</li>
<li>构建headers，cookies参数</li>
<li>对目标网址发送请求（<em>伪装为浏览器访问</em>）</li>
<li>解析返回的响应数据</li>
<li>保存数据，重复3-5步骤</li>
</ol>
<p><a href="https://shanghai.8684.cn/" target="_blank" rel="noopener">https://shanghai.8684.cn/</a> 交通数据网站</p>
<h3 id="网站爬取"><a href="#网站爬取" class="headerlink" title="网站爬取"></a>网站爬取</h3><p>使用request包对内容爬取</p>
<p>响应码：200成功，4XX客户端错误，5XX服务器错误</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'https://shanghai.8684.cn/'</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    print(r.status_code)</span><br></pre></td></tr></table></figure>
<p><strong>注意项目：</strong></p>
<ul>
<li>Encoding：utf-8</li>
<li>HTML Response</li>
<li>r.text是相应内容</li>
</ul>
<p><strong>为了伪装成浏览器，加上headers，params等</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'https://shanghai.8684.cn/so.php'</span></span><br><span class="line">    parameters = &#123;<span class="string">'q'</span>:<span class="string">'同济大学'</span>,<span class="string">'q1'</span>:<span class="string">'东方明珠'</span>,<span class="string">'k'</span>:<span class="string">'p2p'</span>&#125;</span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>:...&#125; <span class="comment"># 根据浏览器类型来</span></span><br><span class="line">    r = requests.get(url,headers=headers,params=parameters)</span><br><span class="line">    print(r.status_code)</span><br></pre></td></tr></table></figure>
<h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><p>返回了一大堆数据，要进行数据的解析，分为HTML和JSON解析</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">res = soup.findAll(<span class="string">'span'</span>,&#123;<span class="string">'class'</span>:<span class="string">'author'</span>&#125;) <span class="comment">#查找条件，得到一个列表</span></span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">output: [<span class="string">'&lt;span class='</span>autho<span class="string">r'&gt;我叫作者&lt;/span&gt;'</span>]</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">res = soup.findAll(<span class="string">'span'</span>,&#123;<span class="string">'class'</span>:<span class="string">'author'</span>&#125;).findChildern(text=<span class="literal">True</span>) <span class="comment">#查找条件，得到一个列表</span></span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">output: [<span class="string">'我叫作者'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="数据解析re"><a href="#数据解析re" class="headerlink" title="数据解析re"></a>数据解析re</h4><p>正则表达式解析</p>
<p>用re.compile去写一个正则表达式pattern</p>
<p>pattern = re.compile(string)</p>
<ul>
<li>re.findall(pattern, string) # 返回列表</li>
<li>re.match(pattern,string)</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'https://shanghai.8684.cn/so.php'</span></span><br><span class="line">    parameters = &#123;<span class="string">'q'</span>:<span class="string">'同济大学'</span>,<span class="string">'q1'</span>:<span class="string">'东方明珠'</span>,<span class="string">'k'</span>:<span class="string">'p2p'</span>&#125;</span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Chrome/85.0.4183.121 Safari/537.36'</span>&#125;</span><br><span class="line">    r = requests.get(url,headers=headers,params=parameters).text</span><br><span class="line">    soup = BeautifulSoup(r,<span class="string">'lxml'</span>)</span><br><span class="line">    <span class="comment">#res = soup.find_all('div')</span></span><br><span class="line">    res = soup.findAll(<span class="string">'div'</span>,&#123;<span class="string">'class'</span>:<span class="string">'plan-head'</span>&#125;)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>
<p>结果如下<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[&lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案1&lt;/span&gt;&lt;p&gt;途经8个站点，共换乘1次，步行342米，全程约39分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案2&lt;/span&gt;&lt;p&gt;途经7个站点，共换乘1次，步行392米，全程约47分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案3&lt;/span&gt;&lt;p&gt;途经14个站点，共换乘1次，步行154米，全程约1小时18分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案4&lt;/span&gt;&lt;p&gt;途经7个站点，共换乘1次，步行650米，全程约53分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案5&lt;/span&gt;&lt;p&gt;途经13个站点，共换乘2次，步行49米，全程约1小时15分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案6&lt;/span&gt;&lt;p&gt;途经14个站点，共换乘2次，步行1米，全程约1小时20分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案7&lt;/span&gt;&lt;p&gt;途经13个站点，共换乘2次，步行154米，全程约1小时18分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案8&lt;/span&gt;&lt;p&gt;途经15个站点，共换乘2次，步行1米，全程约1小时25分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案9&lt;/span&gt;&lt;p&gt;途经23个站点，共换乘1次，步行169米，全程约2小时03分&lt;/p&gt;&lt;/div&gt;, &lt;div class="plan-head"&gt;&lt;span class="plan-no"&gt;方案10&lt;/span&gt;&lt;p&gt;途经11个站点，共换乘1次，步行870米，全程约1小时17分&lt;/p&gt;&lt;/div&gt;]</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="多重循环采集数据"><a href="#多重循环采集数据" class="headerlink" title="多重循环采集数据"></a>多重循环采集数据</h3><p>爬虫是一个多重循环</p>
<p>需要注意为了robust：加入try异常机制</p>
<ul>
<li>注意潜在的错误信息<ul>
<li>list列表为空</li>
<li>设计随机暂停（time.sleep()）可以搞一个正态分布<ul>
<li>模拟正常浏览行为</li>
</ul>
</li>
<li>多准备一些IP地址（代理服务器）</li>
</ul>
</li>
</ul>
<h3 id="通过API获取数据"><a href="#通过API获取数据" class="headerlink" title="通过API获取数据"></a>通过API获取数据</h3><p>合法公开接口</p>
<p>API申请：</p>
<ul>
<li>百度开放平台</li>
<li>注册</li>
<li>控制台应用</li>
<li>定义IP限制</li>
<li>得到api_key密钥</li>
</ul>
<p>通过开发文档了解API规则</p>
<h3 id="手机APP接口获取"><a href="#手机APP接口获取" class="headerlink" title="手机APP接口获取"></a>手机APP接口获取</h3><p>电脑端：Fiddler等</p>
<ul>
<li>捕获HTPPS</li>
<li>基本界面</li>
<li>设置断点<ul>
<li>修改request</li>
<li>修改response</li>
</ul>
</li>
<li>过滤会话</li>
<li>编码</li>
</ul>
<p>安卓：</p>
<ul>
<li>Wireshark</li>
<li>Package Capture</li>
<li>Share for root</li>
</ul>
<h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>Virtual Private Server虚拟专用服务器</p>
<p>物理设备上的虚拟机</p>
<p>阿里云、腾讯云</p>
<p>VULTR、DigitalOcean</p>
<p>选择哪个？：分析海底光缆拓扑</p>
<p>使用SSH</p>
<p>windows：Xshell/PuTTY</p>
]]></content>
      <categories>
        <category>校内课程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python调用c#编写的dll文件</title>
    <url>/2021/02/26/%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8c-%E7%BC%96%E5%86%99%E7%9A%84dll%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>遇到了一个第三方的API库，是使用c#写的dll库，为了便于与项目的其他部分融合（也是为了想降低coding难度哈哈），想要使用python操作dll库，做了一番探索，做一个记录。</p>
<a id="more"></a>
<p>网上大致搜索了一下，python可以通过第三方库的支持来读取调用dll文件，有一个叫ctypes之类的库可以读取c编写的函数，针对c#有一个专门的库叫pythonnet。</p>
<p>使用pip install pythonnet或者上pypi手动下载wheel文件完成安装，需要注意手动安装时要选择适配python3.x版本的相应文件，网上有很多人版本没有选对。</p>
<p>在这里也大致说一下我对c#所写dll文件结构的理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classlib.dll</span><br><span class="line"></span><br><span class="line">mynamespace&#123;</span><br><span class="line">    myclass&#123;</span><br><span class="line">        func1;</span><br><span class="line">        func2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个dll文件中包含着命名空间，dll文件名不需要和namespace的名字一样（使用vs2017生成dll时默认与namespace名字一致），命名空间mynamespace中含有相关的类和方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using mynamespace;</span><br><span class="line"></span><br><span class="line">inst &#x3D; myclass();</span><br><span class="line">var result &#x3D; inst.func1();</span><br></pre></td></tr></table></figure>
<p>在c#中使用时，声明使用dll文件中的命名空间，就可以使用里面的类和方法，用法是比较简单的。在python中我们也期待可以用相似的方式导入命名空间，直接访问相应的类和方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clr <span class="comment"># 是的不叫pythonnet，那个只是包名字</span></span><br><span class="line">clr.AddReference(<span class="string">'classlib'</span>) <span class="comment"># 注意没有dll后缀</span></span><br><span class="line"><span class="keyword">from</span> mynamespace <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">inst = myclass()</span><br><span class="line">res = inst.func1()</span><br></pre></td></tr></table></figure>
<p>将dll文件放到与py文件相同的文件夹，使用上述的方法就理论可以完成namespace的导入和使用</p>
<p><strong>但是！</strong></p>
<p>使用过程中也有一些奇怪的，我不能理解的问题：<br>在项目中有个dll文件一直提示找不到这个模块，无论是放在同一个目录下还是将它加入到path系统变量都不行，有一些方案提示使用绝对路径地址，或者使用<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">clr.FindAssembly(<span class="string">"absolute path.dll"</span>) <span class="comment"># 注意有dll后缀</span></span><br></pre></td></tr></table></figure><br>这些方法对于我来说都不是很好用，后来这个dll文件没有实际使用，FindAssembly和AddReference两个函数有什么区别我也没搞清，pythonnet项目的github地址上给的例子使用的是AddReference，我最终使用的也是这个，FindAssembly有啥用怎么用看之后如果有机会碰到了再研究吧</p>
<p>今天是体会到python为什么叫胶水语言了，确实简单好用</p>
<p>下一篇与此项目相关的内容暂定为python调用windows COM组件的方法，和C++调用COM一对比就看出来python是真的简单啊</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用paramiko远程登陆虚拟机执行命令</title>
    <url>/2021/02/22/%E4%BD%BF%E7%94%A8paramiko%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在win10环境下撰写python脚本，ssh登录虚拟机，并执行命令和返回结果</p>
<a id="more"></a>
<p>今天接到了一个小任务，需要在windows环境下写个python脚本执行远程机器上的命令，主要就是把ssh命令行的指令变成脚本，搜了一下发现paramiko这个库可以简单的实现这一功能，做一个记录</p>
<p>没有安装paramiko的环境可以使用pip3 install paramiko安装一下，需要注意pip的版本最好更新到最新，一开始使用低版本的pip遇到了找不到依赖项的情况，更新了pip之后就好了</p>
<p>anaconda没有遇到安装问题</p>
<p>在ubuntu20的虚拟机上写了个demo.py，内容就是打印”Ubuntu is ready”，虚拟机采用桥接方式，地址为192.168.110.104</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="comment"># 默认ssh登陆在~目录，所以直接执行了如下命令，正常情况最好用文件绝对地址</span></span><br><span class="line">cmd = <span class="string">'python3 demo.py'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create client object</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line"><span class="comment"># do if missing host key, add new hostname into list</span></span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># login (fakeinfo here) port22:ssh port</span></span><br><span class="line">ssh.connect(hostname=<span class="string">'192.168.110.104'</span>, username=<span class="string">'adin'</span>, password=<span class="string">'xxxxxxx'</span>, port=<span class="number">22</span>)</span><br><span class="line"><span class="comment"># return result</span></span><br><span class="line">stdin, stdout, stderr = ssh.exec_command(cmd)</span><br><span class="line"><span class="comment"># read the buffer and decode</span></span><br><span class="line">print(stdout.read().decode())</span><br><span class="line"></span><br><span class="line">ssh.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化问题</title>
    <url>/2021/03/07/%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>凸优化问题的求解方法</p>
<a id="more"></a>
<h2 id="凸优化问题的表述"><a href="#凸优化问题的表述" class="headerlink" title="凸优化问题的表述"></a>凸优化问题的表述</h2><script type="math/tex; mode=display">
min \quad f(x) \\
s.t. \quad g_i(x)\le 0 , i=1...m\\
\qquad h_j(x)=0, j =1,...n</script><p>成为凸优化问题的条件：</p>
<ol>
<li>$f(x)$是凸函数</li>
<li>$g(x)$是凸函数</li>
<li>$h(x)$是线性函数</li>
</ol>
<p>有时乍一看某个问题不是凸优化，但是通过等价转换后可以变成凸优化问题</p>
<hr>
<h2 id="凸优化问题的特点"><a href="#凸优化问题的特点" class="headerlink" title="凸优化问题的特点"></a>凸优化问题的特点</h2><ol>
<li><p><strong>局部最优解就是全局最优解</strong></p>
</li>
<li><p>全局最优解$x^* \in S$的等价条件：</p>
</li>
</ol>
<script type="math/tex; mode=display">\bigtriangledown f(x^*)^T(x-x^*)\ge 0, \forall x \in S</script><p>可以用上一章凸函数的性质证明</p>
<blockquote>
<ol>
<li>等价于$f(y)\ge f(x)+\bigtriangledown f(x)^T(y-x)$.在图形上为凸函数在任意点的切面上方。</li>
</ol>
</blockquote>
<script type="math/tex; mode=display">f(x)\ge f(x^*)+\bigtriangledown f(x^*)^T(x-x^*)\ge f(x^*)</script><p>最优点的梯度向量可以作为超平面的法向量，该超平面就是一个凸集的支撑平面</p>
<hr>
<h2 id="几种特殊凸问题的最优化条件"><a href="#几种特殊凸问题的最优化条件" class="headerlink" title="几种特殊凸问题的最优化条件"></a>几种特殊凸问题的最优化条件</h2><ol>
<li>无约束凸优化的最优点充分必要条件：</li>
</ol>
<script type="math/tex; mode=display">\bigtriangledown f(x^*)=0</script><ol>
<li>等式约束凸优化问题$min{f(x) | Ax = b}$</li>
</ol>
<p>$\bigtriangledown f(x^*)$在A矩阵的行向量空间里</p>
<ol>
<li>非负约束$min{f(x) | x \ge 0}$:</li>
</ol>
<script type="math/tex; mode=display">\bigtriangledown f(x^*)x^* = 0, x^*\ge 0, \bigtriangledown f(x^*) \ge 0</script><hr>
<h2 id="线性规划问题-LP"><a href="#线性规划问题-LP" class="headerlink" title="线性规划问题 LP"></a>线性规划问题 LP</h2><h3 id="通用解法"><a href="#通用解法" class="headerlink" title="通用解法"></a>通用解法</h3><script type="math/tex; mode=display">min\quad c^Tx \\
s.t. \quad Ax = b \\
\qquad x \ge 0</script><p>去找集合的极点，依次判断每个极点是不是最优点即可</p>
<h3 id="可以转换为线性规划的问题"><a href="#可以转换为线性规划的问题" class="headerlink" title="可以转换为线性规划的问题"></a>可以转换为线性规划的问题</h3><h4 id="分式线性规划"><a href="#分式线性规划" class="headerlink" title="分式线性规划"></a>分式线性规划</h4><h4 id="最小化绝对值函数"><a href="#最小化绝对值函数" class="headerlink" title="最小化绝对值函数"></a>最小化绝对值函数</h4><h4 id="最小化多面体函数"><a href="#最小化多面体函数" class="headerlink" title="最小化多面体函数"></a>最小化多面体函数</h4><hr>
<h2 id="二次规划问题-QP"><a href="#二次规划问题-QP" class="headerlink" title="二次规划问题 QP"></a>二次规划问题 QP</h2>]]></content>
      <categories>
        <category>最优化</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title>凸函数</title>
    <url>/2021/03/07/%E5%87%B8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>凸函数的定义与性质</p>
 <a id="more"></a>
<h2 id="凸函数的定义"><a href="#凸函数的定义" class="headerlink" title="凸函数的定义"></a>凸函数的定义</h2><p>设$C$是非空凸集，$f$是定义在$C$上的函数，若对任意$x,y\in C,\alpha \in (0,1)$，都存在</p>
<script type="math/tex; mode=display">f(\alpha x + (1-\alpha)y) \ge \alpha f(x) + (1-\alpha)f(y)</script><ol>
<li>则称函数$f$是凸函数</li>
<li>若大于等于号变成大于号，则为严格凸函数</li>
<li>小于号代表凹函数，凹凸的方向与字型相反</li>
</ol>
<hr>
<h2 id="常见的凸函数"><a href="#常见的凸函数" class="headerlink" title="常见的凸函数"></a>常见的凸函数</h2><ol>
<li>线性函数$y=a^Tx+b$</li>
<li>二次函数$y=x^TQx+a^Tx+b, Q\in S_{+}^n$</li>
<li>最小二乘函数$f(x)=|Ax-b |^2_2$</li>
<li>$p$范数$f(x) = (\sum_i^n|x_i|^p)^{1/p}, p\ge 1$</li>
</ol>
<ul>
<li>$p=0$的时候范数不满足凸函数要求，0范数代表$x$中非零的元素数目</li>
<li>二次型矩阵需要是半正定矩阵</li>
<li>最小二乘类似二次函数，由于其二次型函数为$A^TA$，保证了一定为半正定矩阵</li>
</ul>
<hr>
<h2 id="凸函数的性质"><a href="#凸函数的性质" class="headerlink" title="凸函数的性质"></a>凸函数的性质</h2><p>若$f(x)$是凸函数</p>
<ol>
<li>一定是连续函数</li>
<li>$\forall a,b \in R^n, \varphi(x)=f(x+\alpha y)$也是凸函数，需要注意$a,b$一旦选定后为定值。可以视作$ab$点连线对原凸函数的切面。切面得到的函数仍是凸函数。例如对一个二维的抛物面用切线剖开，得到的是凸函数抛物线。</li>
<li>等价于$f(y)\ge f(x)+\bigtriangledown f(x)^T(y-x)$.在图形上为凸函数在任意点的切面上方。</li>
<li>若$f(x)$二阶可微，则凸函数等价于Hesse矩阵为半正定矩阵。类似于$f(x)$任一点二阶导数大于等于零，从图形上来看是斜率一直在增加。</li>
</ol>
<hr>
<h2 id="保证凸函数性质的运算"><a href="#保证凸函数性质的运算" class="headerlink" title="保证凸函数性质的运算"></a>保证凸函数性质的运算</h2><ol>
<li>透视函数</li>
</ol>
<p>若$f(x)$是凸函数，构造了一个新函数$g(x,t)=tf(x/t),t&gt;0$</p>
<p>$g(x)$也是凸函数</p>
<p><img src='perception.png' width=600, title='透视函数'></p>
<ol>
<li>非负组合</li>
</ol>
<script type="math/tex; mode=display">g(x) = \sum w_i f_i(x), w_i\ge 0</script><ol>
<li>凸函数求最大</li>
</ol>
<script type="math/tex; mode=display">g(x) = max{f_1(x),...f_m(x)}</script><hr>
<h2 id="和凸集关系"><a href="#和凸集关系" class="headerlink" title="和凸集关系"></a>和凸集关系</h2><p>若函数为凸函数，则<strong>水平集</strong>一定是凸集</p>
<p><img src='co.png' width=600, title='水平集'></p>
<p>反过来是不成立的</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title>排序：优先队列</title>
    <url>/2020/06/29/%E6%8E%92%E5%BA%8F%EF%BC%9A%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>优先队列是一种数据结构，基本的操作包括<em>去除最大元素</em>以及<em>插入元素</em>。通过实现优先队列可以实现<em>堆排序</em>方法，也可以用于模拟系统的优先级操作。</p>
<a id="more"></a>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">具体实现也用到了之前用过的less()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt;</span>&#123;</span><br><span class="line">    MaxPQ(); <span class="comment">// create a Prior Queue</span></span><br><span class="line">    MaxPQ(<span class="keyword">int</span> max); <span class="comment">// create a Prior Queue whose capacity is max</span></span><br><span class="line">    MaxPQ(Key[] a); <span class="comment">// create a Prior Queue from Key[] a</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>; <span class="comment">// insert a element into the PQ</span></span><br><span class="line">    <span class="function">Key <span class="title">max</span><span class="params">()</span></span>; <span class="comment">//get the maximum element</span></span><br><span class="line">    <span class="function">Key <span class="title">delMax</span><span class="params">()</span></span>; <span class="comment">// delete and return the maximum element</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先队列的一个用途就是从长度为N的序列中找出M个最大的元素。</p>
<center> 寻找M个最大元素的成本 </center>

<div class="table-container">
<table>
<thead>
<tr>
<th>增长的数量级</th>
<th>时间</th>
<th>空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>排序算法的用例</td>
<td>NlogN</td>
<td>N</td>
</tr>
<tr>
<td>调用初级实现的优先队列</td>
<td>NM</td>
<td>M</td>
</tr>
<tr>
<td>调用基于堆实现的优先队列</td>
<td>NlogM</td>
<td>M</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopM</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(arg[<span class="number">0</span>]);</span><br><span class="line">        MinPQ&lt;Transaction&gt; pq = <span class="keyword">new</span> MinPQ&lt;Transaction&gt;</span><br><span class="line">        <span class="keyword">while</span>(StdIn.hasNextline())&#123;</span><br><span class="line">            pq.insert(<span class="keyword">new</span> Transaction(StdIn.readline()))</span><br><span class="line">            <span class="keyword">if</span> (pq.size()&gt;M)&#123;</span><br><span class="line">                pq.delMin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Transaction&gt; stack = <span class="keyword">new</span> Stack&lt;Transaction&gt;;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) stack.push(pq.delMin());</span><br><span class="line">        <span class="keyword">for</span> (t : stack) StdOut.println(t);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初级实现"><a href="#初级实现" class="headerlink" title="初级实现"></a>初级实现</h2><h3 id="有序数组实现"><a href="#有序数组实现" class="headerlink" title="有序数组实现"></a>有序数组实现</h3><p>插入方法insert（）中添加选择合适位置的代码，保证插入的元素一直使得数组有序，时间复杂度为N</p>
<p>delMax（）则与栈的pop方法一致</p>
<h3 id="无序数组实现"><a href="#无序数组实现" class="headerlink" title="无序数组实现"></a>无序数组实现</h3><p>插入方法insert（）与栈的push（）一致</p>
<p>delMax（）与选择排序类似，遍历寻找最大元素，然后交换栈顶元素与最大元素，之后pop（）</p>
<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><p>链表与数组类似，也分有序与无序，区别也同样在于是insert（）还是delMax（）中增加代码</p>
<h2 id="优先队列的堆实现"><a href="#优先队列的堆实现" class="headerlink" title="优先队列的堆实现"></a>优先队列的堆实现</h2><p>数据结构<strong>二叉堆</strong>是二叉树的一种特殊形式，规则在于一棵树的三个节点有固定的大小关系。当根结点大于两个子节点时，该二叉堆为<strong>堆有序</strong>状态。</p>
<p><img src='fulltree.png' width=700 title='complete binary tree '></p>
<p>如果使用指针表示二叉堆，每个节点需要有三个指针指向相关节点。而如果二叉堆的组成结构是一个完全二叉树，则可以使用数组的方式直接表示，按照层级存储的方式不需要指针。</p>
<p>二叉堆也在本文中也简称为堆，堆的第$K$个节点的父节点位置为$floor(K/2)$，子节点为$2K$和$2K+1$。</p>
<p>使用堆可以用对数级别性能完成插入和删除操作。</p>
<h2 id="堆算法"><a href="#堆算法" class="headerlink" title="堆算法"></a>堆算法</h2><p>to be continued</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>凸集的概念与性质</title>
    <url>/2021/02/27/%E5%87%B8%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<p>凸集是最优化理论中的重要概念，是凸优化理论的前置知识</p>
<a id="more"></a>
<p>如果目标函数是一个凸函数，可行集是一个凸集，那么这种优化问题可以视作是凸优化问题</p>
<h2 id="为什么要研究凸优化"><a href="#为什么要研究凸优化" class="headerlink" title="为什么要研究凸优化"></a>为什么要研究凸优化</h2><p><strong>凸优化问题有一些比较好的性质</strong></p>
<ol>
<li><p>对凸函数来说，一定能找到最优解，平稳点就是最优解；非凸函数不能得到这种结论<br><img src='convexfunc.png' width=600 title='凸函数的好处'></p>
</li>
<li><p>可行集是凸集的话</p>
</li>
</ol>
<p><img src='convexcollec.png' width=600 title='凸集的特点'></p>
<p>凸集上最优点的充分必要条件是，该点的负梯度，与，任一点与该点的内积小于零（夹角大于90度）<br>非凸集上没有这种条件</p>
<p>综上，凸优化问题中可以有比较好的性质可以利用，可以设计有效的算法（如<strong>内点法</strong>）来解决凸优化问题</p>
<h2 id="凸集的基本定义"><a href="#凸集的基本定义" class="headerlink" title="凸集的基本定义"></a>凸集的基本定义</h2><p>对于任意的$x,y \in C$与任意的$\lambda \in [0,1]$有</p>
<script type="math/tex; mode=display">
\lambda x + (1-\lambda)y \in C</script><p>集合两点的连线仍然属于集合</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p><img src='convexcom.png' width=600 title='凸组合和凸包'></p>
<p>有几种组合，线性、仿射、非负和凸组合，凸包是一种凸组合。凸包可以让非凸的集合填满，填成凸集合。</p>
<h2 id="常见的凸集合"><a href="#常见的凸集合" class="headerlink" title="常见的凸集合"></a>常见的凸集合</h2><ul>
<li>超平面</li>
</ul>
<script type="math/tex; mode=display">
H = \{x | a^Tx=b\} (a\ne 0)</script><ul>
<li>半空间</li>
</ul>
<script type="math/tex; mode=display">
H = \{ x | a^Tx \le b \} (a\ne 0)</script><ul>
<li>多面体<ul>
<li>不等式和线性等式刻画的都是多面体<script type="math/tex; mode=display">
\{x|a_i^Tx\le b_i, i=1,2...m\}</script></li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
\{x|a_i^Tx =  b_i, i=1,2...m\}</script><ul>
<li>球体 Euclidean</li>
</ul>
<script type="math/tex; mode=display">
B(x_c, r) = \{ x| \parallel x -x_c \parallel \le r\}</script><ul>
<li><p>椭球 Ellipsoid</p>
<ul>
<li>注意矩阵的逆，P为正定矩阵，椭球的半轴是矩阵的特征值开根号<script type="math/tex; mode=display">
\{ x| ( x -x_c )^T P^{-1} (x -x_c) \le 1\}</script></li>
</ul>
</li>
<li><p>二阶锥 Second-order cone，ice-cream cone</p>
<ul>
<li>x是前n-1个元素，t是最后一个元素<script type="math/tex; mode=display">
\{ (x,t) | \parallel x \parallel _2 < t\}</script></li>
</ul>
</li>
<li><p>半定矩阵锥</p>
</li>
</ul>
<p><img src='halfortho.png' width=600 title='半定矩阵锥'></p>
<p>这个图形表示x，y，z满足上述公式的单的集合，半正定矩阵形成的集合</p>
<h2 id="保持凸性的运算"><a href="#保持凸性的运算" class="headerlink" title="保持凸性的运算"></a>保持凸性的运算</h2><p>交集可以保证凸性，并集不能保证。加减法也可以保证。</p>
<p>仿射变换保证凸性：</p>
<p>仿射变换是一种线性变换, 凸集仿射后得到的还是一个凸集</p>
<p><img src='fangshe.png' width=600 title='仿射'></p>
<h3 id="投影定理"><a href="#投影定理" class="headerlink" title="投影定理"></a>投影定理</h3><p><img src='touying.png' width=600 title='投影'></p>
<h3 id="点与凸集的分离"><a href="#点与凸集的分离" class="headerlink" title="点与凸集的分离"></a>点与凸集的分离</h3><p>用超平面分离两个点，或者是两个闭凸集<br><img src='sep.png' width=600 title='分离'></p>
<p>一个超平面能够让整个闭凸集位于超平面的一侧<br><img src='support.png' width=600 title='支撑超平面'></p>
<h2 id="Farkas引理"><a href="#Farkas引理" class="headerlink" title="Farkas引理"></a>Farkas引理</h2><p>给定矩阵$A_{m\times n}$和n维向量$c$，以下两个问题只存在一个解</p>
<ol>
<li><script type="math/tex; mode=display">Ax<0,c^Tx>0</script></li>
<li><script type="math/tex; mode=display">A^Ty = c, y\ge 0</script></li>
</ol>
<p>如果把$A$看作是一个凸集内多个n维行向量的集合，则上述两个定理分别是让$c$位于凸集内和凸集外，在凸集外可以用点和凸集的分离定理来证明这个引理。</p>
<p>或者用画图的方式，大于小于零分别是向量夹角大于或者小于180度。画一画就看出来不可能同时有解。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title>排序：初级排序算法</title>
    <url>/2020/06/20/%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序通常是数据处理中最先要做的一步，也是耗时大户。《算法4》中的这一章，主要是学习几种经典的排序算法。第一部分为初级排序算法，将学习两种基础算法以及其中的变体。</p>
<a id="more"></a>
<h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><h3 id="元素与主键"><a href="#元素与主键" class="headerlink" title="元素与主键"></a>元素与主键</h3><p>排序算法关注的排序对象为数组<strong>元素</strong>，每一个元素有一个对应的<strong>主键</strong>。<br>在Java中主键的抽象描述是通过实现<em>Comparable接口</em>完成的。</p>
<h3 id="算法类API"><a href="#算法类API" class="headerlink" title="算法类API"></a>算法类API</h3><p>解决这一排序问题的算法以类的形式出现，具有一些通用的方法。下面列出“排序算法类模板Example”的API。</p>
<ul>
<li>sort（）用于排序</li>
<li>less（）比较两个元素大小</li>
<li>exch（）交换元素位置</li>
<li>isSorted（）判断是否是有序数组</li>
<li>show（）按顺序打印数组</li>
<li>main（）测试用例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 在单行中打印数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            StdOut.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 从标准输入读取字符串，将它们排序并输出</span></span><br><span class="line">        String[] a = In.readStrings();</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序算法评价方法"><a href="#排序算法评价方法" class="headerlink" title="排序算法评价方法"></a>排序算法评价方法</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>使用isSorted（）来判断算法是否成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(isSorted(a))</span><br></pre></td></tr></table></figure>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>需要计算的成本包括数组元素的交换、比较的次数，对于不交换元素的算法，则计算其访问数组的次数。实际测试以随机输入来进行性能比较。</p>
<h4 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h4><p>算法在额外空间消耗指标上的表现可以将其分为两类：</p>
<ul>
<li>原地排序算法： 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存</li>
<li>其他排序算法：需要额外空间来存储另一份数组副本</li>
</ul>
<h3 id="数据类型的实现"><a href="#数据类型的实现" class="headerlink" title="数据类型的实现"></a>数据类型的实现</h3><p>Java中实现排序功能的数据类型都实现了Comparable接口，具体到自己实现的数据类型，只需要实现compareto（）这个方法即可，该方法定义了目标类型对象的<strong>自然排序</strong>。Java中的原始数据类型的包装类Integer Double等都实现了这一个接口。</p>
<p>一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123; day = d; month = m; year = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> year; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date that)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &gt; that.year ) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &lt; that.year ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &gt; that.month) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &lt; that.month) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &gt; that.day ) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &lt; that.day ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compareTo（）方法通常返回-1，0，+1三种结果，对应调用者小于，等于，大于被调用元素。如果调用者和被调用元素无法比较大小则会抛出异常。</p>
<p>该方法的实现时需要保证：</p>
<ul>
<li>自反性 v=v</li>
<li>反对称性 v &lt; w —&gt; w &gt; v</li>
<li>传递性 v &lt; w  w &lt; p —&gt; v &lt; p</li>
</ul>
<p>实现这三个特性是比较自然的，意义也比较明确。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote>
<p>一种最简单的排序算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。</p>
</blockquote>
<p>选择排序的特点是</p>
<ul>
<li>排序时间与输入无关。一个数组是否有序并不能影响排序的时间，排序时间只和数组的规模有关。数组大小为N时，将进行$\frac{N^{2}}{2}$次比较和$N$次元素交换。其他算法通常会利用数据的输入状态。</li>
<li>数据移动的次数是最少的。交换次数和数组大小是线性关系，这与其他的算法有着鲜明的区别（一般交换的次数都是线性对数或者平方级别）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length; <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123; <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line">            <span class="keyword">int</span> min = i; <span class="comment">// 最小元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">                exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序.</p>
</blockquote>
<p>与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。</p>
<p>和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。</p>
<blockquote>
<p>对于随机排列的长度为N 且主键不重复的数组，平均情况下插入排序需要～ $\frac{N^2}{4}$ 次比<br>较以及～ $\frac{N^2}{4}$ 次交换。最坏情况下需要～ $\frac{N^2}{2}$ 次比较和～$\frac{N^2}{2}$次交换，最好情况下需要$N-1$次比较和$0$次交换。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        &#123; <span class="comment">// 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">                exch(a,j,j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和冒泡的排序方法总觉得有些类似，它是按照索引向前不断将索引左侧的数据进行冒泡一样的排序，把最小值或最大值运往最左侧。索引左侧永远是个完成好的排序工作。</p>
<p><img src='paixu.png' width = '600' title = 'insert sorting'></p>
<p><strong>插入排序很擅长处理基本上有序的数组，它可能比其他任何算法都要擅长处理</strong></p>
<p>基本有序的数组：</p>
<ul>
<li>每个元素都距离最终的位置不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素位置不正确 </li>
</ul>
<blockquote>
<p>插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一</p>
</blockquote>
<h2 id="希尔排序-Shell-Sorting"><a href="#希尔排序-Shell-Sorting" class="headerlink" title="希尔排序 Shell Sorting"></a>希尔排序 Shell Sorting</h2><p>希尔排序是插入排序的一种改进，将原本的步长为1扩大为h，我觉得可以理解为将一个无序的大数组先变成若干个有序的小数组，然后再逐渐合并这些小数组（降低h），直至h=1时达到与插入排序相同的效果。</p>
<blockquote>
<p>研究希尔排序性能需要的数学论证超出了本书范围</p>
</blockquote>
<p>希尔算法在最差情形下也小于平方级别，大约是1.5次级别，对它严格的数学推导到目前为止也是难题，但大量的实验证明了它比插入排序的速度要快很多，而且数据的规模越大它的优势也就越大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121, 364, 1093, ...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123; <span class="comment">// 将数组变为h有序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++)</span><br><span class="line">            &#123; <span class="comment">// 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src='shell.png' width = '600' title = 'shell'></p>
<p><img src='shell-vision.png' width='600' title = 'shell-visibility'></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>排序：归并排序</title>
    <url>/2020/06/21/%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本章讨论的是归并排序算法，它的基本思路是把有序的小数组合并为大数组，同时也使用了递归的思想。归并排序可以保证任意长度为$N$的数组可以在正比于$NlogN$的时间里完成排序，但缺点是所需空间与$N$成正比。</p>
<a id="more"></a>
<p><img src='guibing.JPG' size = '600' title='demonstration of the Merge Sort'></p>
<h2 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h2><blockquote>
<p>原地排序算法： 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存</p>
</blockquote>
<p>原地归并的思路并不复杂，先排序前半部分，再排序后半部分，然后不需额外空间的移动数组元素。但在算法实现中这种方案比较复杂。</p>
<p>一种原地归并的抽象化方法，使用了一个辅助数组aux。按照升序排列，两个已经排序好的数组依次比较各元素大小，挑选小的放进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[lo..mid] 和 a[mid+1..hi] 归并</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) <span class="comment">// 将a[lo..hi]复制到aux[lo..hi]</span></span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) <span class="comment">// 归并回到a[lo..hi]</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid)                    a[k] = aux[j++]; <span class="comment">// 前半个数组已经都排完了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi )               a[k] = aux[i++]; <span class="comment">// 后半个数组都已经排完了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++]; <span class="comment">// 挑选两个数组中最小值的较小值</span></span><br><span class="line">        <span class="keyword">else</span>                            a[k] = aux[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h2><p>递归方法，不断分而治之，直到把数组分为一个个元素再合并起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">// 归并所需的辅助数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length]; <span class="comment">// 一次性分配空间</span></span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 将数组a[lo..hi]排序</span></span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid); <span class="comment">// 将左半边排序</span></span><br><span class="line">        sort(a, mid+<span class="number">1</span>, hi); <span class="comment">// 将右半边排序</span></span><br><span class="line">        merge(a, lo, mid, hi); <span class="comment">// 归并结果（代码见“原地归并的抽象方法”）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src='merge.JPG' width = '600' title='demonstration of the Merge Sort'></p>
<h2 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h2><p>自顶向下的方法的合并顺序是按照树的顺序，使用递归的方法左右子树依次合并。而自底向上的归并排序则不是使用递归，而是两两合并，再四四合并，再八八合并，每次合并都是在全数据范围内进行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">// 归并所需的辅助数组</span></span><br><span class="line">    <span class="comment">// merge()方法的代码请见“原地归并的抽象方法”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 进行lgN次两两归并</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz+sz) <span class="comment">// sz子数组大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz; lo += sz+sz) <span class="comment">// lo:子数组索引</span></span><br><span class="line">                merge(a, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, N-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src='merge-bu.png' width='600' title='merge-bu-visualization'></p>
<blockquote>
<p>对于长度为N 的任意数组，自底向上的归并排序需要$1/2NlgN$ 至$NlgN$ 次比较，最多访问数组$6NlgN$ 次。</p>
<p>当数组长度为2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同</p>
<p><strong>自底向上的归并排序比较适合用链表组织的数据</strong>。想象一下将链表先按大小为1 的子链表进行排序，然后是大小为2 的子链表，然后是大小为4 的子链表等。这种方法只需要重新组织链表链接就能将链表<strong>原地排序</strong>（不需要创建任何新的链表结点）</p>
</blockquote>
<h2 id="排序算法的复杂度"><a href="#排序算法的复杂度" class="headerlink" title="排序算法的复杂度"></a>排序算法的复杂度</h2><blockquote>
<p>没有任何基于比较的算法能够保证使用少于$lg（N!）$～ $NlgN$ 次比较将长度为N 的数组排序。</p>
</blockquote>
<p>这个结论可以简单用树结构证明，每一张N个元素的排列方式是一个树的叶子，N个元素共有N！种排列，也就是这个树叶子的数目为N！，如果每一个节点代表比较了两个元素，每个节点比较之后会对应两种结果，也就是这个节点的左右子树。因此基于比较的算法可以表示为<strong>一颗二叉树</strong>，<strong>需要比较的次数就是根到叶子节点的路径长度</strong>，该长度最大就是一个二叉树的高度，即lg（N！），根据斯特灵公式可以近似表示为NlgN。对应着N元素数组的最坏情况。</p>
<blockquote>
<p>归并排序是一种渐进最优的基于比较排序的算法。</p>
</blockquote>
<p>两者的复杂度类似都是$Nlg(N!)$</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>排序：快速排序</title>
    <url>/2020/06/22/%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>快速排序算法得到了十分广泛的应用，原因在于它具有在时间和空间上的双重优点——它是原地排序算法，所需的时间与$Nlog（N）$成正比。它的实现比较脆弱，脆弱的含义是一旦不小心性能会变得非常糟糕。</p>
<a id="more"></a>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>基本的思想是<strong>分而治之</strong>。</p>
<blockquote>
<p>快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：<em>归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。</em>在第一种情况中，递归调用发生在处理整个数组<strong>之前</strong>；在第二种情况中，递归调用发生在处理整个数组<strong>之后</strong>。</p>
</blockquote>
<p>在归并排序中，一个数组被等分为两半；在快速排序中，切分（partition）的位置取决于数组的内容。</p>
<p><img src='quick.JPG' width='600' title='demonstration of quick sorting'></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StdRandom.shuffle(a); <span class="comment">// 消除对输入的依赖</span></span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi); <span class="comment">// 切分（请见“快速排序的切分”）</span></span><br><span class="line">        sort(a, lo, j-<span class="number">1</span>); <span class="comment">// 将左半部分a[lo .. j-1]排序</span></span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi); <span class="comment">// 将右半部分a[j+1 .. hi]排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打乱数组—&gt;切分—&gt;分别排序</p>
<h3 id="快速排序的切分"><a href="#快速排序的切分" class="headerlink" title="快速排序的切分"></a>快速排序的切分</h3><p><strong>切分策略是快速排序算法的核心</strong></p>
<p>一般策略是先随意地取a[lo] 作为切分元素，即那个将会被排定的元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此我们交换它们的位置。如此继续，我们就可以保证左指针i 的左侧元素都不大于切分元素，右指针j 的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素a[lo] 和左子数组最右侧的元素（a[j]）交换然后返回j 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将数组切分为a[lo..i-1], a[i], a[i+1..hi]</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi+<span class="number">1</span>; <span class="comment">// 左右扫描指针</span></span><br><span class="line">    Comparable v = a[lo]; <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123; <span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(v, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, lo, j); <span class="comment">// 将v = a[j]放入正确的位置</span></span><br><span class="line">    <span class="keyword">return</span> j; <span class="comment">// a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi] 达成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h2><h3 id="切换到插入排序"><a href="#切换到插入排序" class="headerlink" title="切换到插入排序"></a>切换到插入排序</h3><p>在快速排序开始的时候，判断如果数组长度小于某个值则将算法切换为插入排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hi&lt;=lo) <span class="keyword">return</span>;</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"><span class="keyword">if</span> (hi&lt;=<span class="number">1</span>o+M) &#123;Insertion.sort(a,lo,hi); <span class="keyword">return</span>;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三取样切分"><a href="#三取样切分" class="headerlink" title="三取样切分"></a>三取样切分</h3><blockquote>
<p>改进快速排序性能的第二个办法是使用子数组的一小部分元素的中位数来切分数组。这样做得到的切分更好，但代价是需要计算中位数。人们发现将取样大小设为3 并用大小居中的元素切分的效果最好。我们还可以将取样元素放在数组末尾作为“哨兵”来去掉partition() 中的数组边界测试。使用三取样切分的快速排序轨迹如图</p>
</blockquote>
<p><img src='3groupsample.png' width=800 title='3groupsample'></p>
<h3 id="熵最优排序"><a href="#熵最优排序" class="headerlink" title="熵最优排序"></a>熵最优排序</h3>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：向量</title>
    <url>/2020/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<p>邓公学堂在线MOOC+清华《数据结构第三版》的一些记录。本篇为向量部分。</p>
<a id="more"></a>
<p>抽象数据类型ADT与数据结构DS不同，后者包含着算法。</p>
<p>向量是对数组这种数据类型的抽象和泛化，元素的顺序使用秩<strong>Rank</strong>来表示。</p>
<hr>
<p>继承的时候，同样分为public protected private继承，次时修饰符modifier代表派生类的被访问权限的上限（在此假定权限定义高低为public &gt; protected &gt; private）即如果private继承，类里面所有成员变量和成员函数都会变成private：如果public继承，保持不变；如果protected继承，只会将原先是public的降低至protected。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//ADT interface of Vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_CAPCITY 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    T* _elem; Rank _size; <span class="keyword">int</span> _capacity;</span><br><span class="line">    ...... <span class="comment">//auxiliary funcitons </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...... <span class="comment">// constructor and destructor and interface function</span></span><br><span class="line">    Vector(<span class="keyword">int</span> c=DEFACULT_CAPACTIY,<span class="keyword">int</span> s=<span class="number">0</span>, T v=<span class="number">0</span>) &#123; <span class="comment">// all element are initialize to v</span></span><br><span class="line">        _elem = <span class="keyword">new</span> T[_capacity=c]; <span class="keyword">for</span>(_size=<span class="number">0</span>;_size&lt;s,;_elem[size++]=v);</span><br><span class="line">    &#125;</span><br><span class="line">    Vector (T <span class="keyword">const</span>* A, Rank n) &#123;copyfrom(A,<span class="number">0</span>,n)&#125;; <span class="comment">//数组整体复制</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>装填因子$\lambda=\frac{_size}{_capacity}$表示目前向量有效元素的比例，一般在接近满的时候会扩容，当有效元素小于容量1/4的时候会缩容。</p>
<p>扩容的方法包括倍增式扩容以及固定增量扩容两种方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 倍增式扩容expand()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::expand()&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size&lt;_capacity) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (_capcity &lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPCITY;</span><br><span class="line">    T* oldelem = _elem; _elem = <span class="keyword">new</span> T[_capacity&lt;&lt;=<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;_size;i++) &#123;</span><br><span class="line">        _elem[i] = oldelem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] oldelem; <span class="comment">// 记得调用delete[]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定增量式扩容只需要改动第三句</span></span><br><span class="line">...</span><br><span class="line">T* oldelem = _elem; _elem = <span class="keyword">new</span> T[_capacity+=increment]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对比这两种扩容方式，倍增式扩容在空间利用率上相对较低（但也大于50%），但是在时间复杂度上平摊只需O（1）的时间。相比固定增量式扩容需要O（n）的时间，这种空间上的不足是可以接受的。</p>
<p><em>为什么倍增式扩容可以平摊到O(1)，而固定式扩容还是O(n)呢，原因在于不论每次输入的量是多大，只要之后每次这个输入量保持不变，倍增式扩容都会迅速的将capacity扩展到比这个输入量大很多，使得扩容的频率迅速下降，有一种自适应的能力（输入的越猛，增长的越猛）。但是固定式扩容，一旦输入大于固定增量，则每次输入都会产生扩容操作，导致复杂度一直都差不多是O(n)，没有一个自我调节的能力。</em></p>
<p><strong>Average Running Time vs. amortized running time</strong></p>
<ul>
<li>前面的是平均时间，指的是算法按照概率分布的期望运行时间，又可以称作expected running time，对实际运行情况的模拟不够好。割裂了各个操作的相关性和连贯性。</li>
<li>后面的叫做分摊时间，假定的是对向量做足够多次操作后，时间分摊至每一次操作的成本，更具有现实意义。</li>
</ul>
<p><strong>一个习题与解答</strong></p>
<blockquote>
<p>Is it possible to replace:是否可以将视频里向量扩容代码中的：</p>
<p>for (int i = 0; i &lt; _size; i++) _elem[i] = oldElem[i];</p>
<p>in the vector expansion code in the video with: 替代为：</p>
<p>memcpy(_elem, oldElem, _size * sizeof(T));</p>
<p>P.S.This question involves the relevant knowledge of C++ P.S.本题涉及C++的相关知识</p>
</blockquote>
<p>解析：</p>
<p>When T is a non-base type and there is a corresponding assignment operator to perform deep copy, the previous section of code calls the assignment operator, and the latter section can only perform shallow copy. 当T为非基本类型且有对应的赋值运算符以执行深复制时，前一段代码会调用赋值运算符，而后一段只能进行浅复制。</p>
<p>缩容的实现与扩容基本一致，先比较size和capacity，再复制元素到新的elem中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;typnename T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: shrink()&#123;</span><br><span class="line">    <span class="keyword">if</span> (_capacity &lt; DEFAULT_CAPACITY&lt;&lt;<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// can not be smaller than the D_C</span></span><br><span class="line">    <span class="keyword">if</span> (_size&lt;&lt;<span class="number">2</span> &gt; _capacity) <span class="keyword">return</span>; <span class="comment">// not small enough</span></span><br><span class="line">    T* oldelem = _elem; _elem = <span class="keyword">new</span> T[_capacity&gt;&gt;=<span class="number">1</span>]; <span class="comment">// shrink to half</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; _size; i++) _elem[i]=oldelem[i];</span><br><span class="line">    <span class="keyword">delete</span>[] oldElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作符-重载"><a href="#操作符-重载" class="headerlink" title="操作符[]重载"></a>操作符[]重载</h2><p>为了获得下标式的元素引用方式A[i]，将向量操作符重载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; Vector &lt;T&gt; :: <span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span> (<span class="keyword">return</span> _elem[r])</span><br><span class="line"><span class="comment">// 此处对r的有效区间的讨论没做严格要求，实际使用时需要注意</span></span><br></pre></td></tr></table></figure>
<h2 id="插入insert-Rank-r-T-e"><a href="#插入insert-Rank-r-T-e" class="headerlink" title="插入insert(Rank r, T e)"></a>插入insert(Rank r, T e)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt; :: insert(Rank r, T e)&#123;</span><br><span class="line">    expand(); <span class="comment">// expand if necessary</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=_size; i&gt;r; i--)</span><br><span class="line">        T[i] = T[i<span class="number">-1</span>];</span><br><span class="line">    T[r] = e;</span><br><span class="line">    _size++;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间删除remove-Rank-lo-Rank-hi"><a href="#区间删除remove-Rank-lo-Rank-hi" class="headerlink" title="区间删除remove(Rank lo, Rank hi)"></a>区间删除remove(Rank lo, Rank hi)</h2><p>整体左移覆盖要删除的部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: remove(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hi&lt;_size) _elem[lo++] = _elem[hi++];</span><br><span class="line">    _size = lo; shrink(); <span class="comment">// _size = _size-(hi-lo)</span></span><br><span class="line">    <span class="keyword">return</span> hi - lo ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单个元素的删除可以看作区间删除的特例，但是区间删除不能看作单元素删除的特例，因为单独删除单元素也会有最坏O（n）的移动，已经和区间删除的复杂度相当了，如果反复执行这一过程会导致O（n^2）的复杂度，实际上是不可行的。</p>
</blockquote>
<h2 id="查找-find-T-const-amp-e-Rank-lo-Rank-hi"><a href="#查找-find-T-const-amp-e-Rank-lo-Rank-hi" class="headerlink" title="查找 find(T const&amp; e, Rank lo, Rank hi)"></a>查找 find(T const&amp; e, Rank lo, Rank hi)</h2><p>从后向前找，返回秩最大的符合要求的元素的秩。若没有返回-1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt; :: find(T <span class="keyword">const</span> &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">while</span>((lo&lt;hi--) &amp;&amp; e!= _elem[hi]);</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最好情况O（1），最坏情况O（n），这种称为 <strong>输入敏感</strong> 问题</p>
</blockquote>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>使用函数指针或者函数对象visit作为traverse的参数，从而实现对向量元素的遍历和操作。函数对象相比前者的应用范围更加广泛。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; ::traverse(<span class="keyword">void</span>(*visit) (T&amp;))&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;_size ; i++) &#123; visit(_elem[i]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; </span><br><span class="line"> <span class="keyword">void</span> Vector&lt;T&gt;:: traverse( VST&amp; visit)&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; _size;i++) visit(_elem[i]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>在这里不理解什么是函数对象和函数指针，不会使用</strong></p>
<blockquote>
<p>As a function object class XXX, which of the following member functions must be explicitly defined: 作为一个函数对象的类XXX，它必须显式定义以下哪个成员函数</p>
<ul>
<li>XXX()</li>
<li>~XXX()</li>
<li>operator<a href=""></a></li>
<li>operator()()</li>
</ul>
</blockquote>
<p>For a function object, () is an operator used to perform a function call 对于函数对象来说，()是用于执行函数调用的操作符</p>
<h2 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h2><p>无序的向量元素之间只能判定是否相等，而有序的元素则能进行比较。</p>
<p>一般而言，如果能够将无序输入向量有序化，则能大幅提升算法的性能，并且有序化所带来的复杂度将小于算法优化减少的复杂度，对于算法的表现是有利的。</p>
<h3 id="有序性甄别"><a href="#有序性甄别" class="headerlink" title="有序性甄别"></a>有序性甄别</h3><p>使用计算邻接无序对数目的方式来判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: disorderd() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;_size ;i++)&#123;</span><br><span class="line">        count += (_elem[i]&gt;_elem[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="低效率唯一化"><a href="#低效率唯一化" class="headerlink" title="低效率唯一化"></a>低效率唯一化</h3><p>没有充分利用有序化序列，调用太多次remove函数会导致效率低下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: uniquify()&#123;</span><br><span class="line">    <span class="keyword">int</span> oldSize = _size; <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;_size)&#123;</span><br><span class="line">        _elem[i<span class="number">-1</span>]==_elem[i]?remove(i):i++; <span class="comment">// remove隐含_size的变化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高效率唯一化"><a href="#高效率唯一化" class="headerlink" title="高效率唯一化"></a>高效率唯一化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: uniquify()&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++j&lt;_size)&#123;</span><br><span class="line">        _elem[i]!=elem[j]?_elem[++i]=_elem[j]:<span class="keyword">continue</span>;<span class="comment">//不知道这里三目可不可以空语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    _size = i;shrink();</span><br><span class="line">    <span class="keyword">return</span> j-i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找与排序算法"><a href="#查找与排序算法" class="headerlink" title="查找与排序算法"></a>查找与排序算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>复杂度约为1.5log（N） 仍有改进空间</p>
<h3 id="Fibonacci查找"><a href="#Fibonacci查找" class="headerlink" title="Fibonacci查找"></a>Fibonacci查找</h3><p>二分查找如果把各种实例画成图似乎是平衡的，但是实际上由于程序每次判断大小时都先判断中点左部，再判断中点右部，导致向左和向右的比较成本不一样（1次 vs. 2次）也因此实际的算法是不平衡的，算法对于[lo,mi)这个区间的元素的查找起来比 (mi,hi)区间更为快速。</p>
<p>为了缓解这个问题，寻求最优解，可以考虑人为的将这个图左右两侧长度设置为不一样的，左边既然搜索的快区间就长一点，右边既然慢就降低难度让它短一点，来追求左右侧的平衡，并尝试是否为最优查找。</p>
<p><img src='fib.png' width = '800' title = 'binary search vs. fibonacci search'></p>
<p>两者的区别只在于mi点的选取，fibonacci取在了黄金分割点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span><span class="params">(T* A, <span class="keyword">const</span> T&amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="function">Fib <span class="title">fib</span><span class="params">(hi-lo)</span></span>;<span class="comment">//创建了fibonacci数列类</span></span><br><span class="line">    <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">        <span class="keyword">while</span> (hi-lo &lt; fib.get()) fib.prev(); <span class="comment">// fib(k-1)</span></span><br><span class="line">        Rank mi = lo + fib.get() - <span class="number">1</span> <span class="comment">//fib(k-1)-1</span></span><br><span class="line">        <span class="keyword">if</span> (e&lt;A[mi]) hi = mi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mi]&lt;e) lo = mi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>Interpolation Search</p>
<p>当一个序列有了近似的规律的时候，可以利用插值的方式确定近似的区间，就好比翻查字典的时候如果是按照A-Z的分布，去寻找W这个部分的单词肯定不会从中间二分查找，而是会按照近似比例的方法去确定一个大致位置。</p>
<ol>
<li>已知lo和hi位置的值，还知道e，计算出e对应的大概位置</li>
<li>比较位置元素和e的大小，确定下一段区间</li>
<li>再次计算e的大概位置</li>
</ol>
<p>如果输入数据不符合均匀独立分布，会变成病态问题，导致时间复杂度升到O（n）</p>
<p>每经过一次比较，插值查找就可以将查找范围从n缩小至$\sqrt{n}$</p>
<p><strong>从二进制字宽方面考虑，一个数值为n的值，它用二进制表示的字宽就是$\log{n}$，而当范围缩小为$\sqrt{n}$时，对应的二进制字宽折半，变成$\frac{1}{2}\log{n}$，因而从字宽角度考虑让字宽小于1位所需要的时间就是$\log\log{n}$</strong></p>
<p><em>缺点</em><br><em>1. 容易受到病态数据影响导致复杂度升高O（n）</em><br><em>2. 需要计算乘法和除法，相比加减法需要的运算更为复杂</em></p>
<h3 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h3><p>binary search；fibonacci search；interpolation search各有特点</p>
<p>使用建议为结合使用：</p>
<ul>
<li>大数据用interpolation迅速减小规模</li>
<li>中等数据使用binary搜索</li>
<li>小数据直接遍历</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: sort(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(rand()%<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: bubblesort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: selectionSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: heapSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: quickSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: mergeSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="气泡排序"><a href="#气泡排序" class="headerlink" title="气泡排序"></a>气泡排序</h2><p>最简单的二重遍历bubblesort没有什么意思，这里增加了一个sorted标志位，用于提前结束bubblesort过程，减少无谓的遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: bubbleSort(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!bubble(Rank lo, Rank hi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Vector&lt;T&gt; :: bubble(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(++lo &lt;  hi)&#123;</span><br><span class="line">        <span class="keyword">if</span> (_elem[lo] &lt; _elem[lo<span class="number">-1</span>]) swap(_elem[lo<span class="number">-1</span>],_elem[lo]);</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步的改进，挪动bubble中hi的位置，进而减少后部已排列元素的扫描</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: bubbleSort(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi=bubble(Rank lo, Rank hi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt; :: bubble(Rank lo, Rank hi)&#123;</span><br><span class="line">    Rank last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++lo &lt;  hi)&#123;</span><br><span class="line">        <span class="keyword">if</span> (_elem[lo] &lt; _elem[lo<span class="number">-1</span>]) swap(_elem[lo<span class="number">-1</span>],_elem[lo]);</span><br><span class="line">        last = lo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法的稳定性</strong>：算法排序前后相同数值的元素大小不变</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一个古老/经典的算法，由冯诺依曼提出，主要思想就是分而治之，可以参考之前算法4里面的文章。</p>
<a href="/2020/06/21/%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" title="排序：归并排序">排序：归并排序</a>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：列表</title>
    <url>/2020/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>邓公《数据结构》第二种主要的数据结构列表。相比静态结构数组，列表的访问修改有着明显差别。</p>
<a id="more"></a>
<h2 id="静态到动态"><a href="#静态到动态" class="headerlink" title="静态到动态"></a>静态到动态</h2><p>数据结构可以分为静态和动态的，列表list是动态储存策略的典型结构，其中元素称为<strong>节点node</strong>，各节点<em>通过指针或者引用彼此联接</em>，在逻辑上构成线性序列。</p>
<p>相邻节点分别为predecessor前驱，successor后继。这种相邻节点<strong>如果存在则必然唯一</strong>。</p>
<p>没有predecessor和successor的称为首（first/front）和末（last/rear）。</p>
<h3 id="从秩到位置"><a href="#从秩到位置" class="headerlink" title="从秩到位置"></a>从秩到位置</h3><p>向量支持循秩访问的方式：访问效率极高O（1）</p>
<p>对于列表而言，可以为每个节点设置秩rank这个属性，通过重载下标操作符访问，但是循秩访问的成本过高，应该改成<strong>循位置访问call-by-position</strong>，通过两两关系找到。</p>
<h3 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h3><p>列表节点node需要独立封装实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ADT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Posi(T) ListNode<span class="meta-string">&lt;T&gt;*</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> &#123;</span> <span class="comment">//简洁起见，完全开放不封装</span></span><br><span class="line">T data;</span><br><span class="line">Posi(T) pred;</span><br><span class="line">Posi(T) succ;</span><br><span class="line">ListNode() &#123;&#125;</span><br><span class="line">ListNode(T e, Posi(T) p=<span class="literal">NULL</span>, Posi(T) s=<span class="literal">NULL</span>)</span><br><span class="line">:data(), pred(p),succ(s)&#123;&#125;</span><br><span class="line">Posi(T) insertAsPred(T <span class="keyword">const</span>&amp; e);</span><br><span class="line">Posi(T) insertAsSucc(T <span class="keyword">const</span>&amp; e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>头head</strong>、<em>首first、末last</em>、<strong>尾trailer</strong>对应秩-1，0，n-1，n 四个节点中两个<strong>哨兵</strong></p>
<h3 id="几种操作"><a href="#几种操作" class="headerlink" title="几种操作"></a>几种操作</h3><p>插入:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_size++;</span><br><span class="line">p-&gt;pred-&gt;succ = new_p;</span><br><span class="line">new_p-&gt;pred = p-&gt;pred;</span><br><span class="line">p-&gt;pred = new_p;</span><br><span class="line">new_p-&gt;succ = p</span><br></pre></td></tr></table></figure>
<p>复制构造：先初始化首尾节点，再不断将要复制的节点作为trailer的前序插入</p>
<p>移除：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p-&gt;pred-&gt;succ = p-&gt;succ;</span><br><span class="line">p-&gt;succ-&gt;pred = p-&gt;pred;</span><br><span class="line">_size--;</span><br></pre></td></tr></table></figure></p>
<p>析构：先清空可见列表（反复删除header后继），再去除头尾节点</p>
<h3 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h3><ol>
<li>首先处理平凡情况</li>
<li>记录原规模，p从首节点开始</li>
<li>在p的r个真前驱中查找与之雷同的节点，删除前面的节点</li>
</ol>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>在唯一化中，有序列表的排列成<em>阶梯型</em>，目标就是保留每一阶阶梯的第一个节点，删除其余节点。复杂度O（n），相比无序列表提升较多。</p>
<p>查找的效率，有序和无序没有什么提高。call-by-pos没有call-by-rank对有序的提升那么大。</p>
<p>RAM模型是循秩，图灵机模型是循位置。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>bubblesort也是一种选择排序，不断选择未排序部分的最值然后将它有序无序的分界点。</p>
<p>这里讨论的是效率更高的选择排序，<strong>减少交换次数</strong>，一趟扫描直接找到最大元素搬运过去！比较适合列表，向量的操作会有很多元素的搬运。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>等于扑克牌排序的时候，每拿一张牌会将它插入到合适的位置。感觉也好适合链表来用。</p>
<p>和选择排序的区别：</p>
<ul>
<li>选择排序总是把操作元素放到有序与无序的边界，无序部分的最大值不能大于有序部分的最小值</li>
<li>插入排序需要自己确定放入有序区间，无序部分与有序部分的大小没有关系</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> List&lt;T&gt;::insertionSort(Posi(T) p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;n;r++)&#123; <span class="comment">// 逐一插入p之后的n个节点</span></span><br><span class="line">        insertAfter(search(p-&gt;data,r,p), p-&gt;data); <span class="comment">//查找+插入</span></span><br><span class="line">        p = p-&gt;succ; remove(p-&gt;pred);<span class="comment">//转向下一节点</span></span><br><span class="line">    &#125;<span class="comment">//n次迭代，每次O（r+1）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用O（1）辅助空间，属于原地算法in-place</span></span><br></pre></td></tr></table></figure>
<p><strong>插入排序最好情形下需要O（n），最坏情形下O(n^2)，选择排序所有情况下都需要O（n^2）</strong></p>
<p>但是很遗憾，计算平均性能的时候，复杂度还是O(n^2)这个级别，最好情况出现的概率很低啊。</p>
<p><em>插入排序所需要的时间=O（inversion+n），逆序对是排序算法主要的工作量</em></p>
<p>这种算法属于input-sensitive输入敏感的算法</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>无约束优化</title>
    <url>/2021/03/10/%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>无约束优化问题的思路和若干解法</p>
<a id="more"></a>
<h2 id="无约束问题的最优值条件"><a href="#无约束问题的最优值条件" class="headerlink" title="无约束问题的最优值条件"></a>无约束问题的最优值条件</h2><p>若目标函数为$min f(x)$</p>
<h3 id="f-x-为凸函数"><a href="#f-x-为凸函数" class="headerlink" title="f(x)为凸函数"></a>f(x)为凸函数</h3><p>充要条件为$\bigtriangledown f(x^*) = 0$</p>
<h3 id="f-x-为一般函数"><a href="#f-x-为一般函数" class="headerlink" title="f(x)为一般函数"></a>f(x)为一般函数</h3><p>必要条件：</p>
<ul>
<li>$\bigtriangledown f(x^*)=0$</li>
<li>$\bigtriangledown ^2 f(x^*) \succeq 0$ 海塞矩阵半正定</li>
</ul>
<p>充分条件：</p>
<ul>
<li>$\bigtriangledown f(x^*)=0$</li>
<li>$\bigtriangledown ^2 f(x^*) \succ 0$ 海塞矩阵正定</li>
</ul>
<h2 id="算法概要"><a href="#算法概要" class="headerlink" title="算法概要"></a>算法概要</h2><p>基本思路是使用迭代下降的算法求解最优化点</p>
<p>分为两种类型</p>
<ol>
<li>线搜索方法Linear Search</li>
<li>信赖域方法Trust Reign</li>
</ol>
<p>区别：</p>
<ol>
<li>线搜索方法是先确定下降方向，再确定下降的步长大小。例如最速下降法和牛顿法。（课堂重点）</li>
<li>信赖域先划定一个下降的区域（类似于确定步长大小），再确定具体的下降方法。<script type="math/tex; mode=display">
min f(x^* + d), \quad s.t. \|d^2\| \le \Delta</script></li>
</ol>
<h2 id="线搜索方法的一般步骤"><a href="#线搜索方法的一般步骤" class="headerlink" title="线搜索方法的一般步骤"></a>线搜索方法的一般步骤</h2><ol>
<li>选取初始化点$x^0$，k=0</li>
<li>验证$x^k$是否满足了终止条件，是则终止</li>
<li>确定迭代的下降方向，$d^k$</li>
<li>确定迭代的步长大小$\alpha$，满足$f(x^k +\alpha d^k) &lt; f(x^k)$</li>
<li>$x^{k+1} = x^k + \alpha d^k$，$k = k+1$,转step1</li>
</ol>
<p>终止条件可以有多种选择，例如函数值差足够小，梯度足够小，或者步长足够小</p>
<p>迭代步长的选择，是在方向确定之后，找一个能够使$\phi (x)=f(x^k +\alpha d^k)$下降最多的步长，涉及到又一个一元函数求解最小值的问题，有很多种方法去确定步长</p>
<p>线搜索方法还要讨论算法是否收敛的问题</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title>李群和李代数</title>
    <url>/2021/03/05/%E6%9D%8E%E7%BE%A4%E5%92%8C%E6%9D%8E%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<p>李群和李代数的知识记录，为SLAM后端优化做基础</p>
<a id="more"></a>
<h2 id="群和李群"><a href="#群和李群" class="headerlink" title="群和李群"></a>群和李群</h2><p>群是<strong>一种集合</strong>加上<strong>一种运算</strong>的代数结构。如果把集合记作$A$，把运算记为$\cdot$，则群可以记为$G={ A,·}$。群要去运算满足以下四个条件：</p>
<ol>
<li>封闭性，运算之后的结果仍属于集合。$\forall a_1,a_2 \in A, a_1 \cdot a_2 \in A$</li>
<li>结合律：$\forall a_1, a_2, a_3 \in A \quad (a_1 \cdot a_2)\cdot a_3 = a_1 \cdot (a_2 \cdot a_3)$</li>
<li>幺元：$\exist a_0 \in A \quad s.t  \quad a_0 \cdot a_1 = a_1 \cdot a_0 = a_1$</li>
<li>逆运算：$\forall a\in A, \quad \exist a^{-1} \in A, \quad s.t \quad a \cdot a^{-1} = a_0$</li>
</ol>
<p>封、结、幺、逆</p>
<p>常见的群：</p>
<ol>
<li>一般线性群，可逆矩阵和乘法运算构成$GL(n)$。</li>
<li>特殊正交群。正交矩阵，对于乘法运算构成群。旋转矩阵$R$所在的$SO(3),SO(2)$就是该群。</li>
<li>特殊欧式群。变换矩阵$T$属于的$SE(3), SE(2)$。</li>
</ol>
<p>李群的李是指，该群具有连续（光滑）的性质，像整数群就不属于李群。$SO(3) \quad SE(3)$都是李群。<br><em>每一个李群都有相应的李代数。</em></p>
<h2 id="李代数"><a href="#李代数" class="headerlink" title="李代数"></a>李代数</h2><p>李代数so3的引出是通过对旋转矩阵的导数计算得到的。</p>
<script type="math/tex; mode=display">R(t)R(t)^{T} = I</script><p>对时间求导，移项得到</p>
<script type="math/tex; mode=display">\dot R(t)R(t)^{T} = -[\dot R(t)R(t)^{T}]^{T}</script><p>这样可以看出$\dot R(t)R(t)^{T}$是一个反对称矩阵，<em>对于每一个反对称矩阵可以找到一个与之对应的向量$\phi(t)$</em>。</p>
<p>表示为</p>
<script type="math/tex; mode=display">\dot R(t)R(t)^{T} = \phi(t)^{\land}</script><p>等式两边右乘$R(t)$，正交矩阵转置乘原矩阵为单位阵</p>
<script type="math/tex; mode=display">\dot R(t) = \phi (t)^\land R(t)</script><p>因此得到了对旋转矩阵求导等于左乘一个$\dot R(t)R(t)^{T}$的对应向量，这正是与$SO(3)$对应的李代数$so(3)$.</p>
<p>进一步，对$R(t)$在零附近$t=0$进行泰勒展开，注意$R(t_0) = I$</p>
<script type="math/tex; mode=display">R(t) = R(t_0) + \dot R(t_0) (t-t_0) = R(t_0) + \phi(t_0)^{\land}R(t_0)(t-t_0)=I + \phi(t)^{\land}t</script><blockquote>
<p>我们看到$\phi$ 反映了$ R$的导数性质，故称它在$SO(3)$ 原点附近的正切空间(TangentSpace) 上。同时在$t0$ 附近，设$\phi$保持为常数$\phi(t_0) = \phi_0。$</p>
</blockquote>
<script type="math/tex; mode=display">\dot R(t) = \phi_0^\land R(t)</script><p>微分方程的解为$R(t) = exp(\phi_0)^\land t$</p>
<h3 id="李代数定义"><a href="#李代数定义" class="headerlink" title="李代数定义"></a>李代数定义</h3><p>每个李群都有对应的李代数</p>
<p>李代数由一个集合$\mathbb{V}$，一个数域$\mathbb{F}$，一个二元运算$[,]$组成。</p>
<p>李代数需要满足四个性质：</p>
<ol>
<li>封闭性，李括号运算后仍属于集合</li>
<li>双线性，X，Y，Z任意两者线性运算后与第三者进行李括号运算，可以把线性系数提出来做两次李括号运算相加。</li>
<li>自反性，自己与自己运算结果为0</li>
<li>雅可比等价，X，Y，Z三者两两做李括号运算后，再与第三者做李括号运算，可以得到三个结果，三结果相加等于零</li>
</ol>
<p>三维向量$\mathbb{R}^3$上定义的叉积$\times$是一种李括号，因此构成了一个李代数$g =[\mathbb{R}^3 , \mathbb{R}, \times];$</p>
<blockquote>
<p>李代数$so(3)$是一个三维向量，但是因为和反对称矩阵的关系紧密，常常对此两者不加区分，统称为$so(3)$</p>
</blockquote>
<p><strong>利用李代数得到反对称矩阵，再做指数映射可以得到李群</strong></p>
<h3 id="与李群转换关系"><a href="#与李群转换关系" class="headerlink" title="与李群转换关系"></a>与李群转换关系</h3><p>矩阵的指数映射定义如下：</p>
<script type="math/tex; mode=display">e^X = \sum^{\infin}_{0} \frac{1}{k!}X^k</script><p>SE(3)也有相应的李代数se(3)，属于6维向量空间内，其“类反对称矩阵”（实际上不是反对称，只是一个6维向量变成矩阵的映射关系）是一个$\mathbb{R}^{4\times 4}$的四维矩阵。</p>
<p><img src='so3.png' width='700' title='李代数指数映射的展开'></p>
<p>对指数映射进行展开，可以得到罗德里格斯公式，表明so(3)实际上是由旋转向量组成的空间</p>
<p><img src='so3se3.png' width='700' title='李群和李代数的对应关系'></p>
<h2 id="BCH公式"><a href="#BCH公式" class="headerlink" title="BCH公式"></a>BCH公式</h2><p>研究李代数的目的是研究李群，或者说为了利用相关的转化关系简化李群的相关运算。</p>
<p>两个李群中的矩阵进行乘法的时候，李代数并不是简单的对应指数乘法，而是会表达为一个复杂的公式，该公式名叫Baker-Campbell-Hausdorff公式，简称为BCH公式。</p>
<p><img src='bch.png' width='600' title='BCH formula'></p>
<p>BCH公式的包含项很多，这里的前几项已经可以看出</p>
<blockquote>
<p>当处理两个矩阵指数之积时，它们会产生一些由李括号组成的余项。</p>
</blockquote>
<p><img src='bch2.png' width='600' title='BCH formula2'></p>
<p>当$\phi_1$或者$\phi_2$是一个小量的时候，可以忽略高阶项，近似得到上述的扰动模型，式子1为左扰动模型，式子2为右扰动模型。使用时需要注意。</p>
<blockquote>
<p>假定对某个旋转$R$，对应的李代数为$ϕ$。我们给它左乘一个微小旋转，记作$ΔR$，对应的李代数为$Δϕ$。那么，在李群上，得到的结果就是ΔRR，而在李代数上，根据BCH近似，为：$J^{-1}_l (ϕ)Δϕ + ϕ$。合并起来，可以简单地写成：</p>
<script type="math/tex; mode=display">exp(\Delta\phi^\land)exp(\phi^\land) = exp((\phi + J^{-1}_l(\phi)\Delta\phi)^\land)</script></blockquote>
<h2 id="SO3的求导"><a href="#SO3的求导" class="headerlink" title="SO3的求导"></a>SO3的求导</h2><p>位姿求解问题的数学表达如下</p>
<ol>
<li>观察世界坐标系下位置p的点，得到观察数据z，传感器噪声为w<script type="math/tex; mode=display">z = Tp +w</script></li>
<li>理想观测与实际的误差用e表示<script type="math/tex; mode=display">e = z- Tp</script></li>
<li>得到了N个这样的点的观测数据，目标为最小化误差函数J，转化为最优化问题，寻找最小二乘误差对应的位姿$T$<script type="math/tex; mode=display">\min_T J(T) = \sum^N_i \| z_i - Tp_i\|</script>求解这样的最优化问题，需要求$J$对$T$的导数</li>
</ol>
<blockquote>
<p>然而，SO(3); SE(3) 上并没有良好定义的加法，它们只是群。如果我们把T 当成一个普通矩阵来处理优化，那就必须对它加以约束。而从李代数角度来说，由于李代数由向量组成，具有良好的加法运算。因此，使用李代数解决求导问题的思路分为两种：</p>
<ol>
<li>用李代数表示姿态，然后对根据李代数加法来对李代数求导。</li>
<li>对李群左乘或右乘微小扰动，然后对该扰动求导，称为左扰动和右扰动模型。</li>
</ol>
</blockquote>
<p>使用扰动模型的求导结果更为简洁，给出SO3的求导结果。</p>
<script type="math/tex; mode=display">\frac{\partial (Rp)}{\partial\phi} = -(Rp)^\land</script><p>使用第一种方法会在上述结果右侧再加一个雅可比矩阵$J_l$</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>现代控制理论（1）绪论与控制系统建模</title>
    <url>/2020/05/02/%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%EF%BC%881%EF%BC%89%E7%BB%AA%E8%AE%BA%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<p>现代控制理论是控制理论研究人员在20世纪中期所提出的一批关于控制理论问题的成果的总称。在控制理论中具有承上启下的作用-承接经典控制理论，启发后续真*现代控制理论，例如模糊控制/鲁棒控制理论。</p>
<p>本文内容为现代控制理论课程的回顾和总结，第一部分为绪论和控制系统建模。</p>
<a id="more"></a>
<blockquote>
<p><strong>大约一年后2021.3.3来更新了，这门本研互选的课最终没能在本科阶段上完，所以研一下学期我又来“重修”了哈哈哈哈</strong></p>
</blockquote>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="现代控制理论的特点和优势"><a href="#现代控制理论的特点和优势" class="headerlink" title="现代控制理论的特点和优势"></a>现代控制理论的特点和优势</h3><p>相比经典控制理论，即自动控制理论课程中所学的基于传递函数、零极点与特征根等的控制理论方法，现代控制理论具有以下特点和优势：</p>
<ul>
<li>数学模型方面：现代控制理论是一种<strong>使用内部描述模型的内部空间法</strong>。</li>
<li>适用于<strong>多输入多输出系统</strong>，可以解决初值<strong>非零问题</strong>。</li>
<li>结构特性方面：解决了是系统可控性和不确定性问题。</li>
<li>设计方法方面：可以得到定量的，最优的控制解。</li>
</ul>
<blockquote>
<p>通过目前几节课的学习（截止5-2共学习了8节课程），现代控制理论确实让我感觉相比原有经典控制理论<strong>更加科学</strong>，这种感觉来源于现代控制理论相比自控，系统的细节更为丰富（内部），能够处理MIMO，优化有据可循，而不是试凑（吐槽自控进行系统设计的方法，基本上就是试凑，瞎碰上成就用，不成就重新加个模块调个系数，令人头大）。</p>
<p>当然，自控在处理一些简单问题时足够使用，能够简化问题</p>
</blockquote>
<p>现代控制理论的代表人物：庞德里亚金 别尔曼 卡尔曼</p>
<h3 id="现代控制理论的几个模块"><a href="#现代控制理论的几个模块" class="headerlink" title="现代控制理论的几个模块"></a>现代控制理论的几个模块</h3><ul>
<li>线性多变量理论： 能控性/能观测性，系统的极点配置，状态观测器设计和抗干扰问题（本书重点）</li>
<li>最优控制理论： 已知数学模型，寻找最优控制函数</li>
<li>最优估计理论： 已知数学模型，<strong>从被噪声干扰的观测数据中确定</strong>系统状态（卡尔曼滤波）</li>
<li>系统辨识和参数估计： 基于输入输出数据辨识系统参数</li>
</ul>
<h3 id="自控里幅值裕度和相角裕度在说什么"><a href="#自控里幅值裕度和相角裕度在说什么" class="headerlink" title="自控里幅值裕度和相角裕度在说什么"></a>自控里幅值裕度和相角裕度在说什么</h3><p><img src='bode.jpg' width='600' title='赋值裕度和相角裕度'></p>
<p>上面的bode图描述的是开环系统随着输入频率变化，传递函数赋值和相角的变化，即开环频率响应。</p>
<p>幅值裕度是相角为-180度的时候，赋值距离0db的大小，比0db低为正赋值裕度；相角裕度是当赋值裕度为0db的时候，相角高于-180度的大小，比-180度大则为正相角裕度。</p>
<p><img src='sys.gif' width='600' title='一个系统'></p>
<p>谈论裕度时，我们必须以闭环系统为讨论基础，一个闭环的单位负反馈系统，输出会乘以-1加入到输入端。考虑一个输入的正弦信号（所有的信号都可以通过傅里叶分解变成正弦信号的集合），对于相角为-180度之前的输出信号，反馈会起到降低输入信号的副作用，而-180度的时候，反馈信号会变成对输入信号的增益（乘以-1负负得正），导致系统变成正反馈，容易产生发散，因此-180度是一个判断系统稳定性的关键性节点。</p>
<p>为了让系统稳定，我们应该尽量保证：</p>
<ol>
<li>-180度时幅值增益越小越好，即db值为负的越厉害越好（即正幅值裕度）</li>
<li>0db对应的相角应该离-180度越远越好，保证到-180度的时候，增益已经衰减了微不足道的大小，即便是正反馈也掀不起什么波浪（正相角裕度）</li>
</ol>
<p>用一个比喻来说，如果将-180度这个角度认为是做坏事，0度对应做好事，那么上述两条变成</p>
<ol>
<li>不得不做坏事的时候，要做一个能力差（幅值增益小）的坏人</li>
<li>能力还没有变弱（0db以上）的时候，要做一个远离恶的好人（离-180度远点）</li>
</ol>
<p>你可能也会疑惑，只看-180度是不是太粗糙了，相角是别的角度的时候也可能产生正的增益。这种思考完全是有道理的，下面这句话对我有所启发</p>
<blockquote>
<p>使用增益和相位裕量是因为它们简单，而不是因为它们是稳定性的理想度量。</p>
</blockquote>
<p>总的来说，自控里用裕度判断稳定性还是为了简化难度，因为-180度时的正反馈作用最强，如果能保证此时的反馈不至于让系统发散，则对于系统的稳定性就有了一个比较放心的判断。</p>
<p>更加准确判断稳定性的方法，也请看后续现代控制理论的方法！</p>
<h3 id="如何判断我的系统是否接近0-dB，-180度？"><a href="#如何判断我的系统是否接近0-dB，-180度？" class="headerlink" title="如何判断我的系统是否接近0 dB，-180度？"></a>如何判断我的系统是否接近0 dB，-180度？</h3><p>有两个迹象：</p>
<ol>
<li>闭环幅度响应中的幅度较大，以及</li>
<li>开环频率响应接近0 dB，-180度</li>
</ol>
<p>很容易看到较大的闭环幅度响应。大响应是任何大于6dB的值。</p>
<p>相角裕度至少要有30度，才有可能稳定。</p>
<h2 id="控制系统的数学模型"><a href="#控制系统的数学模型" class="headerlink" title="控制系统的数学模型"></a>控制系统的数学模型</h2><h3 id="状态空间表达式"><a href="#状态空间表达式" class="headerlink" title="状态空间表达式"></a>状态空间表达式</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li>状态：能够表征系统的物理量</li>
<li>状态变量/向量：确定系统状态所需的<strong>最小一组变量</strong>，这些变量构成一个向量，<strong>具体形式没有要求</strong></li>
<li>状态空间：以选定的状态变量为坐标轴，生成的正交空间（状态向量所在的线性空间）</li>
</ul>
<p>状态空间表达式是一个方程组，简单来说包含两部分</p>
<ul>
<li>状态方程，描述状态变量导数与状态变量和输入的关系</li>
<li>输出方程，描述输出量与状态变量和输入的关系</li>
</ul>
<p>一个例子如下：</p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} \frac{di(t)}{dt} \\ \frac {du_c(t)}{dt} \end{matrix} \right] = \left[  \begin{matrix} -\frac{R}{L} & -\frac{1}{L} \\  \frac{1}{C}  & 0 \end{matrix}\right] \left[  \begin{matrix} i(t) \\ u_c(t)\end{matrix}\right]+\left[  \begin{matrix} \frac{1}{L} \\ 0 \end{matrix}\right] u(t)</script><p>这就是一个<strong>状态方程（组）</strong>，$i(t)$和$u_c(t)$就是两个状态变量，等式的左边是状态变量的导数，最右侧是输入量$u(t)$</p>
<p>现在如果我们选取$u_c(t)$同时作为该系统的输出变量，那么就可以写出输出方程：</p>
<script type="math/tex; mode=display">
u_c(t) = [0 \quad 1] \left[ \begin{matrix} i(t) \\u_c(t)\end{matrix}\right]</script><blockquote>
<p>毫无疑问，系统的状态变量也可以是输出量，反之亦然</p>
</blockquote>
<h4 id="状态空间表达式的几个特点"><a href="#状态空间表达式的几个特点" class="headerlink" title="状态空间表达式的几个特点"></a>状态空间表达式的几个特点</h4><p><strong>*形式不唯一</strong>，可以随状态变量选取而任意改变*</p>
<ul>
<li><p>状态方程 </p>
<ul>
<li>状态方程是一阶微分方程（组）；</li>
<li>状态方程是状态空间分析法的基本数学方程；</li>
<li>状态方程具有非唯一性；</li>
<li>状态方程中不含有输入变量的导数</li>
</ul>
</li>
<li><p>输出方程</p>
<ul>
<li>输出方程是代数方程（组）；</li>
<li>输出方程是状态空间分析法的基本数学方程；</li>
<li>输出方程具有非唯一性；</li>
</ul>
</li>
</ul>
<p>抽象化形式</p>
<script type="math/tex; mode=display">
\dot{X} = AX + BU \\</script><script type="math/tex; mode=display">
Y = CX+DU</script><blockquote>
<p>$A$系数矩阵 $B$输入矩阵 $C$输出矩阵 $D$前馈矩阵 </p>
</blockquote>
<h3 id="状态变量图"><a href="#状态变量图" class="headerlink" title="状态变量图"></a>状态变量图</h3><p>一种类似于传递函数系统分析时所画的图，绘制时有一些原则和思路。 状态变量图只有加法器，比例器和积分器。绘制时，先针对每一个一阶微分方程单独画（以积分器为基础），然后再依次连接这些模块。</p>
<h3 id="建模思路"><a href="#建模思路" class="headerlink" title="建模思路"></a>建模思路</h3><ol>
<li>确定正方向</li>
<li>寻找可观测量与特征量</li>
<li>利用物理规律写出方程</li>
<li>确定输入、输出与状态变量</li>
</ol>
<blockquote>
<p>没办法也不应该以微分器作为状态图中的一部分</p>
</blockquote>
<h2 id="列出状态空间表达式"><a href="#列出状态空间表达式" class="headerlink" title="列出状态空间表达式"></a>列出状态空间表达式</h2><p>难点主要在于等式右侧有输入变量的导数项时，需要在状态变量里增加输入项。第一次看书上一个三阶方程的处理方法时，我对设置3个状态变量没有异议，但对于为什么要加一个额外的中间变量$x_4 = \dot x_3 - \beta_3 u$不理解，感觉多引入了一个待定系数。</p>
<p>实际试了一下，如果只用$\beta_0 \beta_1 \beta_2$三个待定系数，将状态变量x代替y的导数回代，会得到四个方程（分别与输入项的系数相等），使得问题变成超正定（未知数少于方程），有可能无解。因此有必要多设置一个待定系数，保证可以求出唯一解。</p>
<p>除了待定系数法，还可以利用拉普拉斯变换将问题转化到频域，然后利用中间变量Z(s)将输入输出分离来求解状态空间表达式。</p>
<h2 id="传递函数矩阵"><a href="#传递函数矩阵" class="headerlink" title="传递函数矩阵"></a>传递函数矩阵</h2><p>对状态空间表达式的一般形式做拉普拉斯变换，然后通过消去$X(s)$得到传递函数</p>
<script type="math/tex; mode=display">G(s) = C[sI-A]^{-1}B+D = C\frac{adj[sI-A]}{det[sI-A]}B+D</script><ol>
<li>无零极点对消时：A的特征值=传递函数的极点</li>
<li>有零极点对消时：<pre><code>    A的特征值=传递函数的极点+对消的极点
</code></pre></li>
</ol>
<p>$G(s)$是一个矩阵的时候，$G_{ij}$代表第$i$个输出值对第$j$个输入值的传递函数</p>
<p><strong>正则的有理传递函数</strong>：$s-&gt;\infin$若传递函数（矩阵内元素）是有限常量，则称为传递函数正则。非正则的传递函数不可以应用，因为那样会放大高频噪声</p>
<h2 id="离散系统的数学描述"><a href="#离散系统的数学描述" class="headerlink" title="离散系统的数学描述"></a>离散系统的数学描述</h2><p>离散系统也可以写出状态空间表达式，状态空间表达式里包含的不再是微分方程而是差分方程。</p>
<script type="math/tex; mode=display">x(k+1)=Gx(k)+Hu(k)</script><p>我们可以用差分和微分的近似关系来分析一下G和A的关系</p>
<script type="math/tex; mode=display">\dot x(kT) = \frac{x(k+1)-x(k)}{T} = Ax(k)+bu(k)</script><script type="math/tex; mode=display">x(k+1) = (I+AT)x(k)+bTu(k)</script><p>可以看到$G=I+AT,H=bT$，在T比较小的时候G可以近似为单位矩阵</p>
<h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>选取不同的状态变量，能够获得不同的系数矩阵、输出矩阵等，线性变换的目的是将形形色色的矩阵统一成标准的、方便后续计算的矩阵-标准型矩阵。</p>
<script type="math/tex; mode=display">
\overline{x} = Px,\quad x = P^{-1}\overline{x}</script><script type="math/tex; mode=display">\overline{x} = PAP^{-1}\overline{x} + PBu</script><script type="math/tex; mode=display">y = CP^{-1}\overline{x}+Du</script><p>线性变换：</p>
<ol>
<li>不改变系统的特征值</li>
<li>不改变系统的传递矩阵</li>
</ol>
<p>几种较好的标准型矩阵</p>
<h3 id="对角型"><a href="#对角型" class="headerlink" title="对角型"></a>对角型</h3><p>使用特征向量矩阵S</p>
<script type="math/tex; mode=display">\Lambda = S^{-1}AS = PAP^{-1}</script><h3 id="约当型"><a href="#约当型" class="headerlink" title="约当型"></a>约当型</h3><p>A存在重复的特征值，并且特征向量的数量小于n时，不能进行对角化，只能化为约当型矩阵$J$</p>
<p>约当型矩阵的对角线是特征值，上三角阵</p>
<h3 id="模态矩阵"><a href="#模态矩阵" class="headerlink" title="模态矩阵"></a>模态矩阵</h3><p>特征值为共轭复数的时候，矩阵可以变为模态阵</p>
<p>若特征值$\lambda _1 = \sigma +j \omega, \quad \lambda _2 = \sigma -j \omega$</p>
<p>模态阵的形式为：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
\sigma & \omega \\
-\omega & \sigma
\end{pmatrix}</script><h2 id="组合系统"><a href="#组合系统" class="headerlink" title="组合系统"></a>组合系统</h2><p>涉及到两个系统的串联，并联，以及一个作为另一个的反馈</p>
<ul>
<li>串联时系统1的输出为系统2的输入</li>
<li>并联时输入相同，输出等于两者各自输出之和</li>
<li><strong>反馈时</strong>需要避免<strong>代数环</strong>的出现，两个系统中不能都有输出矩阵，否则无法求出结果</li>
</ul>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
        <tag>控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Cross-Entropy Loss, Softmax Loss, Focal Loss等名词</title>
    <url>/2020/04/24/%E7%90%86%E8%A7%A3Cross-Entropy-Loss-Softmax-Loss-Focal-Loss%E7%AD%89%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<p><strong>Cross-Entropy Loss</strong> 中文翻译为交叉熵损失，是一种常用的损失函数，但在不同的论文与机器学习框架中常会被叫做不同的名字，本文将对这些令人迷惑的名称以及一些其他常见的损失函数进行说明。</p>
<a id="more"></a>
<p><img src="intro.png" width = "800" title = '概要' alt="概要"/></p>
<p>首先说明一些概念</p>
<h2 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h2><p>按照标签类型不同进行区分</p>
<h3 id="Multi-Class-Classification多类别分类"><a href="#Multi-Class-Classification多类别分类" class="headerlink" title="Multi-Class Classification多类别分类"></a>Multi-Class Classification多类别分类</h3><p><strong>每个目标只属于一个类别</strong>。若总计有数目为$C$的类别，CNN网络的输出（Scores）将会是一个维度为$C$的向量$s$。输入样本对应的标签或真实值（groundtruth）是一个one-hot vector，只有目标类别为1，其余$C-1$类均为0。</p>
<h3 id="Multi-Label-Classification多标签分类"><a href="#Multi-Label-Classification多标签分类" class="headerlink" title="Multi-Label Classification多标签分类"></a>Multi-Label Classification多标签分类</h3><p>s<br><strong>每个目标可以属于多个类别</strong>。例如，某样本可以同时属于human和woman两个类别。若总计有数目为$C$的类别，CNN网络的输出（Scores）与上述任务相同，是一个$C$维的向量$s$。不同的是，输入样本的标签将有多个1值，代表目标属于多个种类。</p>
<p><img src='multiclass_multilabel.png' width = '800' title = 'types of tasks'></p>
<h2 id="输出层激活函数"><a href="#输出层激活函数" class="headerlink" title="输出层激活函数"></a>输出层激活函数</h2><p>通常在计算loss之前会作用在CNN结果向量$s$上的激活函数</p>
<h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p>一种常见的激活函数，效果是可以将任意数值限制在（0，1）区间之内。使用时会作用于向量$s$的每一个元素$s_{i}$也被称为<strong>logistic function</strong>。</p>
<script type="math/tex; mode=display">
f(s_{i}) = \frac{1}{1+e^{-s_{i}}}</script><h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><p>首先需要明确的是，单独的Softmax是一种函数而非一种loss。它的效果是让输入向量$s$的每一个元素$s_{i}$都处于（0，1）区间之内，并且各元素之和为1。</p>
<script type="math/tex; mode=display">
f(s_{i}) = \frac{e^{s_{i}}}{\sum^{C}_{j} e^{s_{j}}}</script><p>上式中，$C$为输出向量维度</p>
<blockquote>
<p>训练过程和预测中都会在输出向量后使用激活函数</p>
</blockquote>
<h2 id="各种Loss函数"><a href="#各种Loss函数" class="headerlink" title="各种Loss函数"></a>各种Loss函数</h2><h3 id="Cross-Entropy-Loss交叉熵损失函数"><a href="#Cross-Entropy-Loss交叉熵损失函数" class="headerlink" title="Cross-Entropy Loss交叉熵损失函数"></a>Cross-Entropy Loss交叉熵损失函数</h3><p>事实上，这里讨论所有Loss的都是Cross-Entropy家族里面的成员。交叉熵损失CE Loss定义为：</p>
<script type="math/tex; mode=display">
CE = -\sum_{i}^{C}t_{i}log(s_{i})</script><p>其中$t<em>{i}$和$s</em>{i}$代表的是label向量$t$和CNN预测的向量$s$的对应元素。在计算CE损失前，通常会有一个激活函数(sigmoid/softmax)$f$作用于输出向量上。</p>
<p>在二元分类问题中（即目标只需判断属于或不属于，$C=2$）,CE Loss也会被写作Binary Cross-Entropy Loss:</p>
<script type="math/tex; mode=display">
BCE = -\sum_{i=1}^{C=2}t_{i}log(f(s_{i})) = -t_{1}log(f(s_{1}))-(1-t_{1})log(1-f(s_{1}))</script><p><strong>Logistic Loss</strong>和<strong>Multinomial Logistic Loss</strong>是Cross-Entropy Loss的别称。</p>
<p>对应机器学习框架中一些<strong>不带有激活函数</strong>的：</p>
<ul>
<li>Caffe：Multinomial Logistic Loss Layer。仅限于Multi-Class Classification问题，不支持Multi-Labels。</li>
<li>PyTorch：BCELoss。仅限于二元分类。</li>
<li>TensorFlow：log_loss</li>
</ul>
<h3 id="Categorical-Cross-Entropy-Loss分类交叉熵损失函数"><a href="#Categorical-Cross-Entropy-Loss分类交叉熵损失函数" class="headerlink" title="Categorical Cross-Entropy Loss分类交叉熵损失函数"></a>Categorical Cross-Entropy Loss分类交叉熵损失函数</h3><p>该损失函数也被叫做Softmax Loss，可以认为是Softmax和Cross-Entropy Loss两个函数的叠加。专门用于处理Multi-Class问题，输出向量的每一个元素代表每一种类别的概率。</p>
<p><img src='softmax_CE_pipeline.png' width = '800' title = 'softmax loss'></p>
<p>由于Multi-Class的label是一个one-hot vector，因此计算损失的时候只需要计算$t<em>{i}=t</em>{p}=1$那一项，其余的交叉熵由于label元素为0而乘积都为0，不需要计算</p>
<script type="math/tex; mode=display">
CE = -log\left ( \frac{e^{s_{p}}}{\sum_{j}^{C} e^{s_{j}}} \right )</script><p>上式中$s_{p}$是输出结果中对应真实类别的那一项</p>
<p>定义了Softmax Loss后就会进行反向传播的梯度计算，虽然Loss中的分母只有$s<em>{p}$ , 但是需要对输出层每一个neuron计算gradient，因为损失分母中仍然存在着这些项目。梯度计算分为对非零元素$s</em>{p}$以及对其他零元素</p>
<p>对$s_{p}$</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial{s_{p}}}\left(-log\left ( \frac{e^{s_{p}}}{\sum_{j}^{C}s^{s_{j}}}\right)\right) = \left(\frac{e^{s_{n}}}{\sum_{j}^{C}e^{s_{j}}}-1 \right)</script><p>对$s_{n}$</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial s_{n}} \left (-log\left ( \frac{e^{s_{p}}}{\sum_{j}^{C} e^{s_{j}}} \right ) \right ) = \left ( \frac{e^{s_{n}}}{\sum_{j}^{C}e^{s_{j}}}\right )</script><p>对应机器学习框架中：</p>
<ul>
<li>Caffe：SoftmaxWithLoss Layer。仅限于Multi-Class Classification问题，不支持Multi-Labels。</li>
<li>PyTorch：CrossEntropyLoss。仅限Multi-Class问题</li>
<li>TensorFlow：softmax_cross_entropy。仅限Multi-Class问题</li>
</ul>
<h3 id="Binary-Cross-Entropy-Loss"><a href="#Binary-Cross-Entropy-Loss" class="headerlink" title="Binary Cross-Entropy Loss"></a>Binary Cross-Entropy Loss</h3><p>前面已经简单提到了BCE这种形式，它也被叫做Sigmoid Cross-Entropy Loss。</p>
<script type="math/tex; mode=display">
BCE = -\sum_{i=1}^{C=2}t_{i}log(f(s_{i})) = -t_{1}log(f(s_{1}))-(1-t_{1})log(1-f(s_{1}))</script><p><img src='sigmoid_CE_pipeline.png' width = '800' title = 'sigmoid loss'></p>
<p>形式是比较清晰明了的，输出和真实值实际上只有一个$s<em>{1}$和$t</em>{1}$，但是因为是二分类问题，在$label t<em>{1}=0$的时候也要计算损失，因而存在一个隐含的元素$s</em>{2}, s<em>{1}+s</em>{2}=1$</p>
<p>计算梯度：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial s_{i}} (CE(f(s_{i}))) = t_{1}(f(s_{1})-1)+ (1-t_{1})f(s_{1})</script><h3 id="Focal-Loss"><a href="#Focal-Loss" class="headerlink" title="Focal Loss"></a>Focal Loss</h3><p><strong>Focal Loss</strong>是由Facebook Lin et al.提出的一种损失函数，RetinaNet使用了这种损失函数。Focal Loss是一种交叉熵损失函数，它能够根据分类结果调整损失函数各部分的权重。基本思路是：如果样本已经被CNN正确的标注，那么它对于Loss的贡献或者说权重比例将会降低，作者认为这种策略可以帮助算法集中精力在哪些被错误分类的样本上。</p>
<p>Focal Loss使用了sigmoid激活函数，因此可以FL也可以被视作一个Binary Cross-Entropy Loss。FL定义如下：</p>
<script type="math/tex; mode=display">
FL = -\sum_{i=1}^{C=2}(1-s_{i})^{\gamma}t_{i}log(s_{i})</script><p>$\gamma&gt;=0$是一个调节因子，$\gamma=0$时FL退化为BCE</p>
<p><img src='focal-loss.png' width = '800' title = 'focal-loss'></p>
<p>由图上可以看出，对于概率越小的情况，Focal Loss中的$\gamma$对于正确分类样本的Loss降低越为明显。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提及的诸多LossFunction都由最基本的Cross-Entropy Loss演化得到，在不同的框架中他们有着不同的名字。</p>
<ul>
<li>Cross-Entropy Loss<ul>
<li>别名:Logistic Loss &amp; Multinomial Logistic Loss,最基本的形式</li>
</ul>
</li>
<li>Categorical Cross-Entropy Loss<ul>
<li>别名:Softmax Loss = Softmax+CE</li>
</ul>
</li>
<li>Binary Cross-Entropy Loss<ul>
<li>别名:Sigmoid Cross-Entropy Loss = Sigmoid+CE</li>
</ul>
</li>
<li>Focal Loss<ul>
<li>在CE每一个项目前增加了系数因子</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>相机模型</title>
    <url>/2021/03/06/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>针孔相机模型，若干种坐标系的转换方法<br><a id="more"></a></p>
<h2 id="几个坐标系"><a href="#几个坐标系" class="headerlink" title="几个坐标系"></a>几个坐标系</h2><p>针孔相机模型就是小孔成像模型，通过针孔后目标在成像平面上形成了一个倒立（通常缩小）的像。</p>
<p>借用十四讲里的图：<br><img src='model.png' width=600 title='针孔相机模型'></p>
<p>上图描述了相机坐标系中的$P$点经转换后在图像坐标系$x’O’y’$成像的过程。</p>
<p>需要注意，上图里$x’O’y’$图像坐标系的原点$O’$是成像平面与过光心直线的交点，下面要说的像素坐标系与图像坐标系在同一个平面上，但标度和原点不同，此图并没有画出。</p>
<p><img src='ouv.png' width=600 title='像素坐标系'></p>
<p>上图为从坐在相机里内向外看的视角，<strong>像素坐标系</strong>的原点在图像左上角，$u$轴向右，$v$轴向下；<strong>图像坐标系</strong>原点在过光心直线与平面交点，$x$轴向右，$y$轴向下。</p>
<p>顺便提及，<strong>相机坐标系</strong>的原点设置在光心处，同向看去，$Z$轴朝外，$X$轴向右，$Y$轴向下。（另外俩坐标系没有Z轴）</p>
<hr>
<h2 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h2><p>相机坐标系$(X,Y,Z)$至图像坐标系$(x,y)$</p>
<script type="math/tex; mode=display">\frac{Z}{f}=\frac{X}{x}=\frac{Y}{y}</script><p>$f$为相机焦距</p>
<p>图像坐标系$(x,y)$至像素坐标系$(u,v)$</p>
<script type="math/tex; mode=display">\left\{
    \begin{array}{lr}
    u = \alpha x + c_x & \\
    v =  \beta y + c_y& \\
    \end{array}

    \right.</script><p>$\alpha 和 \beta$是像素每米的转换比例，$c_x 和c_y$是两个坐标系原点的平移距离</p>
<p>再看一次</p>
<p><img src='ouv.png' width=600 title='像素坐标系'></p>
<p>由以上两个转换推出相机坐标系$(X,Y,Z)$至像素坐标系$(u,v)$</p>
<script type="math/tex; mode=display">\left\{
    \begin{array}{lr}
    u = f_x \frac{X}{Z} + c_x & \\
    v =  f_y \frac{Y}{Z} + c_y& \\
    \end{array}

    \right.</script><script type="math/tex; mode=display">f_x = \alpha f, \quad f_y =\beta f</script><p>使用<em>齐次坐标</em>可以将上述表达变为矩阵形式，以及再加上相机坐标系到世界坐标系的转换</p>
<script type="math/tex; mode=display">
\left[
    \begin{array}{lr}
    u\\
    v\\
    1\\
    \end{array}
    \right]
= \frac{1}{Z}
\left[
    \begin{array}{lr}
    f_x & 0 & c_x\\
    0 & f_y & c_y\\
    0 & 0 & 1\\
    \end{array}
    \right]

    \left[
    \begin{array}{lr}
    X\\
    Y\\
    Z\\
    \end{array}
    \right]
    =
    \frac{1}{Z} K P_c
    =
    \frac{1}{Z} K(RP_w + t)
    =
    \frac{1}{Z} KTP_w</script><p>$K$矩阵为相机的<strong>内参矩阵</strong>，相机标定的对象就是它</p>
<p>十四讲中说习惯会把Z乘到左边</p>
<script type="math/tex; mode=display">Z P_{uv} = KTP_w</script><p>如果对相机坐标系下的坐标进行归一化处理，那么$Z=1$，$P_{uv}=KP_c$，即乘以内参矩阵就得到了像素坐标。</p>
<p>所以像素坐标也被认为是对<strong>归一化平面</strong>上的坐标进行量化测量的结果。</p>
<h2 id="针孔模型与透镜"><a href="#针孔模型与透镜" class="headerlink" title="针孔模型与透镜"></a>针孔模型与透镜</h2><p>小孔成像是将一大堆光线挡住只让“一束光”穿过去成像，凸透镜是把所有光线聚集起来成像。</p>
<p><img src='core2.gif' width=600 title='hole'></p>
<p>知乎上图</p>
<p><a href="https://www.zhihu.com/question/299247177" target="_blank" rel="noopener">https://www.zhihu.com/question/299247177</a></p>
<p><img src='core.gif' width=600 title='2zero'></p>
<p>小孔成像可以理解为透镜成像在孔径（光圈）趋近于零的极限情况。另外当孔径趋近于零时，景深趋近于无穷，成像的亮度也趋于零。</p>
<h2 id="双目相机模型"><a href="#双目相机模型" class="headerlink" title="双目相机模型"></a>双目相机模型</h2><p>通过同一物体在双目左右成像面的像素坐标，判断物体的距离</p>
<p>图源十四讲</p>
<p><img src='stereo.png' width=600 title='2zero'></p>
<p>根据相似关系</p>
<script type="math/tex; mode=display">\frac{z-f}{z} = \frac{b-u_L+u_R}{b}</script><p>注意$u_R$为负，进而推出$z$的大小</p>
<script type="math/tex; mode=display">z = \frac{fb}{d}, \quad d = u_L - u_R</script><p>双目模型估计深度的难点在于，如何精确的确定左右图像的像素对应关系，计算视差$d$的难度很大</p>
<p>双目相机由于$d$最小为1像素，所以$Z$的测量是有上限的</p>
<h2 id="结构光与ToF相机"><a href="#结构光与ToF相机" class="headerlink" title="结构光与ToF相机"></a>结构光与ToF相机</h2><p>结构光相机向物体发射光斑或者条纹，再观察其形变来判断距离。</p>
<p><img src='slc.jpg' width=600 title='structured light camera'></p>
<p>ToF相机发射光线，测量返回光线的时间，来计算距离，Time of Flight。</p>
<p><img src='tof.png' width=600 title='ToF camera'></p>
<p>ToF相机和激光雷达有相似的地方，主动向外发射光线并用时间测距，不同的是激光雷达直接给出3D点云，ToF是给出一个RGB图像和一个深度图，不是一个3D的点云。</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>由类地址强制转换访问私有变量的方法</title>
    <url>/2021/02/27/%E7%94%B1%E7%B1%BB%E5%9C%B0%E5%9D%80%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用取地址的方式访问私有成员</p>
<a id="more"></a>
<p>对于定义在类的私有成员变量，可以通过取对象地址的方式直接推断出私有成员变量的地址，从而修改私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():val(<span class="number">5</span>),num(<span class="number">20</span>) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = A();</span><br><span class="line">	a.GetValue();</span><br><span class="line">	*((<span class="keyword">int</span>*)&amp;a + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line">	a.GetValue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>数据段存储在类的开头部分，与类里面定义的顺序无关。</p>
]]></content>
      <categories>
        <category>黑客入门</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>英语相近词辨析</title>
    <url>/2020/09/13/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E8%BF%91%E8%AF%8D%E8%BE%A8%E6%9E%90/</url>
    <content><![CDATA[<p>本篇为学习中遇到的相近单词的辨析，大多与计算机领域相关，按照首字母顺序排列</p>
<a id="more"></a>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><strong>amortized vs. average</strong></p>
<blockquote>
<p>Amortized time complexity is a worst-case estimate but considered over many repeated operations. If an operation has  O(f(n))  amortized time complexity, then individual operations may take more time than  O(f(n)) , but the mean time taken by a larger number of operations will be  O(f(n)) , over any input.</p>
<p>Average-case time complexity instead assumes that all inputs are equally likely. Some individual inputs may be worse than  O(f(n)) , but an input chosen at random will take time with expected value  O(f(n)) . A related notion is expected time complexity, which can refer either to assuming a random input or to randomizing the operation of the algorithm.</p>
</blockquote>
<ul>
<li>amortized complexity 分摊复杂度，在任意输入下重复很多次一个操作，有时候某个操作非常费时，但如果将时间均摊到每一次操作成本其实不一定很高</li>
<li>average complexity 平均复杂度，表示在不同输入下的复杂度的一种加权，是一种近似概率加权的模型</li>
</ul>
<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p><strong>memorization vs. memoization</strong></p>
<blockquote>
<p>As nouns the difference between memorization and memoization is that <em>memorization</em> is the act of committing something to memory or memorizing while <em>memoization</em> is (computer science) a technique in which partial results are recorded (forming a memo) and then can be re-used later without having to recompute them.</p>
</blockquote>
<ul>
<li>memorization 是常用名词‘记忆’，指代一般人脑的记忆活动</li>
<li>memoization 是计算机名词，特指为了后续使用便捷，将某些数据存储的过程</li>
</ul>
<p>备注：在fib递归的改进中遇到</p>
<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p><strong>recursion vs. recurrence</strong></p>
<blockquote>
<p>Recursion is a related term of recurrence. Recurrence is a related term of recursion.<br>As nouns the difference between recurrence and recursion is that <em>recurrence</em> is return or reversion to a certain state while <em>recursion</em> is the act of recurring.</p>
</blockquote>
<ul>
<li>recurrence 指的是返回值或者递归结果本身，可以翻译为‘迭代结果’</li>
<li>recursion 指的是迭代过程本身</li>
</ul>
<p>recursion trace 迭代追踪：绘制出迭代过程的图解</p>
<p>recurrence equation 递推方程：对递归模式进行数学归纳，例如</p>
<script type="math/tex; mode=display">
T(n) = T(n-1) + O(1)</script><p>备注：迭代分析的两种方法</p>
]]></content>
      <categories>
        <category>语言知识</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>集合类数据类型的迭代在JAVA中的实现</title>
    <url>/2020/06/14/%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%9C%A8JAVA%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>集合类数据类型包括背包Bag、栈Stack、队列Queue。它们的共同基本操作包括判断空集合isEmpty，添加Add，删除Delete，以及遍历集合元素foreach。这里对集合类数据类型的迭代方法如何实现做一个记录。</p>
<a id="more"></a>
<h2 id="实现迭代的基本要求"><a href="#实现迭代的基本要求" class="headerlink" title="实现迭代的基本要求"></a>实现迭代的基本要求</h2><p>一个用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Stack &lt;String&gt; Collection = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (String s: Collection)</span><br><span class="line">&#123;</span><br><span class="line">    StdOut.println(s);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">另一种等价写法为：</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">    String s = i.next();</span><br><span class="line">    StdOut.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知，在任意可迭代的集合数据类型中需要实现的东西：</p>
<ul>
<li>集合数据类型必须实现一个iterator（）方法并且返回一个<strong>Iterator</strong>对象；</li>
<li>Iterator类必须包含两个方法hasNext（），返回Boolean和next（），返回一个泛型元素</li>
</ul>
<h2 id="使用接口实现迭代方法iterator（）"><a href="#使用接口实现迭代方法iterator（）" class="headerlink" title="使用接口实现迭代方法iterator（）"></a>使用接口实现迭代方法iterator（）</h2><p>在Java中，使用接口的方式为类添加迭代所需方法iterator（）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.Iterable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">item</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如我们要实现一个集合数据类型Member，可以定义一个<strong>Iterator接口</strong>的类别DefinedIterator：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">item</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">item <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator的三个方法通常只要前两个实现即可，remove方法保持实现为空不影响遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span>&lt;<span class="title">item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">item</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;item&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> DefinedIterator&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DefinedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">item</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ...&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完成了迭代所需要的基本的实现。对于每一个具体不同的集合数据类型，在自定义的DefinedIterator里面可以实现不同的迭代细节，比如数组的和链表的实现方法对应的迭代方法就完全不同，需要自行去调整。</p>
<h2 id="一些值得额外记录的信息"><a href="#一些值得额外记录的信息" class="headerlink" title="一些值得额外记录的信息"></a>一些值得额外记录的信息</h2><p>在Java里面，泛型数组的直接初始化是不可以的，需要先new一些Object类别的数组，再强制转化为泛型的Item类别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Error:</span><br><span class="line"></span><br><span class="line">Member&lt;item&gt;[] members = <span class="keyword">new</span> Members&lt;item&gt;[N];</span><br><span class="line"></span><br><span class="line">Ok:</span><br><span class="line"></span><br><span class="line">Member&lt;item&gt;[] members = (Members&lt;item&gt;[]) <span class="keyword">new</span> Objects[N]</span><br></pre></td></tr></table></figure>
<p>这种方法会得到Warning，但可以执行。</p>
<hr>
<p>对于集合数据类型，需要常常做的操作是扩容和缩容（数组类），改变容量的原则是</p>
<ul>
<li>当填满集合时，容量变为目前的两倍</li>
<li>当数量不足容量的<strong>四分之一</strong>时，容量缩小为目前的<strong>二分之一</strong></li>
</ul>
<p>这种方法可以避免频繁的改变容量。扩容放在Push中，缩容放在Pop中，都是作为if的条件进行数量/容量判断，之后再执行进出的操作。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>现代控制理论2-状态空间表达式的分析求解</title>
    <url>/2021/03/16/%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA2-%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%88%86%E6%9E%90%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>在建立了状态空间表达式之后，求解状态变量的过程</p>
<a id="more"></a>
<h2 id="线性定常系统齐次方程的求解"><a href="#线性定常系统齐次方程的求解" class="headerlink" title="线性定常系统齐次方程的求解"></a>线性定常系统齐次方程的求解</h2><p>线性齐次的表达式如下，特征为没有输入变量 $u$</p>
<script type="math/tex; mode=display">\dot x(t)=Ax(t)</script><p>课本上对于这个问题的求解是先假设 $x(t)$ 的表达式为幂级数的和，再代回原方程求解待定系数，得到了</p>
<script type="math/tex; mode=display">x(t) = (I + At + \frac{1}{2!}A^2t^2 + \frac{1}{3!}A^3t^3...)x(0)</script><p>前面长长的系数可以写成矩阵指数 $e^{At}$ ，这个矩阵指数也被称作状态转移矩阵 $\Phi(t)$ ，代表从0时刻的状态进行了转移</p>
<hr>
<h2 id="状态转移矩阵的性质"><a href="#状态转移矩阵的性质" class="headerlink" title="状态转移矩阵的性质"></a>状态转移矩阵的性质</h2><p>有几条比较重要的性质</p>
<ol>
<li>在 $t=0$ 时状态转移矩阵为 $I$</li>
<li>可逆性，$\Phi(t) = (\Phi(-t))^{-1}，\Phi(t)\Phi(-t) = I$</li>
<li>结合律，状态转移矩阵可以连乘</li>
<li>不可交换性，连乘顺序不可改变</li>
</ol>
<hr>
<h2 id="状态转移矩阵的求法"><a href="#状态转移矩阵的求法" class="headerlink" title="状态转移矩阵的求法"></a>状态转移矩阵的求法</h2><p>有四种求法，最重要的是利用拉氏变换求解</p>
<ol>
<li>根据定义，计算无穷幂级数，计算机也只能计算有限项的近似解</li>
<li><p>应用拉普拉斯变换，转换到频域化简，再反变换求解</p>
<script type="math/tex; mode=display">\Phi(t) = \mathbb{L}^{-1}((sI-A)^{-1})</script></li>
<li><p>使用凯莱-哈密顿定理，求解n个系数，再求和</p>
</li>
<li><p>变换为对角阵，利用 $e^{Q\Lambda Q^{-1}} = Qe^{\Lambda} Q^{-1}$ 求解</p>
</li>
</ol>
<p>第四种方法对于不能对角化的阵，处理方式与前一章相同，即约当型或者分虚实部处理</p>
<hr>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>校内课程</tag>
        <tag>控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title>MITLinearAlgebra-4</title>
    <url>/2021/03/17/MITLinearAlgebra-4/</url>
    <content><![CDATA[<p>MIT线性代数笔记第四部分</p>
<ul>
<li>相似矩阵和若尔当型</li>
<li>奇异值分解</li>
<li>线性变换与对应矩阵</li>
<li>基变换与图形压缩</li>
<li>左右逆和伪逆</li>
</ul>
<a id="more"></a>
<p>完整链接:<br><a href="/2020/09/27/MITLinearAlgebra/" title="MITLinearAlgebra">MITLinearAlgebra</a><br><a href="/2020/11/13/MITLinearAlgebra-2/" title="MITLinearAlgebra(2)">MITLinearAlgebra(2)</a><br><a href="/2020/11/13/MITLinearAlgebra-3/" title="MITLinearAlgebra(3)">MITLinearAlgebra(3)</a><br><a href="/2021/03/17/MITLinearAlgebra-4/" title="MITLinearAlgebra-4">MITLinearAlgebra-4</a></p>
<h2 id="相似矩阵和若尔当型"><a href="#相似矩阵和若尔当型" class="headerlink" title="相似矩阵和若尔当型"></a>相似矩阵和若尔当型</h2><p>如果矩阵$A$的rank等于n，则严格大于零，$A^TA$具有正定性</p>
<p>当M是可逆矩阵的时候，如果</p>
<script type="math/tex; mode=display">B = M^{1}AM</script><p>则称B矩阵和矩阵A相似，<strong>相似矩阵具有相同的特征值！！</strong></p>
<p>证明过程并不复杂，通过原始的特征值的定义式可以表达出</p>
<script type="math/tex; mode=display">A x= \lambda x</script><script type="math/tex; mode=display">M^{-1}AMM^{-1} x = M^{-1}\lambda x</script><script type="math/tex; mode=display">B (M^{-1}x) = \lambda (M^{-1}x)</script><p><strong>单位矩阵的相似矩阵只有它自己</strong></p>
<hr>
<p>下面需要讨论无法对角化的情形，特征值出现重根，特征向量数量不足</p>
<p>矩阵只能努力变成最像对角型的矩阵,jordan form</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
4 & 1\\
0 & 4\\
\end{pmatrix},
\begin{pmatrix}
3 & 1\\
-1 & 5\\
\end{pmatrix},
\begin{pmatrix}
4 & 0\\
17 & 4\\
\end{pmatrix}</script><p>这些矩阵的特征值都是重根4，只有一个特征向量，他们无法化为对角型，因为对角型将会是单位矩阵的倍数，而单位矩阵的相似矩阵只有它自己。这些矩阵中第一个的形式被认为最好，被称为约当型（若尔当型）Jordan Form。</p>
<p>任何矩阵都可以化为 Jordan Form，其形式认为可以将所有的矩阵化为n块，n是特征向量的个数，每一块的上方是一些 1 。对于可对角化的矩阵来说，Jordan Form就是对角阵，而对于不太好的（不能对角化），Jordan Form是若干矩阵块的组合，每个矩阵块除了特征值就是1.</p>
<p>这个描述很抽象，教授也不打算讲授如何化为Jordan Form，这并不是学习重点。</p>
<p>线性代数的核心内容是SVD奇异值分解。</p>
<h2 id="SVD奇异值分解"><a href="#SVD奇异值分解" class="headerlink" title="SVD奇异值分解"></a>SVD奇异值分解</h2><p>每一个矩阵都有 SVD 分解，是一种最好的分解方式，左右都是正交矩阵，中间是对角阵</p>
<script type="math/tex; mode=display">
A = U\Sigma V^T</script><p>即使A是一个长方阵，即使A是一个奇异矩阵，也可以完成 SVD 分解</p>
<script type="math/tex; mode=display">A_{m \times n} = U_{m \times m} * \Sigma_{m\times n} * V^T_{n\times n}</script><p>对于非方阵，不具有特征值，而将其分解得到的两个正交矩阵可以得到特征值，我们分别称呼其为左奇异值（U）和右奇异值（V），它们反映了两组基向量。</p>
<p>SVD的目的可以写成将一组<strong>列空间中的基向量</strong> $[v_1, v_2,…,v_r]$ ，乘以矩阵 $A$ 转化为一组<strong>行空间中的基向量</strong> $[u_1, u_2, … u_r]$ , 转换后乘以<strong>比例因子</strong> $diag([\sigma_1, \sigma_2, … \sigma_r])$</p>
<script type="math/tex; mode=display">AV = U\Sigma</script><p>计算步骤：</p>
<ol>
<li>利用$AA^T$计算$U$的奇异值和奇异向量</li>
<li>利用$A^TA$计算$V$的奇异值和奇异向量</li>
<li>奇异值开根号, 取正数, 按照大小顺序, 由大至小放入$\Sigma$</li>
<li>按照奇异值的顺序, 将左右奇异向量分别排列好放入$U$, $V$, 两者需要对应 $Av_i = u_i\sigma_i$</li>
</ol>
<blockquote>
<p>SVD可以用于PCA主成分分解</p>
<p>$\Lambda = S^{-1}AS$可以理解为SVD的特例</p>
</blockquote>
<h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>线性变换T需要满足两条性质</p>
<ul>
<li>$T(u+v) = T(u) + T(v)$</li>
<li>$T(cv) = cT(v)$</li>
</ul>
<p>满足这两条性质的前提下，可以推导出</p>
<ul>
<li>T(0) = 0</li>
</ul>
<p><strong>投影变换</strong>、<strong>旋转</strong>、<strong>沿坐标轴镜像</strong>都是线性变换</p>
<p>直接对某一维度坐标不是线性变换，可以用性质简单证伪</p>
<p>坐标的概念来源于basis，如果坐标写出来，就一定决定了一组基向量，平常写向量的时候其实默认了正交基坐标</p>
<p>基坐标的选择不是随意的，选择正交基标准基或者特征向量是一个比较好的选择</p>
<p><strong>线性变换事实上就是从一组基到另一组基</strong></p>
<p>导数的求导也可以写成一种线性变换<br>从<br>$f = a + bx + cx^2$<br>到<br>$f = b + 2cx$</p>
<p>实际上相当于基从$1, x, x^2$变成了$1,x$</p>
<script type="math/tex; mode=display">
A \begin{pmatrix}
a \\
b\\
c
\end{pmatrix}
=
\begin{pmatrix}
b\\
2c
\end{pmatrix}</script><p>可以推导出对应的矩阵</p>
<script type="math/tex; mode=display">
A =  \begin{pmatrix}
0 & 1 & 0\\
0 & 0 & 2
\end{pmatrix}</script><p>逆线性变换就对应逆矩阵，矩阵的乘积等同于连续线性变换，矩阵的乘法正是来自于线性变换</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>operator :: in python</title>
    <url>/2021/04/02/operator-in-python/</url>
    <content><![CDATA[<p>运算符::的作用</p>
<a id="more"></a>
<p> :: 可以看作对切片的一种扩展，::前面的数字代表起始位置，后面的数字代表步长，步长为正则向后遍历，步长为负则向前遍历</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[:<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[::<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">1</span>::<span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>::<span class="number">3</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>::<span class="number">-1</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>::<span class="number">-2</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[::<span class="number">-2</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
