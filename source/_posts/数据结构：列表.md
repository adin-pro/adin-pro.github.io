---
title: 数据结构：列表
mathjax: true
date: 2020-10-07 14:22:17
tags:
- C++
- 基础知识
categories: 数据结构与算法
---

邓公《数据结构》第二种主要的数据结构列表。相比静态结构数组，列表的访问修改有着明显差别。

<!-- more -->

## 静态到动态

数据结构可以分为静态和动态的，列表list是动态储存策略的典型结构，其中元素称为**节点node**，各节点*通过指针或者引用彼此联接*，在逻辑上构成线性序列。

相邻节点分别为predecessor前驱，successor后继。这种相邻节点**如果存在则必然唯一**。

没有predecessor和successor的称为首（first/front）和末（last/rear）。

### 从秩到位置

向量支持循秩访问的方式：访问效率极高O（1）

对于列表而言，可以为每个节点设置秩rank这个属性，通过重载下标操作符访问，但是循秩访问的成本过高，应该改成**循位置访问call-by-position**，通过两两关系找到。

### 节点实现

列表节点node需要独立封装实现

```cpp
//ADT

#define Posi(T) ListNode<T>*
template <typename T>
struct Listnode { //简洁起见，完全开放不封装
T data;
Posi(T) pred;
Posi(T) succ;
ListNode() {}
ListNode(T e, Posi(T) p=NULL, Posi(T) s=NULL)
:data(), pred(p),succ(s){}
Posi(T) insertAsPred(T const& e);
Posi(T) insertAsSucc(T const& e);
};

```
**头head**、*首first、末last*、**尾trailer**对应秩-1，0，n-1，n 四个节点中两个**哨兵**

### 几种操作

插入:

```cpp
_size++;
p->pred->succ = new_p;
new_p->pred = p->pred;
p->pred = new_p;
new_p->succ = p
```

复制构造：先初始化首尾节点，再不断将要复制的节点作为trailer的前序插入

移除：
```cpp
p->pred->succ = p->succ;
p->succ->pred = p->pred;
_size--;

```

析构：先清空可见列表（反复删除header后继），再去除头尾节点

### 唯一化

1. 首先处理平凡情况
2. 记录原规模，p从首节点开始
3. 在p的r个真前驱中查找与之雷同的节点，删除前面的节点

## 有序列表

在唯一化中，有序列表的排列成*阶梯型*，目标就是保留每一阶阶梯的第一个节点，删除其余节点。复杂度O（n），相比无序列表提升较多。

查找的效率，有序和无序没有什么提高。call-by-pos没有call-by-rank对有序的提升那么大。

RAM模型是循秩，图灵机模型是循位置。

### 选择排序

bubblesort也是一种选择排序，不断选择未排序部分的最值然后将它有序无序的分界点。

这里讨论的是效率更高的选择排序，**减少交换次数**，一趟扫描直接找到最大元素搬运过去！比较适合列表，向量的操作会有很多元素的搬运。

### 插入排序

等于扑克牌排序的时候，每拿一张牌会将它插入到合适的位置。感觉也好适合链表来用。

和选择排序的区别：
- 选择排序总是把操作元素放到有序与无序的边界，无序部分的最大值不能大于有序部分的最小值
- 插入排序需要自己确定放入有序区间，无序部分与有序部分的大小没有关系

```cpp
template <typename T> void List<T>::insertionSort(Posi(T) p, int n){
    for (int r=0;r<n;r++){ // 逐一插入p之后的n个节点
        insertAfter(search(p->data,r,p), p->data); //查找+插入
        p = p->succ; remove(p->pred);//转向下一节点
    }//n次迭代，每次O（r+1）
}

//使用O（1）辅助空间，属于原地算法in-place
```

**插入排序最好情形下需要O（n），最坏情形下O(n^2)，选择排序所有情况下都需要O（n^2）**

但是很遗憾，计算平均性能的时候，复杂度还是O(n^2)这个级别，最好情况出现的概率很低啊。

*插入排序所需要的时间=O（inversion+n），逆序对是排序算法主要的工作量*

这种算法属于input-sensitive输入敏感的算法




