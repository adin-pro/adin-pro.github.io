---
title: 排序：归并排序
mathjax: true
date: 2020-06-21 11:13:17
tags:
- 算法
- JAVA
categories: 数据结构与算法
---

本章讨论的是归并排序算法，它的基本思路是把有序的小数组合并为大数组，同时也使用了递归的思想。归并排序可以保证任意长度为$N$的数组可以在正比于$NlogN$的时间里完成排序，但缺点是所需空间与$N$成正比。

<!-- more -->

<img src='guibing.JPG' size = '600' title='demonstration of the Merge Sort'>

## 原地归并

>原地排序算法： 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存

原地归并的思路并不复杂，先排序前半部分，再排序后半部分，然后不需额外空间的移动数组元素。但在算法实现中这种方案比较复杂。

一种原地归并的抽象化方法，使用了一个辅助数组aux。按照升序排列，两个已经排序好的数组依次比较各元素大小，挑选小的放进去。

```java
public static void merge(Comparable[] a, int lo, int mid, int hi)
{ // 将a[lo..mid] 和 a[mid+1..hi] 归并
    int i = lo, j = mid+1;
    for (int k = lo; k <= hi; k++) // 将a[lo..hi]复制到aux[lo..hi]
        aux[k] = a[k];
    for (int k = lo; k <= hi; k++) // 归并回到a[lo..hi]
        if (i > mid)                    a[k] = aux[j++]; // 前半个数组已经都排完了
        else if (j > hi )               a[k] = aux[i++]; // 后半个数组都已经排完了
        else if (less(aux[j], aux[i]))  a[k] = aux[j++]; // 挑选两个数组中最小值的较小值
        else                            a[k] = aux[i++];
}

```
## 自顶向下的归并排序

递归方法，不断分而治之，直到把数组分为一个个元素再合并起来。

```java
public class Merge
{
    private static Comparable[] aux; // 归并所需的辅助数组
    public static void sort(Comparable[] a)
    {
        aux = new Comparable[a.length]; // 一次性分配空间
        sort(a, 0, a.length - 1);
    }
    private static void sort(Comparable[] a, int lo, int hi)
    { // 将数组a[lo..hi]排序
        if (hi <= lo) return;
        int mid = lo + (hi - lo)/2;
        sort(a, lo, mid); // 将左半边排序
        sort(a, mid+1, hi); // 将右半边排序
        merge(a, lo, mid, hi); // 归并结果（代码见“原地归并的抽象方法”）
    }
}

```

<img src='merge.JPG' width = '600' title='demonstration of the Merge Sort'>

## 自底向上的归并排序


自顶向下的方法的合并顺序是按照树的顺序，使用递归的方法左右子树依次合并。而自底向上的归并排序则不是使用递归，而是两两合并，再四四合并，再八八合并，每次合并都是在全数据范围内进行的。

```java
public class MergeBU
{
    private static Comparable[] aux; // 归并所需的辅助数组
    // merge()方法的代码请见“原地归并的抽象方法”
    public static void sort(Comparable[] a)
    { // 进行lgN次两两归并
        int N = a.length;
        aux = new Comparable[N];
        for (int sz = 1; sz < N; sz = sz+sz) // sz子数组大小
            for (int lo = 0; lo < N-sz; lo += sz+sz) // lo:子数组索引
                merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
    }
}

```

<img src='merge-bu.png' width='600' title='merge-bu-visualization'>

>对于长度为N 的任意数组，自底向上的归并排序需要$1/2NlgN$ 至$NlgN$ 次比较，最多访问数组$6NlgN$ 次。

>当数组长度为2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同

>**自底向上的归并排序比较适合用链表组织的数据**。想象一下将链表先按大小为1 的子链表进行排序，然后是大小为2 的子链表，然后是大小为4 的子链表等。这种方法只需要重新组织链表链接就能将链表**原地排序**（不需要创建任何新的链表结点）


## 排序算法的复杂度

>没有任何基于比较的算法能够保证使用少于$lg（N!）$～ $NlgN$ 次比较将长度为N 的数组排序。

这个结论可以简单用树结构证明，每一张N个元素的排列方式是一个树的叶子，N个元素共有N！种排列，也就是这个树叶子的数目为N！，如果每一个节点代表比较了两个元素，每个节点比较之后会对应两种结果，也就是这个节点的左右子树。因此基于比较的算法可以表示为**一颗二叉树**，**需要比较的次数就是根到叶子节点的路径长度**，该长度最大就是一个二叉树的高度，即lg（N！），根据斯特灵公式可以近似表示为NlgN。对应着N元素数组的最坏情况。


>归并排序是一种渐进最优的基于比较排序的算法。

两者的复杂度类似都是$Nlg(N!)$

