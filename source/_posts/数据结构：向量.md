---
title: 数据结构：向量
mathjax: true
date: 2020-09-13 14:13:57
tags:
- C++
- 基础知识
categories: 数据结构与算法
---

邓公学堂在线MOOC+清华《数据结构第三版》的一些记录。本篇为向量部分。

<!-- more -->

抽象数据类型ADT与数据结构DS不同，后者包含着算法。

向量是对数组这种数据类型的抽象和泛化，元素的顺序使用秩**Rank**来表示。


________________________________________
|           │ Class │Subclass │ World  |
|           │       │         │        |
|───────────┼───────┼─────────┼────────|
|public     │   +   │    +    │   +    | 
|───────────┼───────┼─────────┼────────|
|protected  │   +   │    +    │        | 
|───────────┼───────┼─────────┼────────|
|private    │   +   │         │        |
|___________|_______|_________|________|
 + : accessible         blank : not accessible

继承的时候，同样分为public protected private继承，次时修饰符modifier代表派生类的被访问权限的上限（在此假定权限定义高低为public > protected > private）即如果private继承，类里面所有成员变量和成员函数都会变成private：如果public继承，保持不变；如果protected继承，只会将原先是public的降低至protected。

```cpp

//ADT interface of Vector

typedef int Rank;
#define DEFAULT_CAPCITY 3

template <typename T> class Vector{

private:
    
protected:
    T* _elem; Rank _size; int _capacity;
    ...... //auxiliary funcitons 
public:
    ...... // constructor and destructor and interface function
    Vector(int c=DEFACULT_CAPACTIY,int s=0, T v=0) { // all element are initialize to v
        _elem = new T[_capacity=c]; for(_size=0;_size<s,;_elem[size++]=v);
    }
    Vector (T const* A, Rank n) {copyfrom(A,0,n)}; //数组整体复制
    ...
};

```


## 扩容与缩容

装填因子$\lambda=\frac{_size}{_capacity}$表示目前向量有效元素的比例，一般在接近满的时候会扩容，当有效元素小于容量1/4的时候会缩容。

扩容的方法包括倍增式扩容以及固定增量扩容两种方式。

```cpp

// 倍增式扩容expand()

template <typename T> void Vector<T>::expand(){
    if (_size<_capacity) return;
    if (_capcity < DEFAULT_CAPACITY) _capacity = DEFAULT_CAPCITY;
    T* oldelem = _elem; _elem = new T[_capacity<<=1];
    for (int i=0;i<_size;i++) {
        _elem[i] = oldelem[i];
    }
    delete[] oldelem; // 记得调用delete[]

}

// 固定增量式扩容只需要改动第三句
...
T* oldelem = _elem; _elem = new T[_capacity+=increment]
...

```

对比这两种扩容方式，倍增式扩容在空间利用率上相对较低（但也大于50%），但是在时间复杂度上平摊只需O（1）的时间。相比固定增量式扩容需要O（n）的时间，这种空间上的不足是可以接受的。

*为什么倍增式扩容可以平摊到O(1)，而固定式扩容还是O(n)呢，原因在于不论每次输入的量是多大，只要之后每次这个输入量保持不变，倍增式扩容都会迅速的将capacity扩展到比这个输入量大很多，使得扩容的频率迅速下降，有一种自适应的能力（输入的越猛，增长的越猛）。但是固定式扩容，一旦输入大于固定增量，则每次输入都会产生扩容操作，导致复杂度一直都差不多是O(n)，没有一个自我调节的能力。*

**Average Running Time vs. amortized running time**

- 前面的是平均时间，指的是算法按照概率分布的期望运行时间，又可以称作expected running time，对实际运行情况的模拟不够好。割裂了各个操作的相关性和连贯性。
- 后面的叫做分摊时间，假定的是对向量做足够多次操作后，时间分摊至每一次操作的成本，更具有现实意义。

**一个习题与解答**

>Is it possible to replace:是否可以将视频里向量扩容代码中的：

>for (int i = 0; i < _size; i++) _elem[i] = oldElem[i];

>in the vector expansion code in the video with: 替代为：

>memcpy(_elem, oldElem, _size * sizeof(T));

>P.S.This question involves the relevant knowledge of C++ P.S.本题涉及C++的相关知识


解析：

When T is a non-base type and there is a corresponding assignment operator to perform deep copy, the previous section of code calls the assignment operator, and the latter section can only perform shallow copy. 当T为非基本类型且有对应的赋值运算符以执行深复制时，前一段代码会调用赋值运算符，而后一段只能进行浅复制。

缩容的实现与扩容基本一致，先比较size和capacity，再复制元素到新的elem中

```cpp

template <typnename T> void Vector<T> :: shrink(){
    if (_capacity < DEFAULT_CAPACITY<<1) return; // can not be smaller than the D_C
    if (_size<<2 > _capacity) return; // not small enough
    T* oldelem = _elem; _elem = new T[_capacity>>=1]; // shrink to half
    for (int i=0; i < _size; i++) _elem[i]=oldelem[i];
    delete[] oldElem;
}

```


## 操作符[]重载

为了获得下标式的元素引用方式A[i]，将向量操作符重载

```cpp

template <typename T> T& Vector <T> :: operator[](Rank r) const (return _elem[r])
// 此处对r的有效区间的讨论没做严格要求，实际使用时需要注意

```

## 插入insert(Rank r, T e)

```cpp

template <typename T> Rank Vector<T> :: insert(Rank r, T e){
    expand(); // expand if necessary
    for (int i=_size; i>r; i--)
        T[i] = T[i-1];
    T[r] = e;
    _size++;
    return r;
}

```

## 区间删除remove(Rank lo, Rank hi)

整体左移覆盖要删除的部分

```cpp

template <typename T> int Vector<T> :: remove(Rank lo, Rank hi){
    if (lo == hi) return 0;
    while(hi<_size) _elem[lo++] = _elem[hi++];
    _size = lo; shrink(); // _size = _size-(hi-lo)
    return hi - lo ;
}

```

>单个元素的删除可以看作区间删除的特例，但是区间删除不能看作单元素删除的特例，因为单独删除单元素也会有最坏O（n）的移动，已经和区间删除的复杂度相当了，如果反复执行这一过程会导致O（n^2）的复杂度，实际上是不可行的。

## 查找 find(T const& e, Rank lo, Rank hi)

从后向前找，返回秩最大的符合要求的元素的秩。若没有返回-1.

```cpp
template <typename T> Rank Vector<T> :: find(T const & e, Rank lo, Rank hi){
    while((lo<hi--) && e!= _elem[hi]);
    return hi;
}
```
> 最好情况O（1），最坏情况O（n），这种称为 **输入敏感** 问题


## 遍历

使用函数指针或者函数对象visit作为traverse的参数，从而实现对向量元素的遍历和操作。函数对象相比前者的应用范围更加广泛。

```cpp
template <typename T> void Vector<T> ::traverse(void(*visit) (T&)){
    for (int i=0; i <_size ; i++) { visit(_elem[i]);}
}

template <typename T> template <typename VST> 
 void Vector<T>:: traverse( VST& visit){
     for (int i = 0; i< _size;i++) visit(_elem[i]);
 }

```

-----

**在这里不理解什么是函数对象和函数指针，不会使用**

>As a function object class XXX, which of the following member functions must be explicitly defined: 作为一个函数对象的类XXX，它必须显式定义以下哪个成员函数
- XXX()
- ~XXX()
- operator[]()
- operator()()

For a function object, () is an operator used to perform a function call 对于函数对象来说，()是用于执行函数调用的操作符

## 有序向量

无序的向量元素之间只能判定是否相等，而有序的元素则能进行比较。

一般而言，如果能够将无序输入向量有序化，则能大幅提升算法的性能，并且有序化所带来的复杂度将小于算法优化减少的复杂度，对于算法的表现是有利的。



### 有序性甄别

使用计算邻接无序对数目的方式来判断

```cpp

template <typename T> int Vector<T> :: disorderd() const {
    int count;
    for(int i=0; i<_size ;i++){
        count += (_elem[i]>_elem[i+1]);
    }
}

```

### 低效率唯一化

没有充分利用有序化序列，调用太多次remove函数会导致效率低下

```cpp
template <typename T> int Vector<T> :: uniquify(){
    int oldSize = _size; int i=1;
    while(i<_size){
        _elem[i-1]==_elem[i]?remove(i):i++; // remove隐含_size的变化
    }
    return oldSize - _size;
}

```
### 高效率唯一化

```cpp

template <typename T> int Vector<T> :: uniquify(){
    int i=0; int j=0;
    while(++j<_size){
        _elem[i]!=elem[j]?_elem[++i]=_elem[j]:continue;//不知道这里三目可不可以空语句
    }
    _size = i;shrink();
    return j-i;
}
```

## 查找与排序算法

### 二分查找

复杂度约为1.5log（N） 仍有改进空间

### Fibonacci查找

二分查找如果把各种实例画成图似乎是平衡的，但是实际上由于程序每次判断大小时都先判断中点左部，再判断中点右部，导致向左和向右的比较成本不一样（1次 vs. 2次）也因此实际的算法是不平衡的，算法对于[lo,mi)这个区间的元素的查找起来比 (mi,hi)区间更为快速。

为了缓解这个问题，寻求最优解，可以考虑人为的将这个图左右两侧长度设置为不一样的，左边既然搜索的快区间就长一点，右边既然慢就降低难度让它短一点，来追求左右侧的平衡，并尝试是否为最优查找。

<img src='fib.png' width = '800' title = 'binary search vs. fibonacci search'>

两者的区别只在于mi点的选取，fibonacci取在了黄金分割点。

```cpp

template <typename T> static Rank fibSearch(T* A, const T& e, Rank lo, Rank hi){
    Fib fib(hi-lo);//创建了fibonacci数列类
    while(lo<hi){
        while (hi-lo < fib.get()) fib.prev(); // fib(k-1)
        Rank mi = lo + fib.get() - 1 //fib(k-1)-1
        if (e<A[mi]) hi = mi;
        else if (A[mi]<e) lo = mi;
        else return mi;
    }
}


```

## 插值查找

Interpolation Search

当一个序列有了近似的规律的时候，可以利用插值的方式确定近似的区间，就好比翻查字典的时候如果是按照A-Z的分布，去寻找W这个部分的单词肯定不会从中间二分查找，而是会按照近似比例的方法去确定一个大致位置。

1. 已知lo和hi位置的值，还知道e，计算出e对应的大概位置
2. 比较位置元素和e的大小，确定下一段区间
3. 再次计算e的大概位置

如果输入数据不符合均匀独立分布，会变成病态问题，导致时间复杂度升到O（n）

每经过一次比较，插值查找就可以将查找范围从n缩小至$\sqrt{n}$

**从二进制字宽方面考虑，一个数值为n的值，它用二进制表示的字宽就是$\log{n}$，而当范围缩小为$\sqrt{n}$时，对应的二进制字宽折半，变成$\frac{1}{2}\log{n}$，因而从字宽角度考虑让字宽小于1位所需要的时间就是$\log\log{n}$**

*缺点*
*1. 容易受到病态数据影响导致复杂度升高O（n）*
*2. 需要计算乘法和除法，相比加减法需要的运算更为复杂*

### 综合对比

binary search；fibonacci search；interpolation search各有特点

使用建议为结合使用：
- 大数据用interpolation迅速减小规模
- 中等数据使用binary搜索
- 小数据直接遍历

## 排序

```cpp

template <typename T> void Vector<T> :: sort(Rank lo, Rank hi){
    switch(rand()%5){
        case 1: bubblesort(Rank lo, Rank hi); break;
        case 2: selectionSort(Rank lo, Rank hi); break;
        case 3: heapSort(Rank lo, Rank hi); break;
        case 4: quickSort(Rank lo, Rank hi); break;
        default: mergeSort(Rank lo, Rank hi); break;
    }
}


```


## 气泡排序

最简单的二重遍历bubblesort没有什么意思，这里增加了一个sorted标志位，用于提前结束bubblesort过程，减少无谓的遍历。

```cpp

template <typename T> void Vector<T> :: bubbleSort(Rank lo, Rank hi){
    while(!bubble(Rank lo, Rank hi));
}
template <typename T> bool Vector<T> :: bubble(Rank lo, Rank hi){
    bool sorted = true;
    while(++lo <  hi){
        if (_elem[lo] < _elem[lo-1]) swap(_elem[lo-1],_elem[lo]);
        sorted = false;
    }
    return sorted;
}

```
进一步的改进，挪动bubble中hi的位置，进而减少后部已排列元素的扫描

```cpp
template <typename T> void Vector<T> :: bubbleSort(Rank lo, Rank hi){
    while(lo < hi=bubble(Rank lo, Rank hi));
}
template <typename T> Rank Vector<T> :: bubble(Rank lo, Rank hi){
    Rank last = 0;
    while(++lo <  hi){
        if (_elem[lo] < _elem[lo-1]) swap(_elem[lo-1],_elem[lo]);
        last = lo;
    }
    return last;
}
```

**算法的稳定性**：算法排序前后相同数值的元素大小不变

## 归并排序

归并排序是一个古老/经典的算法，由冯诺依曼提出，主要思想就是分而治之，可以参考之前算法4里面的文章。

{% post_link 排序：归并排序 %}

