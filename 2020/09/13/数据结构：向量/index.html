<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bitbug_favicon-m.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon.ico">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="邓公学堂在线MOOC+清华《数据结构第三版》的一些记录。本篇为向量部分。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构：向量">
<meta property="og:url" content="http://yoursite.com/2020/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%90%91%E9%87%8F/index.html">
<meta property="og:site_name" content="不愧是我">
<meta property="og:description" content="邓公学堂在线MOOC+清华《数据结构第三版》的一些记录。本篇为向量部分。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%90%91%E9%87%8F/fib.png">
<meta property="article:published_time" content="2020-09-13T06:13:57.000Z">
<meta property="article:modified_time" content="2020-10-07T06:17:36.000Z">
<meta property="article:author" content="Adin">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%90%91%E9%87%8F/fib.png">

<link rel="canonical" href="http://yoursite.com/2020/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%90%91%E9%87%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构：向量 | 不愧是我</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不愧是我</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">想法和故事打包于此</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">24</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间线<span class="badge">45</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%90%91%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Adin">
      <meta itemprop="description" content="nobody">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不愧是我">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构：向量
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 14:13:57" itemprop="dateCreated datePublished" datetime="2020-09-13T14:13:57+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-07 14:17:36" itemprop="dateModified" datetime="2020-10-07T14:17:36+08:00">2020-10-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>邓公学堂在线MOOC+清华《数据结构第三版》的一些记录。本篇为向量部分。</p>
<a id="more"></a>
<p>抽象数据类型ADT与数据结构DS不同，后者包含着算法。</p>
<p>向量是对数组这种数据类型的抽象和泛化，元素的顺序使用秩<strong>Rank</strong>来表示。</p>
<hr>
<p>继承的时候，同样分为public protected private继承，次时修饰符modifier代表派生类的被访问权限的上限（在此假定权限定义高低为public &gt; protected &gt; private）即如果private继承，类里面所有成员变量和成员函数都会变成private：如果public继承，保持不变；如果protected继承，只会将原先是public的降低至protected。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//ADT interface of Vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_CAPCITY 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    T* _elem; Rank _size; <span class="keyword">int</span> _capacity;</span><br><span class="line">    ...... <span class="comment">//auxiliary funcitons </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...... <span class="comment">// constructor and destructor and interface function</span></span><br><span class="line">    Vector(<span class="keyword">int</span> c=DEFACULT_CAPACTIY,<span class="keyword">int</span> s=<span class="number">0</span>, T v=<span class="number">0</span>) &#123; <span class="comment">// all element are initialize to v</span></span><br><span class="line">        _elem = <span class="keyword">new</span> T[_capacity=c]; <span class="keyword">for</span>(_size=<span class="number">0</span>;_size&lt;s,;_elem[size++]=v);</span><br><span class="line">    &#125;</span><br><span class="line">    Vector (T <span class="keyword">const</span>* A, Rank n) &#123;copyfrom(A,<span class="number">0</span>,n)&#125;; <span class="comment">//数组整体复制</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>装填因子$\lambda=\frac{_size}{_capacity}$表示目前向量有效元素的比例，一般在接近满的时候会扩容，当有效元素小于容量1/4的时候会缩容。</p>
<p>扩容的方法包括倍增式扩容以及固定增量扩容两种方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 倍增式扩容expand()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::expand()&#123;</span><br><span class="line">    <span class="keyword">if</span> (_size&lt;_capacity) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (_capcity &lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPCITY;</span><br><span class="line">    T* oldelem = _elem; _elem = <span class="keyword">new</span> T[_capacity&lt;&lt;=<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;_size;i++) &#123;</span><br><span class="line">        _elem[i] = oldelem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] oldelem; <span class="comment">// 记得调用delete[]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定增量式扩容只需要改动第三句</span></span><br><span class="line">...</span><br><span class="line">T* oldelem = _elem; _elem = <span class="keyword">new</span> T[_capacity+=increment]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对比这两种扩容方式，倍增式扩容在空间利用率上相对较低（但也大于50%），但是在时间复杂度上平摊只需O（1）的时间。相比固定增量式扩容需要O（n）的时间，这种空间上的不足是可以接受的。</p>
<p><em>为什么倍增式扩容可以平摊到O(1)，而固定式扩容还是O(n)呢，原因在于不论每次输入的量是多大，只要之后每次这个输入量保持不变，倍增式扩容都会迅速的将capacity扩展到比这个输入量大很多，使得扩容的频率迅速下降，有一种自适应的能力（输入的越猛，增长的越猛）。但是固定式扩容，一旦输入大于固定增量，则每次输入都会产生扩容操作，导致复杂度一直都差不多是O(n)，没有一个自我调节的能力。</em></p>
<p><strong>Average Running Time vs. amortized running time</strong></p>
<ul>
<li>前面的是平均时间，指的是算法按照概率分布的期望运行时间，又可以称作expected running time，对实际运行情况的模拟不够好。割裂了各个操作的相关性和连贯性。</li>
<li>后面的叫做分摊时间，假定的是对向量做足够多次操作后，时间分摊至每一次操作的成本，更具有现实意义。</li>
</ul>
<p><strong>一个习题与解答</strong></p>
<blockquote>
<p>Is it possible to replace:是否可以将视频里向量扩容代码中的：</p>
<p>for (int i = 0; i &lt; _size; i++) _elem[i] = oldElem[i];</p>
<p>in the vector expansion code in the video with: 替代为：</p>
<p>memcpy(_elem, oldElem, _size * sizeof(T));</p>
<p>P.S.This question involves the relevant knowledge of C++ P.S.本题涉及C++的相关知识</p>
</blockquote>
<p>解析：</p>
<p>When T is a non-base type and there is a corresponding assignment operator to perform deep copy, the previous section of code calls the assignment operator, and the latter section can only perform shallow copy. 当T为非基本类型且有对应的赋值运算符以执行深复制时，前一段代码会调用赋值运算符，而后一段只能进行浅复制。</p>
<p>缩容的实现与扩容基本一致，先比较size和capacity，再复制元素到新的elem中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;typnename T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: shrink()&#123;</span><br><span class="line">    <span class="keyword">if</span> (_capacity &lt; DEFAULT_CAPACITY&lt;&lt;<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// can not be smaller than the D_C</span></span><br><span class="line">    <span class="keyword">if</span> (_size&lt;&lt;<span class="number">2</span> &gt; _capacity) <span class="keyword">return</span>; <span class="comment">// not small enough</span></span><br><span class="line">    T* oldelem = _elem; _elem = <span class="keyword">new</span> T[_capacity&gt;&gt;=<span class="number">1</span>]; <span class="comment">// shrink to half</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; _size; i++) _elem[i]=oldelem[i];</span><br><span class="line">    <span class="keyword">delete</span>[] oldElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作符-重载"><a href="#操作符-重载" class="headerlink" title="操作符[]重载"></a>操作符[]重载</h2><p>为了获得下标式的元素引用方式A[i]，将向量操作符重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; Vector &lt;T&gt; :: <span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span> (<span class="keyword">return</span> _elem[r])</span><br><span class="line"><span class="comment">// 此处对r的有效区间的讨论没做严格要求，实际使用时需要注意</span></span><br></pre></td></tr></table></figure>
<h2 id="插入insert-Rank-r-T-e"><a href="#插入insert-Rank-r-T-e" class="headerlink" title="插入insert(Rank r, T e)"></a>插入insert(Rank r, T e)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt; :: insert(Rank r, T e)&#123;</span><br><span class="line">    expand(); <span class="comment">// expand if necessary</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=_size; i&gt;r; i--)</span><br><span class="line">        T[i] = T[i<span class="number">-1</span>];</span><br><span class="line">    T[r] = e;</span><br><span class="line">    _size++;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间删除remove-Rank-lo-Rank-hi"><a href="#区间删除remove-Rank-lo-Rank-hi" class="headerlink" title="区间删除remove(Rank lo, Rank hi)"></a>区间删除remove(Rank lo, Rank hi)</h2><p>整体左移覆盖要删除的部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: remove(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hi&lt;_size) _elem[lo++] = _elem[hi++];</span><br><span class="line">    _size = lo; shrink(); <span class="comment">// _size = _size-(hi-lo)</span></span><br><span class="line">    <span class="keyword">return</span> hi - lo ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单个元素的删除可以看作区间删除的特例，但是区间删除不能看作单元素删除的特例，因为单独删除单元素也会有最坏O（n）的移动，已经和区间删除的复杂度相当了，如果反复执行这一过程会导致O（n^2）的复杂度，实际上是不可行的。</p>
</blockquote>
<h2 id="查找-find-T-const-amp-e-Rank-lo-Rank-hi"><a href="#查找-find-T-const-amp-e-Rank-lo-Rank-hi" class="headerlink" title="查找 find(T const&amp; e, Rank lo, Rank hi)"></a>查找 find(T const&amp; e, Rank lo, Rank hi)</h2><p>从后向前找，返回秩最大的符合要求的元素的秩。若没有返回-1.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt; :: find(T <span class="keyword">const</span> &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">while</span>((lo&lt;hi--) &amp;&amp; e!= _elem[hi]);</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最好情况O（1），最坏情况O（n），这种称为 <strong>输入敏感</strong> 问题</p>
</blockquote>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>使用函数指针或者函数对象visit作为traverse的参数，从而实现对向量元素的遍历和操作。函数对象相比前者的应用范围更加广泛。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; ::traverse(<span class="keyword">void</span>(*visit) (T&amp;))&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;_size ; i++) &#123; visit(_elem[i]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; </span><br><span class="line"> <span class="keyword">void</span> Vector&lt;T&gt;:: traverse( VST&amp; visit)&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; _size;i++) visit(_elem[i]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>在这里不理解什么是函数对象和函数指针，不会使用</strong></p>
<blockquote>
<p>As a function object class XXX, which of the following member functions must be explicitly defined: 作为一个函数对象的类XXX，它必须显式定义以下哪个成员函数</p>
<ul>
<li>XXX()</li>
<li>~XXX()</li>
<li>operator<a href=""></a></li>
<li>operator()()</li>
</ul>
</blockquote>
<p>For a function object, () is an operator used to perform a function call 对于函数对象来说，()是用于执行函数调用的操作符</p>
<h2 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h2><p>无序的向量元素之间只能判定是否相等，而有序的元素则能进行比较。</p>
<p>一般而言，如果能够将无序输入向量有序化，则能大幅提升算法的性能，并且有序化所带来的复杂度将小于算法优化减少的复杂度，对于算法的表现是有利的。</p>
<h3 id="有序性甄别"><a href="#有序性甄别" class="headerlink" title="有序性甄别"></a>有序性甄别</h3><p>使用计算邻接无序对数目的方式来判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: disorderd() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;_size ;i++)&#123;</span><br><span class="line">        count += (_elem[i]&gt;_elem[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="低效率唯一化"><a href="#低效率唯一化" class="headerlink" title="低效率唯一化"></a>低效率唯一化</h3><p>没有充分利用有序化序列，调用太多次remove函数会导致效率低下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: uniquify()&#123;</span><br><span class="line">    <span class="keyword">int</span> oldSize = _size; <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;_size)&#123;</span><br><span class="line">        _elem[i<span class="number">-1</span>]==_elem[i]?remove(i):i++; <span class="comment">// remove隐含_size的变化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高效率唯一化"><a href="#高效率唯一化" class="headerlink" title="高效率唯一化"></a>高效率唯一化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt; :: uniquify()&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++j&lt;_size)&#123;</span><br><span class="line">        _elem[i]!=elem[j]?_elem[++i]=_elem[j]:<span class="keyword">continue</span>;<span class="comment">//不知道这里三目可不可以空语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    _size = i;shrink();</span><br><span class="line">    <span class="keyword">return</span> j-i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找与排序算法"><a href="#查找与排序算法" class="headerlink" title="查找与排序算法"></a>查找与排序算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>复杂度约为1.5log（N） 仍有改进空间</p>
<h3 id="Fibonacci查找"><a href="#Fibonacci查找" class="headerlink" title="Fibonacci查找"></a>Fibonacci查找</h3><p>二分查找如果把各种实例画成图似乎是平衡的，但是实际上由于程序每次判断大小时都先判断中点左部，再判断中点右部，导致向左和向右的比较成本不一样（1次 vs. 2次）也因此实际的算法是不平衡的，算法对于[lo,mi)这个区间的元素的查找起来比 (mi,hi)区间更为快速。</p>
<p>为了缓解这个问题，寻求最优解，可以考虑人为的将这个图左右两侧长度设置为不一样的，左边既然搜索的快区间就长一点，右边既然慢就降低难度让它短一点，来追求左右侧的平衡，并尝试是否为最优查找。</p>
<p><img src='fib.png' width = '800' title = 'binary search vs. fibonacci search'></p>
<p>两者的区别只在于mi点的选取，fibonacci取在了黄金分割点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span><span class="params">(T* A, <span class="keyword">const</span> T&amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="function">Fib <span class="title">fib</span><span class="params">(hi-lo)</span></span>;<span class="comment">//创建了fibonacci数列类</span></span><br><span class="line">    <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">        <span class="keyword">while</span> (hi-lo &lt; fib.get()) fib.prev(); <span class="comment">// fib(k-1)</span></span><br><span class="line">        Rank mi = lo + fib.get() - <span class="number">1</span> <span class="comment">//fib(k-1)-1</span></span><br><span class="line">        <span class="keyword">if</span> (e&lt;A[mi]) hi = mi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mi]&lt;e) lo = mi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>Interpolation Search</p>
<p>当一个序列有了近似的规律的时候，可以利用插值的方式确定近似的区间，就好比翻查字典的时候如果是按照A-Z的分布，去寻找W这个部分的单词肯定不会从中间二分查找，而是会按照近似比例的方法去确定一个大致位置。</p>
<ol>
<li>已知lo和hi位置的值，还知道e，计算出e对应的大概位置</li>
<li>比较位置元素和e的大小，确定下一段区间</li>
<li>再次计算e的大概位置</li>
</ol>
<p>如果输入数据不符合均匀独立分布，会变成病态问题，导致时间复杂度升到O（n）</p>
<p>每经过一次比较，插值查找就可以将查找范围从n缩小至$\sqrt{n}$</p>
<p><strong>从二进制字宽方面考虑，一个数值为n的值，它用二进制表示的字宽就是$\log{n}$，而当范围缩小为$\sqrt{n}$时，对应的二进制字宽折半，变成$\frac{1}{2}\log{n}$，因而从字宽角度考虑让字宽小于1位所需要的时间就是$\log\log{n}$</strong></p>
<p><em>缺点</em><br><em>1. 容易受到病态数据影响导致复杂度升高O（n）</em><br><em>2. 需要计算乘法和除法，相比加减法需要的运算更为复杂</em></p>
<h3 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h3><p>binary search；fibonacci search；interpolation search各有特点</p>
<p>使用建议为结合使用：</p>
<ul>
<li>大数据用interpolation迅速减小规模</li>
<li>中等数据使用binary搜索</li>
<li>小数据直接遍历</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: sort(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(rand()%<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: bubblesort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: selectionSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: heapSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: quickSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: mergeSort(Rank lo, Rank hi); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="气泡排序"><a href="#气泡排序" class="headerlink" title="气泡排序"></a>气泡排序</h2><p>最简单的二重遍历bubblesort没有什么意思，这里增加了一个sorted标志位，用于提前结束bubblesort过程，减少无谓的遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: bubbleSort(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!bubble(Rank lo, Rank hi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Vector&lt;T&gt; :: bubble(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(++lo &lt;  hi)&#123;</span><br><span class="line">        <span class="keyword">if</span> (_elem[lo] &lt; _elem[lo<span class="number">-1</span>]) swap(_elem[lo<span class="number">-1</span>],_elem[lo]);</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步的改进，挪动bubble中hi的位置，进而减少后部已排列元素的扫描</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt; :: bubbleSort(Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi=bubble(Rank lo, Rank hi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt; :: bubble(Rank lo, Rank hi)&#123;</span><br><span class="line">    Rank last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++lo &lt;  hi)&#123;</span><br><span class="line">        <span class="keyword">if</span> (_elem[lo] &lt; _elem[lo<span class="number">-1</span>]) swap(_elem[lo<span class="number">-1</span>],_elem[lo]);</span><br><span class="line">        last = lo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法的稳定性</strong>：算法排序前后相同数值的元素大小不变</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一个古老/经典的算法，由冯诺依曼提出，主要思想就是分而治之，可以参考之前算法4里面的文章。</p>
<a href="/2020/06/21/%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" title="排序：归并排序">排序：归并排序</a>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag"># 基础知识</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/13/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E8%BF%91%E8%AF%8D%E8%BE%A8%E6%9E%90/" rel="prev" title="英语相近词辨析">
      <i class="fa fa-chevron-left"></i> 英语相近词辨析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/23/C-%E8%8D%89%E7%A8%BF%E6%9C%AC/" rel="next" title="C++草稿本">
      C++草稿本 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#扩容与缩容"><span class="nav-number">1.</span> <span class="nav-text">扩容与缩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符-重载"><span class="nav-number">2.</span> <span class="nav-text">操作符[]重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入insert-Rank-r-T-e"><span class="nav-number">3.</span> <span class="nav-text">插入insert(Rank r, T e)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间删除remove-Rank-lo-Rank-hi"><span class="nav-number">4.</span> <span class="nav-text">区间删除remove(Rank lo, Rank hi)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找-find-T-const-amp-e-Rank-lo-Rank-hi"><span class="nav-number">5.</span> <span class="nav-text">查找 find(T const&amp; e, Rank lo, Rank hi)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历"><span class="nav-number">6.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序向量"><span class="nav-number">7.</span> <span class="nav-text">有序向量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性甄别"><span class="nav-number">7.1.</span> <span class="nav-text">有序性甄别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#低效率唯一化"><span class="nav-number">7.2.</span> <span class="nav-text">低效率唯一化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高效率唯一化"><span class="nav-number">7.3.</span> <span class="nav-text">高效率唯一化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找与排序算法"><span class="nav-number">8.</span> <span class="nav-text">查找与排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-number">8.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fibonacci查找"><span class="nav-number">8.2.</span> <span class="nav-text">Fibonacci查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插值查找"><span class="nav-number">9.</span> <span class="nav-text">插值查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#综合对比"><span class="nav-number">9.1.</span> <span class="nav-text">综合对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">10.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#气泡排序"><span class="nav-number">11.</span> <span class="nav-text">气泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">12.</span> <span class="nav-text">归并排序</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Adin"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Adin</p>
  <div class="site-description" itemprop="description">nobody</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/adin-pro" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;adin-pro" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ding_yin@yeah.net" title="E-Mail → mailto:ding_yin@yeah.net" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
